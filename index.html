<!DOCTYPE html>
<script type="text/javascript" src="./purify.js"></script>
<script type="text/javascript" src="./DDEABI.js"></script>
<script type="text/javascript" src="./ERC20.js"></script>
<script type="text/javascript" src="./crypto-sha256.js"></script>
<script type="text/javascript" src="./crypto-js.js"></script>
<script type="text/javascript" src="./bignumber.min.js"></script>
<script type="text/javascript" src="./sweetalert211.js"></script>
<script type="text/javascript" src="./cryptico.min.js"></script>
<script type="text/javascript" src="./axios.min.js"></script>
<script type="text/javascript" src="./web3.min.js"></script>
<script type="text/javascript" src="./jdenticon.min.js"></script>
<script type="text/javascript" src="./simple-scrollbar.min.js"></script>
<script src="lottie-player.js"></script>
<link rel="stylesheet" href="./open-sans.css">
<link rel="stylesheet" href="./simple-scrollbar.css">
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript" src="./translate.js"></script>
  <script type="text/javascript" src="./faq.js"></script>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <title t-id="1">BitBay Decentralized Markets</title>
  <style>
    ::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: #263886;
}
* {
  box-sizing: border-box;
}
.swal2-popup {
  background-color: #ededed; /* Background color */
  color: #000000; /* Text color */
  border: 2px solid #3d0064; /* Border color */
  border-radius: 4px; /* Border radius */
  font-size: 11px;
  font-family: 'Courier New', monospace; /* Custom font */
  font-weight: normal;
  z-index: 1000;
}
.swal2-title {
  color: #3d0064; /* Title text color */
}
.swal2-content {
  color: #3d0064; /* Content text color */
}
.swal2-confirm,
.swal2-cancel {
  background-color: #ededed; /* Confirm and cancel button background color */
  color: #3d0064; /* Button text color */
}
/* Hover effect for buttons */
.swal2-confirm:hover,
.swal2-cancel:hover {
  background-color: #0086e3;
}
/* Icon color */
.swal2-icon {
  color: #3d0064;
}
.swal2-range {
  background-color: #ededed; /* Set your desired background color */
  border: 2px solid #3d0064;
}

/* Customize the appearance of the scrollbar thumb (handle) */
.simple-scrollbar .ss-scroll::-webkit-scrollbar-thumb {
  background-color: #555;
}
body {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
  font-size: 14px;
}
html, body {
  direction: ltr;
  unicode-bidi: embed;
}
#languageSelect {
  padding: 10px;
  font-size: 16px;
}
#selectedFlag {
  width: 30px;
  height: 30px;
  margin-right: 15px;
}
.container.site-container {
  display: flex;
  flex-direction: row;
  height: calc(100vh - 140px);
}
.sidebar {
    width: 104px;
    background: transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 10px;
    padding-bottom: 30px;
}
.sidebar-background {
  position: absolute;
  width: 104px;
  height: 100%;
  padding-top: 10px;
  padding-bottom: 30px;
  background-image: url('./purple-gradient.png');
  z-index: -1;
}
.sidebar button {
  background-color: transparent;
  padding: 0;
  width: 65px;
  height: 65px;
  margin: 0;
  margin-bottom: 40px;
  border: none;
  color: white;
  font-size: 14px;
  font-weight: normal;
  cursor: pointer;
  border-radius: 5px;
}
.sidebar .sidebar-icons {
  background-color: #e3e3e3;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 5px;
  padding: 15px;
  margin-bottom: 8px;
}
.sidebar button.active .sidebar-icons {
  background-color: #fff;
}
.sidebar button svg {
  width: 100%;
  height: 100%;
}
.sidebar button svg path {
  fill: #322c62;
}
.sidebar button.active svg path, .sidebar button.active svg path g {
  fill: #7066E0;
}
.main {
  flex: 1;
  padding: 20px;
  display: none;
}
.main.show {
  display: block;
}
.connectionstatus {
  font-size: 8.5px;
  display: none;
}
.header {
  height: 90px;
  background-color: #322c62;
  color: white;
  font-family: 'Open Sans', sans-serif;
  font-weight: 300;
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 0 20px;
  box-shadow: 0 2px 5px #7d71c3;
  position: relative;
}
.header2 {
  height: 80px;
  background-image: url("tabs-bg.png");
  background-repeat: no-repeat;
  background-size: 100% 100%;
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 0 20px;
  margin-bottom: 18px;
  justify-content: space-between;
}
.header2 a {
  font-size: 16px;
  color: white;
  font-weight: bold;
  text-decoration: none;
}
.header2 a:not(:last-child) {
  margin-right: 80px;
}
/* Change link color on hover */
.header2 a:hover, .header2 a.active {
  color: #00a7f0;
}
.header h1 {
  font-size: 12px;
  margin: 0;
  margin-left: 10px;
  flex: 1;
}
.escrow-container {
  font-size: 10px;
}
.tabcontent {
  font-size: 10px;
}
.mobile-pagination-select {
  display: none;
}
.offer-popup-wrapper .arrows-container span {
  background-color: #322C62;
  color: white;
  height: 25px;
  width: 25px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
}
.offer-popup-wrapper .arrows-container .left-arrow {
  position: absolute;
  left: 0;
  top: 0;
}
.offer-popup-wrapper .arrows-container .right-arrow {
  position: absolute;
  right: 0;
  top: 0;
}
.category-purchase-popup {
  text-align: center;
}
.category-purchase-popup .detail-content {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 10px;
  color: black;
}
.modal-shade-bg {
  position: fixed;
  min-height: 100vh;
  background-color: #808080bd;
  width: 100%;
  top: 0;
  left: 0;
  z-index: 99;
  display: flex;
  align-items: center;
  justify-content: center;
}
.category-purchase-popup {
  text-align: center;
  background-color: white;
  border-radius: 6px;
  padding: 20px;
}
.account-details-wrapper {
  overflow-x: hidden;
}
@media screen and (min-width: 600px) {
  .connectionstatus {
    font-size: 8.5px;
    display: block;
  }
  .escrow-container {
    font-size: 13px;
  }
  .tabcontent {
    font-size: 13px;
  }
  /* .sidebar-background {
        position: absolute;
        width: 100px;
        height: 100%;
        padding-top: 10px;
        padding-bottom: 30px;
        background-image: url('./purple-gradient.png');
        z-index: -1;
      } */
  /* .sidebar {
          width: 100px;
          background-color: transparent;
          display: flex;
          flex-direction: column;
          align-items: center;
          padding-top: 10px;
          padding-bottom: 30px;
      }
      .sidebar button {
          width: 80px;
          height: 80px;
          font-size: 13px;
          margin-bottom: 10px;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          display: flex;
          flex-direction: column;
          align-items: center;
          text-align: center;
      }
      .sidebar button img {
          margin-top: 15px;
          width: 30px;
          height: 30px;
      } */
}
@media screen and (min-width: 800px) {
  .header h1 {
            font-size: 20px; /* Adjust the font size for larger screens */
    font-weight: 600;
  }
  .connectionstatus {
    font-size: 12px;
    display: block;
  }
}
.header button {
  padding: 10px;
  background-color: #ccc;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-right: 10px;
}
.connect {
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-left: auto;
}
.connect button {
  background-color: #4caf50;
  border: 2px solid #4caf50;
  color: #fff;
  margin-right: 10px;
  font-size: 14px;
  font-weight: bold;
  padding: 0 12px;
  height: 42px;
  min-width: 150px;
}
.connect button:hover {
  color: #4caf50;
  background-color: transparent;
}
.footer {
  position: fixed;
  left: 0;
  bottom: 0;
  height: 50px;
  width: 100%;
  background-color: #5c519e;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  box-shadow: 0 -2px 5px #322c62;
  z-index: 10;
}
.footer img {
  width: 30px;
  height: 30px;
  margin: 0 10px;
  cursor: pointer;
}
.main.markets {
  min-height: calc(100% - 75); /* Subtract footer height */
  max-height: calc(100% - 75); /* Subtract footer height */
  overflow-y: auto; /* Enable vertical scrolling if content overflows */
  width: calc(100% - 115px);
}
.main.offers {
  min-height: calc(100% - 75); /* Subtract footer height */
  max-height: calc(100% - 75); /* Subtract footer height */
  overflow-y: auto; /* Enable vertical scrolling if content overflows */
}
.main.contracts {
  min-height: calc(100% - 75); /* Subtract footer height */
  max-height: calc(100% - 75); /* Subtract footer height */
  overflow-y: auto; /* Enable vertical scrolling if content overflows */
}
.main.account {
  min-height: calc(100% - 75); /* Subtract footer height */
  max-height: calc(100% - 75); /* Subtract footer height */
  overflow-y: auto; /* Enable vertical scrolling if content overflows */
}
/* .main.account * {
        font-size: 12px;
    } */
.main.about {
  min-height: calc(100% - 75); /* Subtract footer height */
  max-height: calc(100% - 75); /* Subtract footer height */
  overflow-y: auto; /* Enable vertical scrolling if content overflows */
}
.main.markets::after {
  content: '';
  background: url('./bitbay-dynamic-peg-hero.png') center/cover;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  opacity: 0.25; /* Adjust the opacity value as needed */
  z-index: -1;
}
.main.account::after {
  content: '';
  background: url('./free-balloon.png') no-repeat;
  position: absolute;
  top: -5%;
  left: 50%;
  right: 0;
  bottom: 0;
  opacity: 0.07; /* Adjust the opacity value as needed */
  z-index: -1;
  overflow-y: hidden;
}
.square-button {
  display: inline-block;
  border: 1px solid #3d0064;
  padding: 5px 5px;
  border-radius: 4px; /* Make it square */
  background-color: #3498db; /* Set default background color */
  color: #ffffff; /* Set default text color */
  cursor: pointer;
  transition: background-color 0.3s, color 0.3s; /* Add transition effect */
}

.square-button:hover {
  background-color: #003357; /* Invert background color on hover */
  color: #dcdcdc; /* Invert text color on hover */
}
.square-button2 {
  display: inline-block;
  border: 1px solid #3d0064;
  padding: 5px 15px;
  border-radius: 4px; /* Make it square */
  background-color: #ebebeb; /* Set default background color */
  color: #000000; /* Set default text color */
  cursor: pointer;
  transition: background-color 0.3s, color 0.3s; /* Add transition effect */
}

.square-button2:hover, .offers-categories .offers-tab-container button:hover, .account-form-wrapper .account-box-position button:hover, .offers-categories .offers-tab-container button.active {
  background-color: #003357; /* Invert background color on hover */
  color: #dcdcdc; /* Invert text color on hover */
}
/* my css */
.logo {
  width: 60px;
  height: 60px;
  display: block;
}
.logo img {
  width: 100%;
  height: 100%;
}
h2 {
  font-size: 24px;
  color: #322C62;
  font-weight: bold;
  margin-top: 0;
}

.popup-image {
  display: block;
  margin: 0 auto;
  max-width: 200px;
  max-height: 200px;
  object-fit: contain;
  margin-bottom: 10px;
}

.popup-details p {
  margin: 5px 0;
}

.button-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

.button-container button {
  margin: 0 10px;
  padding: 10px;
  border-radius: 5px;
  /* border: none; */
  cursor: pointer;
}

.button-container button:hover {
  background-color: #F5F5F5;
}

.popup-container, .popup-container2 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}
.popup, .popup2, .withdraw-swal-wrapper {
  position: relative;
  background-color: white;
  padding: 30px;
  max-width: calc(600px - 30px);
  width: 100%;
  border-radius: 6px;
}
.close-button, .close-button2 {
  font-size: 38px;
  color: #263886;
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.vertical-spacer {
  display: inline-block;
  height: 2px;
}
/*  */
.modal-header h2 {
  margin-bottom: 25px;
}
.form-contract-modal, .offer-popup-wrapper {
  max-height: calc(580px - 113px);
  overflow-y: auto;
  padding-right: 12px;
}
.offer-popup-wrapper {
  padding-bottom: 15px;
}
.form-contract-modal label {
  font-size: 14px;
  font-weight: 600;
  color: #322C62;
  display: block;
  margin-bottom: 10px;
}
.form-contract-modal select, .form-contract-modal input, .form-contract-modal textarea {
  background: #FCFCFC 0% 0% no-repeat padding-box;
  border: 1px solid #C3C3C3;
  border-radius: 5px;
  box-shadow: unset;
  outline: none;
  height: 42px;
  padding: 12px;
  width: 100%;
}
.input-buttons {
  height: 42px;
}
.form-contract-modal .input-wrapper {
  width: 50%;
  margin-bottom: 15px;
}
.form-contract-modal .input-wrapper.content-margin {
  margin-bottom: 0;
}
.form-contract-modal .input-wrapper:not(:last-child) {
  padding-right: 15px;
}
.input-wrapper-area {
  display: flex;
  justify-content: space-between;
}
.input-wrapper-content {
  margin-bottom: 15px;
}
.input-checkboxes {
  display: flex;
  align-items: center;
}
.input-checkboxes {
  position: relative;
}
.input-checkboxes input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}
.input-checkboxes label {
  margin-bottom: 0;
  margin-left: 40px;
}
.input-checkboxes .checkmark {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  left: 0;
  height: 25px;
  width: 25px;
  background-color: transparent;
  border-radius: 3px;
  border: 2px solid #0D2F80;
  cursor: pointer;
}
.input-checkboxes .checkmark:before {
  content: "";
  position: absolute;
  background-color: #fff;
  height: 15px;
  width: 15px;
  z-index: 0;
  top: -5px;
  right: -5px;
}
.input-checkboxes .checkmark:after {
  content: "";
  position: absolute;
  display: none;
  right: 1px;
  top: -6px;
  width: 7px;
  height: 17px;
  border: 2px solid #0D2F80;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}
.input-checkboxes input:checked ~ .checkmark:after {
  display: block;
}
.checkbox-tick-wrapper input:checked ~ .checkmark {
  background-color: transparent;
  border: 2px solid #0D2F80;
}
.btn-filled, .btn-gray, .withdraw-swal-wrapper .swal2-actions button {
  background-color: #7066E0;
  border-radius: 4px;
  color: white;
  border: 2px solid #7066E0;
  height: 42px;
  min-width: 100px;
  padding: 0 12px;
  cursor: pointer;
  transition: all ease-in-out 0.6s;
  font-size: 16px;
  font-weight: bold;
}
.btn-filled:hover, .withdraw-swal-wrapper .swal2-actions button:hover {
  background-color: transparent;
  color: #7066E0;
}
.btn-gray, .withdraw-swal-wrapper .swal2-actions button.swal2-cancel {
  background-color: #858585;
  border: 2px solid #858585;
}
.btn-gray:hover, .withdraw-swal-wrapper .swal2-actions button.swal2-cancel:hover {
  background-color: transparent;
  color: #858585;
}
.dashboard-content-wrapper h2 {
  margin-bottom: 15px;
}
.withdraw-swal-wrapper .swal2-actions button:focus {
  box-shadow: unset;
}
.withdraw-swal-wrapper .swal2-actions button:hover {
  background-image: unset !important;
}
.dashboard-content-wrapper .square-button, .header-search-area .square-button2 {
  background-color: #322C62;
  border: 1px solid #322C62;
  padding: 10px 15px;
  border-radius: 6px;
  transition: all ease-in-out 0.6s;
  font-weight: bold;
  color: white;
}
.dashboard-content-wrapper .square-button {
  margin-bottom: 12px;
}
.dashboard-content-wrapper .square-button:hover {
  background-color: transparent;
  color: #322C62;
}
.header-search-wrapper {
  display: flex;
  align-items: center;
}
.header-search-area {
  position: relative;
  border-radius: 4px;
  overflow: hidden;
  width: 250px;
  border: 1px solid #322c62;
  margin-right: 10px;
}
.header-search-area input {
  padding: 10px;
  border: none;
  color: black;
  font-size: 14px;
  outline: none;
  box-shadow: unset;
}
.header-search-area .square-button2 {
  border-radius: 0px;
  position: absolute;
  top: 0;
  right: 0;
  transition: all ease-in-out 0.3s;
}
.header-search-area .square-button2:hover {
  transform: scale(1.09);
}
.header-search-wrapper #favorites-button {
  margin: 0;
  padding: 0;
  background-color: transparent;
  border: none;
  display: flex;
  align-items: center;
}
.header-search-wrapper #star-symbol {
  color: #322c62;
  padding: 0;
  margin: 0;
  font-size: 30px;
  display: inline-block;
  line-height: 20px;
}
.header-search-wrapper #favorites-text {
  color: #322c62;
}
.dashboard-content-wrapper .search {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}
.dashboard-content-wrapper .pagination {
  display: flex;
  align-items: center;
}
.dashboard-content-wrapper .pagination .square-button2 {
  border-radius: 6px;
  background-color: #E3E3E3;
  border: none;
  padding: 9px 10px;
  margin: 0;
  margin-right: 10px;
}

.dashboard-content-wrapper .pagination select,
.header #languageSelect,
.mobile-pagination-select, .account-withdraw-popup select, .withdraw-swal-wrapper select {
  background-color: #E3E3E3;
  color: #322C62;
  border: none;
  padding: 12px;
  font-size: 14px;
  font-weight: bold;
  outline: none;
  border-radius: 6px;
}
.dashboard-content-wrapper .listings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  grid-gap: 20px;
  background-color: #F1F1F1;
  padding: 25px;
}
.dashboard-content-wrapper .listing-grid-item {
  border: none;
  text-align: center;
  position: relative;
  cursor: pointer;
  padding: 0 12px;
  max-width: 280px;
  width: 100%;
  margin: 0 auto 20px;
}
.dashboard-content-wrapper .listing-image {
  width: 100%;
  height: 184px;
  border-radius: 8px 8px 0 0;
  overflow: hidden;
  background-color: white;
  box-shadow: 1px 1px 6px 6px #80808030;
  padding: 10px;
  padding-bottom: 0;
}
.dashboard-content-wrapper .listing-image img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
.token-ammount-content {
  background-color: #7066E0;
  border-radius: 0 0 8px 8px;
  color: white;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 15px;
  font-size: 12px;
  font-weight: normal;
  margin-bottom: 10px;
}
.dashboard-content-wrapper .listing-details {
  text-align: center;
}
.token-ammount-content .token bdo, .token-ammount-content .amount bdo {
    font-weight: bold;
    margin-right: 2px;
}
.dashboard-content-wrapper .listing-details .message {
  color: #322C62;
  font-size: 18px;
  font-weight: bold;
}
.header-list-area {
  display: flex;
  align-items: center;
}
.sidebar-toggle {
  display: none;
}
.connect-mobile-icon {
  display: none;
}
.header .dark-light-content {
  background-color: #2799C0;
  width: 42px;
  height: 42px;
  border-radius: 50%;
}
.header .dark-light-content {
  background-color: #2799C0;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px;
}
.day-night-icon, .day-night-icon img {
  width: 100%;
  height: 100%;
}
.header-lang-view {
  display: flex;
  align-items: center;
}
.offer-popup .favorites-button2, .offer-popup .favorites-button3 {
  background-color: #ECEFF8;
  color: #322C62;
  width: 35px;
  height: 35px;
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  padding: 8px;
}

.message-button {
    position: relative; /* Add this line */
    background-color: #ECEFF8;
    color: #322C62;
    width: 35px;
    height: 35px;
    align-items: center;
    justify-content: center;
    padding: 8px;
    display: flex; /* Ensure it uses flexbox to center the icon */
    /* border-radius: 50%; Optional: makes the button circular */
}
.message-count-indicator {
    position: absolute; /* Position it relative to the message button */
    top: 0;
    right: 0;
    background-color: red; /* Red is commonly used for alerts and notifications */
    color: white;
    border-radius: 50%; /* Circular shape */
    padding: 2px 5px; /* Padding to adjust the content inside the circle */
    font-size: 12px; /* Smaller font size for the indicator */
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 20px; /* Minimum width to ensure the circle shape even with single digit */
    height: 20px; /* Fixed height for consistency */
    box-shadow: 0 0 2px #000; /* Optional: adds a slight shadow for better visibility */
}
.offer-popup .favorites-button2 {
  margin-right: 6px;
}
.fav-icons-wrapper {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}
.offer-popup .arrows-container {
  margin-bottom: 15px;
  height: 25px;
}
.offer-popup-wrapper p, .offers-list-box div {
  margin-bottom: 10px;
  font-size: 14px;
}
.offer-popup-wrapper p {
  white-space: normal !important;
  word-break: break-all;
}
.offer-popup-wrapper p:not(:last-child) {
  margin-bottom: 25px;
}

.offer-popup-wrapper p bdo {
  width: 100%;
  display: inline-block;
  font-weight: bold;
  margin-bottom: 6px;
}
.offers-categories .offers-tab-container button, .account-details-wrapper button {
  background-color: #E3E3E3;
  border-radius: 6px;
  color: #322C62;
  min-width: 186px;
  height: 40px;
  border: none;
  font-size: 14px;
  font-weight: bold;
  margin-right: 12px;
  cursor: pointer;
}

.account-details-wrapper button {
  min-height: 40px;
  height: auto;
}

.offers-categories .offers-header,
.offers-categories .escrow-header {
  font-size: 18px;
  color: #322C62;
  font-weight: bold;
  margin-bottom: 15px;
}
.offers-list-box {
  margin: 0;
  padding: 25px 40px;
  background-color: #ECEFF8;
  margin-bottom: 20px;
  cursor: pointer;
}
.offers-list-box div bdo {
  font-weight: bold;
  font-size: 16px;
  color: #111112;
  width: 25%;
  display: inline-block;
}
.dashboard-content-wrapper #paginationNumbers button {
  background-color: #e3e3e3;
  border: none;
  padding: 10px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  margin-right: 10px;
  border-radius: 6px;
  width: 45px;
  height: 45px;
  color: #322C62;
}
.dashboard-content-wrapper #paginationNumbers button.active, .dashboard-content-wrapper #paginationNumbers button:hover {
  background-color: #322C62;
  color: white;
}
.account-details-wrapper #account {
  line-height: 20px;
}
/* account css */
.account-form-wrapper {
  display: flex;
  margin-bottom: 25px;
}
.account-btn-wrapper {
  margin-bottom: 25px;
}
.account-form-wrapper .account-input-box {
  width: 25%;
  padding-right: 18px;
  position: relative;
}
.account-form-wrapper .width-28 {
  width: 28%;
  padding: 0;
}
.account-form-wrapper .input-checkboxes {
  width: 35%;
}
.account-form-wrapper #contactInfoWarning {
  font-size: 12px;
  margin-top: 10px;
}
.account-form-wrapper .account-box-position {
  display: flex;
  align-items: end;
}
.account-form-wrapper .account-box-position button {
  width: 100%;
  background-color: #ECEFF8;
  margin-right: 0;
}

.account-form-wrapper label {
  display: block;
  color: #060505;
  font-size: 16px;
  font-weight: bold;
  margin-bottom: 10px;
}
.account-form-wrapper input, .account-form-wrapper select, .category-purchase-popup input, .account-withdraw-popup input, .withdraw-swal-wrapper input {
  background: #FCFCFC;
  border: 1px solid #C3C3C3;
  border-radius: 5px;
  box-shadow: none;
  outline: none;
  width: 100%;
  height: 40px;
  padding: 5px 12px;
  font-size: 14px;
}
.withdraw-swal-wrapper input:focus {
  box-shadow: unset;
  border-color: #C3C3C3;
}
.account-form-wrapper .input-checkboxes label {
  margin-bottom: 0;
}
.category-purchase-popup input {
  padding: 3px 10px;
}

.about-box-info {
  background-color: #ECEFF8;
  padding: 40px 70px 30px;
  text-align: center;
}

.about-box-info p {
  font-size: 16px;
  line-height: 24px;
  margin-bottom: 15px;
  margin-top: 0;
}

.about-box-img {
  display: block;
  width: 100%;
  margin-bottom: 20px;
}
.about-box-img img {
  width: 100%;
}

.faq-content-wrapper {
  display: flex;
}

/* accordion start */
.faq-accordion {
  width: 100%;
}
#accordionWrapper h4 {
  font-size: 16px;
}
.faq-accordion h3,
.faq-form h3 {
  font-size: 32px;
  font-weight: bold;
  color: #263887;
  margin-bottom: 30px;
  margin-top: 0;
}

.faq-accordion .accordionItem {
  display: block;
  width: 100%;
  box-sizing: border-box;
}

.faq-accordion .accordionItemHeading {
  cursor: pointer;
  padding: 12px 25px 12px 12px;
  margin-bottom: 12px;
  color: #060505;
  font-size: 16px;
  width: 100%;
  box-sizing: border-box;
  font-weight: normal;
}

.faq-accordion .accordionItemHeading span {
  font-size: 18px;
  color: #7066E0;
  margin-right: 15px;
  display: inline-block;
  font-weight: bold;
}

.faq-accordion .accordion-close .accordionItemContent {
  height: 0;
  transition: height 1s ease-out;
  transform: scaleY(0);
  float: left;
  display: block;
}

.faq-accordion .accordion-open .accordionItemContent {
  padding: 12px;
  width: 100%;
  margin-bottom: 12px;
  display: block;
  transform: scaleY(1);
  transform-origin: top;
  transition: transform 0.4s ease;
  box-sizing: border-box;
  font-size: 16px;
  font-weight: normal;
  color: #060505;
  line-height: 27px;
  max-height: initial !important;
}

.faq-accordion .accordion-open .accordionItemContent p {
  margin: 0;
}

.faq-accordion .accordion-open .accordionItemHeading {
  margin: 0;
  position: relative;
}

.faq-accordion .accordion-close .accordionItemHeading {
  position: relative;
}

.faq-accordion .accordion-open .accordionItemHeading::before,
.faq-accordion .accordion-close .accordionItemHeading::before {
  content: '>';
  color: #7066E0;
  font-size: 28px;
  font-weight: 500;
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(-90deg);
  font-family: monospace;
}

.faq-accordion .accordion-close .accordionItemHeading::before {
  transform: translateY(-50%) rotate(90deg);
  right: -4px;
}

/* accordion end */
.faq-form-wrapper {
  width: 45%;
}

.faq-form {
  background-color: #263887;
  border-radius: 6px;
  padding: 35px 60px;
  max-width: 590px;
  margin-left: auto;
}

.faq-form h3,
.form-content label,
.form-content input,
.form-content textarea {
  color: white;
}

.faq-input-wrapper {
  margin-bottom: 30px;
}

.form-content label {
  font-size: 16px;
  font-weight: normal;
  display: block;
  margin-bottom: 10px;
}

.form-content input,
.form-content textarea {
  font-size: 16px;
  font-weight: normal;
  box-shadow: none;
  outline: none;
  background-color: transparent;
  border: none;
  border-bottom: 1px solid #ffffff47;
  width: 100%;
}

.form-content textarea {
  min-height: 50px;
  resize: none;
}

.form-content .form-content-button {
  text-align: right;
  margin-bottom: 30px;
}

.form-content .form-content-button .btn-filled {
  box-shadow: 0px 0px 0px 4px #9E96F6;
  border: none;
}

.form-content .form-content-button .btn-filled {
  color: white;
}

.faq-social-icons {
  display: flex;
  align-items: center;
  justify-content: center;
}

.faq-social-icons a {
  display: block;
  width: 36px;
  height: 36px;
  transition: all ease-in-out 0.5s;
}

.faq-social-icons a:not(:last-child) {
  margin-right: 12px;
}

.faq-social-icons a:hover {
  transform: scale(1.2);
}

.faq-social-icons a img {
  width: 100%;
  height: 100%;
}
.offer-popup-wrapper ul.image-list {
  padding: 0;
}
.offers-list-box listelement {
  padding: 15px 25px;
  margin-bottom: 12px;
  border-radius: 8px;
  display: block;
  position: relative;
}
.offers-list-box listelement:hover { 
  background-color: #fff8f7
}
.offers-list-box listelement::before {
  content: '';
  position: absolute;
  height: 2px;
  width: 90%;
  background-color: #322c62;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
} 
.offers-list-box listelement:hover::before {
  content: unset;
}
.offers-list-box p {
  color: black;
}
.input-wrapper-content #fileNames {
  display: none;
}
.input-wrapper-content #fileDisplayArea {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  padding-top: 15px;
}
#fileDisplayArea .file-display {
  width: 32.33%;
  height: 100px;
  margin-right: 1%;
  padding: 20px;
  position: relative;
  background-color: #80808030;
  border-radius: 4px;
  margin-bottom: 5px;
}
#fileDisplayArea .file-display img {
  object-fit: contain;
  width: 100%;
  height: 100%;
  object-position: center center;
}
#fileDisplayArea .file-display .remove-file {
  font-size: 20px;
  background-color: #1e1a3b;
  color: white;
  border-radius: 4px;
  height: 17px;
  width: 17px;
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 5px;
  cursor: pointer;
}
.account-withdraw-popup h2 {
  font-size: 20px;
  text-align: center;
  color: #322C62;
}
.account-withdraw-popup .form-group {
  margin-bottom: 10px;
}
.account-withdraw-popup label {
  font-size: 14px;
  font-weight: bold;
  display: block;
  margin-bottom: 10px;
  color: black;
}
.account-withdraw-popup select {
  width: 100%;
}
.withdraw-button {
  margin-top: 20px;
}
#publicemail {
  margin-bottom: 25px;
  font-size: 14px;
  font-weight: normal;
  word-break: break-all;
}
#publicemail bdo {
  font-weight: bold;
}
#publicemail span {
  color: #322c62;
  cursor: pointer;
}
.withdraw-swal-wrapper {
  border: none;
  font-family: inherit;
}
.withdraw-swal-wrapper h2 {
  padding: 0;
  margin-bottom: 20px;
}
.withdraw-swal-wrapper .swal2-input {
  display: block;
  margin: 0;
  width: 100%;
  margin-bottom: 15px;
}
.withdraw-swal-wrapper .swal2-html-container, .withdraw-swal-wrapper .swal2-actions {
  margin: 0;
}
.withdraw-swal-wrapper select {
  height: auto;
}
.withdraw-swal-wrapper #swal2-validation-message {
  margin-top: 0;
  margin-bottom: 10px;
}
/* about tabs */
.about-tab {
  display: flex;
}
.about-tab button {
  background-color: transparent;
  color: #322c62;
  border: 2px solid #322c62;
  outline: none;
  cursor: pointer;
  padding: 0 25px;
  transition: 0.3s;
  font-size: 18px;
  width: 320px;
  height: 40px;
  display: block;
  margin-right: 2px;
}
.about-tab .abouttablinks.active {
  display: block;
}
.about-tab button.active, .about-tab button:hover {
  background-color: #322c62;
  color: white;
}
.about-content-area .abouttabcontent {
  display: none;
  padding-top: 25px;
}
.notification-lottie-file {
  position: fixed;
  bottom: 60px;
  right: 10px;
  width: 60px;
  background-color: #322c62;
  border-radius: 50%;
  padding: 10px;
}
#notification-box {
  position: fixed;
  bottom: 65px;
  right: 90px;
  max-width: 380px;
  width: 100%;
  background-color: white;
  box-shadow: 1px 1px 5px 4px #80808057;
  padding: 25px;
  display: none;
  max-height: 480px;
  overflow: hidden;
  overflow-y: auto;
}
#notification-box.active {
  display: block;
}
.notification-box-content {
  display: flex;
  align-items: center;
}
.notification-box-content:not(:last-child) {
  border-bottom: 2px solid #00000036;
  padding-bottom: 15px;
  margin-bottom: 15px;
}
.notification-box-content-button {
  background-color: transparent;
  border: none;
  padding: 0;
  display: flex;
  align-items: center;
  cursor: pointer;
  width: 100%;
}
.notification-badge {
  width: 50px;
  height: 50px;
  margin-right: 15px;
  border-radius: 50%;
  overflow: hidden;
}
.notification-badge img {
  width: 100%;
  height: 100%;
}
.notification-box-content-info {
  width: calc(100% - 65px);
  color: black;
  text-align: left;
}
.notification-box-content-info h6 {
  color: black;
  font-size: 18px;
  margin: 0;
  margin-bottom: 6px;
}
.notification-box-content-info p {
  font-size: 14px;
  line-height: 20px;
  margin: 0;
}
#myoffers .tabcontent {
  display: block;
}
#notification-box .notification-empty {
  color: black;
  font-weight: 600;
  font-size: 16px;
}
.offer-popup .button-container button{
  font-size: 12px;
}
.offer-popup-wrapper .modal-funds-text {
  word-break: break-word;
}
.dashboard-content-wrapper .pagination .button-disabled {
  background-color: #4949498c;
}
.dashboard-content-wrapper .pagination .button-disabled img {
  filter: brightness(0.1);
}
.message-body button {
  background-color: #322C62;
  color: white;
  border: 1px solid #322C62;
  font-weight: bold;
  font-size: 16px;
}
.message-body button:hover {
  background-color: transparent;
  color: #322C62;
}

.message-body {
  word-break: break-word;
}

.message-body .message-body-inner {
  max-height: 150px;
  overflow: hidden;
  overflow-y: auto;
  padding: 10px;
}

.message-receiver, .message-sender {
  border-radius: 10px;
  padding: 10px;
  line-height: 18px;
  width: 90%;
  color: black;
}

.message-sender {
  background-color: #DAF0C4; 
  margin-left: auto;
}

.message-receiver {
  text-align: left;
  background-color: #D3E8EE;
}

@media screen and (max-width: 1600px) {
  .header {
    height: 80px;
  }
  .header h1 {
    font-size: 18px;
  }
  .sidebar {
    padding: 25px;
    width: 110px;
    height: calc(100vh - 130px);
  }
  .sidebar button {
    width: 60px;
    height: 60px;
  }
  .container.site-container {
    height: calc(100vh - 130px);
  }
  .main.markets {
    width: calc(100% - 110px);
  }
  .header2 {
    height: 75px;
  }
  .header2 a:not(:last-child) {
    margin-right: 70px;
  }
  .account-form-wrapper {
    align-items: end;
  }
  .checkboxes-form-wrapper {
    margin-bottom: 30px;
  }
  .checkboxes-form-wrapper .account-input-box {
    width: 30%;
  }

  .about-box-info {
    padding: 35px 55px 30px;
  }

  .about-box-info p {
    font-size: 15px;
  }

  .faq-form {
    padding: 30px 55px;
    max-width: 500px;
  }

  .faq-accordion h3,
  .faq-form h3 {
    font-size: 28px;
  }
  .faq-accordion h3 {
    margin: 0;
  }
  .account-form-wrapper .input-checkboxes {
    width: 40%;
  }
  .account-form-wrapper label {
    font-size: 14px;
  }
  .account-form-wrapper .width-28 {
    width: 31%;
  }
}

@media screen and (max-width: 1399px) {
  .account-form-wrapper label {
    font-size: 14px;
  }

  .faq-form-wrapper {
    padding-left: 30px;
  }

  .faq-form {
    padding: 30px 50px;
    max-width: 100%;
  }

  .about-box-info {
    padding: 30px 45px;
  }
  .account-form-wrapper .input-checkboxes {
    width: 45%;
  }
  .account-form-wrapper .width-28 {
    width: 37%;
  }
  .account-details-wrapper button {
    font-size: 12px;
  }
}

@media screen and (max-width: 1199px) {
  .header {
    height: 75px;
  }
  .logo {
    width: 55px;
    height: 55px;
  }
  .header h1 {
    font-size: 17px;
  }
  .sidebar {
    padding: 20px;
    width: 105px;
    height: calc(100vh - 125px);
  }
  .sidebar button {
    width: 100%;
    height: 60px;
  }
  .container.site-container {
    height: calc(100vh - 125px);
  }
  .main.markets {
    width: calc(100% - 105px);
  }
  .header2 {
    height: 70px;
  }
  .header2 a:not(:last-child) {
    margin-right: 60px;
  }
  .offers-list-box div bdo {
    width: 30%;
  }
  .account-form-wrapper .account-input-box {
    width: 33.33%;
  }
  .checkboxes-form-wrapper .account-input-box {
    width: 40%;
  }

  .about-box-info {
    padding: 30px 40px;
  }

  .faq-accordion h3,
  .faq-form h3 {
    font-size: 24px;
    margin-bottom: 25px;
  }

  .faq-form {
    padding: 30px 40px;
    max-width: 100%;
  }

  .form-content label {
    font-size: 14px;
    margin-bottom: 8px;
  }
  .offers-list-box {
    padding: 25px;
  }
  .account-form-wrapper .width-28 {
    width: 40%;
  }
  .checkboxes-form-wrapper .account-input-box {
    width: 50%;
  }
  .account-form-wrapper label {
    font-size: 12px;
  }

}

@media screen and (max-width: 991px) {
  .logo {
    width: 50px;
    height: 50px;
  }
  .header {
    justify-content: space-between;
  }
  .header h1, .connectionstatus {
    display: none;
  }
  .sidebar {
    padding: 18px;
    width: 95px;
  }
  .sidebar button {
    height: 50px;
  }
  .sidebar .sidebar-icons {
    padding: 12px;
  }
  .header2 {
    height: 60px;
  }
  .header2 a {
    font-size: 15px;
  }
  .header2 a:not(:last-child) {
    margin-right: 40px;
  }
  .offers-list-box {
    overflow-x: auto;
  }

  .offers-list-box div bdo {
    width: 40%;
  }
  .dashboard-content-wrapper #paginationNumbers button {
    padding: 8px;
    font-size: 14px;
    margin-right: 6px;
    width: 40px;
    height: 40px;
  }
  .dashboard-content-wrapper .pagination .square-button2 {
    padding: 7px 8px;
    margin-right: 6px;
  }
  .account-form-wrapper {
    align-items: end;
    flex-wrap: wrap;
    margin-bottom: 0;
  }
  .account-form-wrapper .account-input-box {
    width: 50%;
    margin-bottom: 20px;
  }
  .checkboxes-form-wrapper {
    margin-bottom: 10px;
  }
  .dashboard-content-wrapper .listing-details .message {
    font-size: 16px;
  }

  .faq-accordion,
  .faq-form-wrapper {
    width: 100%;
  }

  .faq-form-wrapper {
    padding-left: 0;
  }

  .faq-content-wrapper {
    display: block;
  }

  .faq-accordion {
    margin-bottom: 40px;
  }
  .offers-list-box div:not(:last-child) {
    margin-bottom: 30px;
  }
  .offers-list-box div bdo {
    width: 100%;
    margin-bottom: 8px;
  }
}

@media screen and (max-width: 767px) {
  h2 {
    font-size: 22px;
  }
  .sidebar-background {
    background-image: url("");
  }
  .sidebar {
    background-image: url("sidebar-bg.png");
    background-size: 100% 100%;
    padding: 15px;
    position: fixed;
    height: calc(100% - 125px);
    z-index: 1;
    transition: transform 0.3s ease;
    transform: translateX(-100%);
  }
  .sidebar .sidebar-icons {
    padding: 10px;
  }
  .sidebar button {
    height: 52px;
    margin-bottom: 35px;
    font-size: 11px;
  }
  .popup, .popup2 {
    padding: 25px 20px;
    max-width: calc(540px - 25px);
  }
  .offer-popup-wrapper p span button {
    font-size: 10px;
    padding: 2px;
  }

  .modal-header h2 {
    margin-bottom: 20px;
  }
  .form-contract-modal, .offer-popup-wrapper {
    max-height: calc(540px - 95px);
  }
  .form-contract-modal label {
    font-size: 13px;
  }
  .input-checkboxes .checkmark {
    height: 20px;
    width: 20px;
  }
  .input-checkboxes .checkmark:after {
    top: -4px;
    width: 5px;
    height: 12px;
  }
  .main.markets {
    width: 100%;
  }
  .sidebar-toggle {
    width: 35px;
    height: 35px;
    padding: 6px;
    background-color: white;
    border-radius: 4px;
    margin-right: 8px;
    margin-top: 5px;
    display: block;
    cursor: pointer;
  }
  .sidebar.active {
    transform: translateX(0);
  }
  .mobile-toggle-header {
    display: flex;
    align-items: center;
  }
  .header .connect {
    display: none;
  }
  .connect-mobile-icon {
    display: block;
    width: 35px;
  }
  .header2 a:not(:last-child) {
    margin-right: 30px;
  }
  .dashboard-content-wrapper .search {
    display: block;
  }
  .header-search-wrapper {
    margin-bottom: 20px;
  }
  .header-search-area {
    width: 100%;
  }
  .header-search-area input {
    padding-right: 90px;
    font-size: 12px;
    width: 100%;
  }
  .offers-list-box {
    padding: 20px 25px;
  }
  .offers-list-box div {
    word-break: break-all;
  }
  .offers-list-box div bdo {
    font-size: 14px;
  }
  .account-form-wrapper .account-box-mobile, .checkboxes-form-wrapper .account-input-box {
    width: 100%;
  }
  .dashboard-content-wrapper .listings-grid {
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  }
  .about-tab button {
    padding: 0 20px;
    font-size: 16px;
    width: 50%;
  }
}
@media screen and (max-width: 575px) {
  .sidebar-background {
    background-image: url("");
  }
  .sidebar {
    background-image: url("sidebar-bg.png");
    background-size: 100% 100%;
    padding: 15px;
    position: fixed;
    height: calc(100% - 125px);
    z-index: 1;
    transition: transform 0.3s ease;
    transform: translateX(-100%);
  }
  .popup, .popup2 {
    max-width: 90%;
  }
  .input-wrapper-area {
    display: block;
  }
  .form-contract-modal .input-wrapper {
    width: 100%;
    margin-bottom: 15px;
  }
  .form-contract-modal .input-wrapper:not(:last-child) {
    padding-right: 0;
  }
  .form-contract-modal .input-wrapper.content-margin {
    margin-bottom: 15px;
  }
  .btn-filled {
    height: 40px;
    min-width: 90px;
    padding: 0 10px;
    font-size: 15px;
    margin-top: 10px;
  }
  .header-list {
    display: flex;
    white-space: nowrap;
    flex-wrap: wrap;
  }
  .header2 a:not(:last-child) {
    margin-right: 20px;
  }
  .header2 a {
    font-size: 14px;
    margin-bottom: 6px;
  }
  .header-list::-webkit-scrollbar {
    height: 4px;
  }
  .header-list::-webkit-scrollbar-thumb {
    background: white;
  }

  .offer-popup-wrapper p:not(:last-child) {
    margin-bottom: 20px;
  }

  .offer-popup-wrapper .button-container {
    display: block;
    text-align: center;
  }
  .offer-popup-wrapper .button-container .btn-filled {
    margin-bottom: 6px;
  }
  .offers-list-box {
    padding: 15px;
  }

  .offers-list-box listelement {
    padding: 10px 18px;
  }
  .offers-categories .offers-tab-container button {
    min-width: 125px;
    height: 38px;
    font-size: 13px;
    margin-right: 6px;
  }

  .account-details-wrapper #account {
    line-height: 20px;
    word-break: break-word;
  }
  .account-btn-wrapper {
    text-align: center;
    margin-bottom: 15px;
  }
  .account-details-wrapper button {
    margin-right: 0;
    margin: 0 auto 12px;
  }
  .account-form-wrapper .account-input-box {
    width: 100%;
    margin-bottom: 16px;
    padding-right: 0;
  }
  .account-form-wrapper label, .account-form-wrapper .account-box-position button {
    font-size: 13px;
  }
  .account-form-wrapper .account-box-position button {
    margin-bottom: 0;
  }
  .dashboard-content-wrapper .listings-grid {
    padding: 15px 10px;
  }

  .about-box-info {
    padding: 20px 15px;
  }

  .faq-accordion {
    margin-bottom: 30px;
  }

  .faq-accordion h3,
  .faq-form h3 {
    font-size: 22px;
    margin-bottom: 20px;
    text-align: center;
  }

  .faq-accordion .accordion-open .accordionItemContent {
    padding: 10px;
    margin-bottom: 10px;
    font-size: 14px;
    line-height: 24px;
  }

  .faq-form {
    padding: 20px;
  }
  .offer-popup-wrapper .button-container .btn-gray:not(:last-child) {
    margin-bottom: 6px;
  }
  #fileDisplayArea .file-display {
    width: 48.33%;
    margin-right: 1%;
  }
  .category-purchase-popup {
    padding: 15px;
    max-width: 300px;
    width: 100%;
  }
  .category-purchase-popup .detail-content {
    font-size: 16px;
  }
  .token-ammount-content {
    padding: 10px;
    font-size: 11px;
  }
  .about-tab button {
    padding: 0 12px;
    font-size: 14px;
  }
}

@media screen and (max-width: 480px) {
      .sidebar-background {
      background-image: url("");
    }
    .sidebar {
      background-image: url("sidebar-bg.png");
      background-size: 100% 100%;
      padding: 15px;
      position: fixed;
      height: calc(100% - 125px);
      z-index: 1;
      transition: transform 0.3s ease;
      transform: translateX(-100%);
    }
    .container.site-container {
      height: calc(100vh - 180px);
    }
    .about-tab {
      display: block;
    }
    .about-tab button {
      width: 100%;
      margin-right: 0;
      margin-bottom: 6px;
    }
    .notification-lottie-file {
    width: 50px;
    }
    #notification-box {
      right: 20px;
      max-width: 80%;
      padding: 20px;
      max-height: 360px;
      bottom: 115px;
    }
    .notification-badge {
      width: 40px;
      height: 40px;
      margin-right: 12px;
    }
    .notification-box-content:not(:last-child) {
      padding-bottom: 12px;
      margin-bottom: 12px;
    }
    .notification-box-content-info {
      width: calc(100% - 52px);
    }
    .notification-box-content-info h6 {
      font-size: 14px;
      margin-bottom: 4px;
    }
    .notification-box-content-info p {
      font-size: 12px;
      line-height: 18px;
    }
}

@media screen and (max-width: 400px) {
  .sidebar-background {
    background-image: url("");
  }
  .sidebar {
    background-image: url("sidebar-bg.png");
    background-size: 100% 100%;
    padding: 15px;
    position: fixed;
    height: calc(100% - 125px);
    z-index: 1;
    transition: transform 0.3s ease;
    transform: translateX(-100%);
  }
  .header {
    height: 130px;
    padding: 12px 18px;
    align-items: start;
  }
  .logo {
    width: 45px;
    height: 45px;
    margin-top: -7px;
  }
  .header-lang-view {
    display: flex;
    align-items: center;
    position: absolute;
    bottom: 12px;
    right: 0;
  }
  .mobile-toggle-header {
    display: flex;
    align-items: self-start;
  }
  .sidebar {
    height: calc(100% - 180px);
  }
  .sidebar-toggle {
    margin-top: 0;
  }
  .pagination #SortBy {
    display: none;
  }
  .mobile-pagination-select {
    display: block;
    width: 100%;
    margin-top: 18px;
  }
}

/* Dark/Light theme styles */
:root {
  --background-color: #fff;
  --text-color: #000;
  --header-bg-color: #322c62;
  --button-bg-color: #d5d4e2;
  --button-text-color: #000;
}

[data-theme="dark"] {
  --background-color: #322C62;
  --text-color: #fff;
  --button-bg-color: #4e4e50;
  --button-text-color: #fff;
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}

.header {
  background-color: var(--header-bg-color);
}

/* .sidebar button {
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
    }  */
/* End Dark/Light theme styles

    /* Loader-Modal Style */
.loader-modal {
  position: fixed;
  top: 0;
  left: 0;
          width: 0; /* Minimize the modal's size */
          height: 0; /* Minimize the modal's size */
          overflow: visible; /* Allow the child elements to be shown */
          display: none; /* Initially hidden */
  z-index: 1500;
}
.loader-content {
  background: white;
  padding: 20px;
  border-radius: 5px;
  text-align: center;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  max-width: 250px;
  width: 100%;
}
.loader-content #loader-text {
  color: black;
}
.loader {
  border: 6px solid #7066e05e;
  border-radius: 50%;
  border-top: 6px solid #7066e0;
  border-bottom: 6px solid #7066e0;
  width: 40px;
  height: 40px;
  animation: spin 2s linear infinite;
  margin: 0 auto;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
}
.loader-minimized {
          display: none; /* Initially hidden */
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: var(--button-bg-color);
  color: var(--button-text-color);
  padding: 5px 10px;
  border-radius: 5px;
  cursor: pointer;
  z-index: 1600;
}
/* End: Loader-Modal Style */

/* dark theme css */
.dark-theme h2,
.dark-theme .dashboard-content-wrapper .message,
.dark-theme .header-search-wrapper #star-symbol,
.dark-theme .offers-categories .offers-header,
.dark-theme .offers-categories .escrow-header,
.dark-theme .account-form-wrapper label, .dark-theme .faq-accordion h3, .dark-theme .faq-accordion .accordionItemHeading, .dark-theme .faq-accordion .accordionItemContent p, .dark-theme .faq-accordion .accordionItemHeading span, .dark-theme .faq-accordion .accordion-open .accordionItemHeading::before, .dark-theme .faq-accordion .accordion-close .accordionItemHeading::before {
  color: white;
}

.dark-theme .dashboard-content-wrapper .square-button,
.dark-theme .header-search-area,
.dark-theme .dashboard-content-wrapper #paginationNumbers button.active,
.dark-theme .dashboard-content-wrapper #paginationNumbers button:hover,
.dark-theme .offers-categories .offers-tab-container button,
.dark-theme .account-details-wrapper button, .dark-theme .about-tab button.active, .dark-theme .about-tab button:hover, .dark-theme .about-tab button {
  border: 1px solid white;
}
.dark-theme .dashboard-content-wrapper .square-button:hover, .dark-theme .about-tab button.active, .dark-theme .about-tab button:hover {
  background-color: white;
  color: #322C62;
}
.dark-theme .dashboard-content-wrapper .listings-grid {
  background-color: #1F1B3E;
}
.dark-theme .dashboard-content-wrapper .token {
  background-color: #7066E0;
}

.dark-theme .offer-popup-wrapper p,
.dark-theme .offers-list-box div, .dark-theme .about-box-info p, .dark-theme #swal2-title {
  color: black;
}
.dark-theme .header-search-wrapper #favorites-text {
  color: white !important;
}
.dark-theme .account-details-wrapper .input-checkboxes .checkmark:before {
  background-color: #322c62;
}

.dark-theme .account-details-wrapper .input-checkboxes .checkmark,
.dark-theme .account-details-wrapper .input-checkboxes .checkmark:after {
  border-color: white;
}
.dark-theme .account-withdraw-popup h2 {
  color: #322c62;
}
.dark-theme .about-tab button {
  color: white;
}
.dark-theme .notification-lottie-file {
  border: 4px solid white;
}

.button-clicked {
    animation: click-effect 0.3s ease;
    background-color: #f0f0f0; /* Light grey background to indicate click */
}

/* Keyframes for click effect animation */
@keyframes click-effect {
    0% { transform: scale(0.98); }
    100% { transform: scale(1); }
}

/* Style for disabled buttons */
.button-disabled {
    color: #ccc; /* Grey out text */
    cursor: not-allowed;
    background-color: #e0e0e0; /* Lighter grey background */
}

    .message-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001; /* High z-index to overlay on top of other content */
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    width: 80%;
    max-width: 520px;
    padding: 20px;
    box-sizing: border-box;
    display: none; /* Initially hidden */
  }

  .message-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    margin-bottom: 10px;
    font-weight: bold;
    color: #322c62;
  }

  .close-btn {
    cursor: pointer;
    font-size: 24px;
  }

  .message-body textarea {
    width: 100%;
    height: 100px;
    margin-top: 10px;
    margin-bottom: 10px;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid black;
    resize: none;
    border-radius: 5px;
  }

  .message-body button {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    cursor: pointer;
  }

</style>
</head>
<body>

  <div class="header">
    <div class="mobile-toggle-header">
      <div class="sidebar-toggle" onclick="toggleSidebar()">
            <img src="sidebar-toggle.svg" alt="sidebar toggle"/>
      </div>
      <a href="#" class="logo">
        <img src="bitbay.png" alt="Logo">
      </a>
    </div>
    <h1 t-id="2">BitBay Decentralized Markets</h1>&nbsp
    <div class="header-list-area">
      <div class="header-lang-view">
        <img id="selectedFlag" src="default.png" alt="Selected Flag">
        <select id="languageSelect" style="margin-right: 15px; width: 100px;">
          <option value="default" disabled selected>Default</option>
        </select>
        <button id="theme-toggle" class="theme-toggle dark-light-content">
        </button>
      </div>
      <div class="connect">
        <button t-id="3" onclick="login(1)">Connect</button>
        <div id="connectionstatus" class="connectionstatus" t-id="4">Not connected</div>
      </div>
      <!-- <div class="connect-mobile-icon" t-id="3" onclick="login(1)"></div> -->
      <div class="connect-mobile-icon" onclick="login(1)">
        <img src="mobile-wallet-icon.svg" alt="wallet icon" />
      </div>
    </div>
  </div>
  <div class="footer">
    <a href="https://bitbay.market" target="_blank"><img src="bitbay.png" text="BitBay"></a>
    <a href="https://t.me/bitbayofficial" target="_blank"><img src="telegram.png" alt="Telegram"></a>
    <a href="https://medium.com/bitbay-blog" target="_blank"><img src="./medium-1.png" alt="Medium"></a>
    <a href="https://github.com/bitbaymarket" target="_blank"><img src="./github-1.png" alt="Github"></a>
  </div>

  <div class="container site-container">
    <div id="loader-modal" class="loader-modal" style="display: none;">
      <div id="loader-content" class="loader-content">
        <div class="loader"></div>
        <p id="loader-text">Waiting for confirmation...</p>
        <button onclick="minimizeLoader()" class="btn-filled">Minimize</button>
      </div>
      <div id="loader-minimized" class="loader-minimized" style="display: none;" onclick="maximizeLoader()">
        Transaction in progress...
      </div>
    </div>
    <!-- End: Loader-Modal -->
    <div class="sidebar-background">
    </div>
    <div class="sidebar" id="sidebar">
          <button onclick="showMain('markets')" id="marketsButton"><div class="sidebar-icons">
          <svg xmlns="http://www.w3.org/2000/svg" width="35.832" height="37.417" viewBox="0 0 35.832 37.417">
            <g id="market-store-svgrepo-com" transform="translate(-10.265)">
              <path id="Path_14579" data-name="Path 14579" d="M44.305,204.739h-.759v-18.7h0a4.463,4.463,0,0,1-2.551-.817,4.437,4.437,0,0,1-2.569.817,4.376,4.376,0,0,1-.569-.046V199.9a1.438,1.438,0,0,1-1.438,1.438H31.251V197.4l1.822,3.04a1.149,1.149,0,1,0,1.971-1.181l-3.662-6.112a1.136,1.136,0,0,0-1.05-.543c-.028,0-4.243,0-4.268,0a1.139,1.139,0,0,0-1.066.545l-3.662,6.112a1.149,1.149,0,1,0,1.971,1.181l1.833-3.06v3.959H19.961a1.438,1.438,0,0,1-1.438-1.438V185.992a4.375,4.375,0,0,1-.569.046,4.516,4.516,0,0,1-.877-.087,4.438,4.438,0,0,1-1.693-.73,4.461,4.461,0,0,1-2.551.817h0v18.7h-.759a1.8,1.8,0,0,0,0,3.6H44.305a1.8,1.8,0,1,0,0-3.6Z" transform="translate(-0.009 -170.921)"/>
              <path id="Path_14580" data-name="Path 14580" d="M213.708,197.226a2.763,2.763,0,1,0,2.394,2.739A2.584,2.584,0,0,0,213.708,197.226Z" transform="translate(-185.528 -182)"/>
              <path id="Path_14581" data-name="Path 14581" d="M12.092,13.09a2.559,2.559,0,0,0,3.185-1.72l.135-.45a2.552,2.552,0,0,0,5.042.217l.062-.313a2.555,2.555,0,0,0,2.292,2.36c.086.008.172.012.257.012a2.559,2.559,0,0,0,2.543-2.306l.019-.19a2.554,2.554,0,0,0,5.106,0l.019.19A2.56,2.56,0,0,0,33.3,13.2c.085,0,.171,0,.257-.012a2.554,2.554,0,0,0,2.292-2.36l.062.313a2.552,2.552,0,0,0,5.042-.217l.135.45A2.56,2.56,0,0,0,43.535,13.2a2.587,2.587,0,0,0,.734-.107,2.56,2.56,0,0,0,1.72-3.185l-2.31-7.731A3.045,3.045,0,0,0,40.761,0H15.6a3.045,3.045,0,0,0-2.918,2.174l-2.31,7.731A2.56,2.56,0,0,0,12.092,13.09Z" transform="translate(0)"/>
            </g>
          </svg>
          </div><span class="text" t-id="5">Markets</span></button>
          <button onclick="showMain('offers')" id="offersButton"><div class="sidebar-icons">
          <svg xmlns="http://www.w3.org/2000/svg" width="23.142" height="37.417" viewBox="0 0 23.142 37.417">
              <path id="ethereum-svgrepo-com" d="M17.589,28.014,6.1,21.236,17.582,37.417,29.074,21.236,17.582,28.014ZM17.76,0,6.279,19.055l11.481,6.79,11.485-6.783Z" transform="translate(-6.104)" fill="#fff"/>
          </svg>
          </div><span class="text" t-id="6">Offers</span></button>
          <button onclick="showMain('contracts')" id="contractsButton"><div class="sidebar-icons">
          <svg xmlns="http://www.w3.org/2000/svg" width="34.776" height="38.145" viewBox="0 0 34.776 38.145">
            <g id="contract-svgrepo-com" transform="translate(-22.612)">
                <path id="Path_14582" data-name="Path 14582" d="M39.157,15.551V6.865l-9.99,9.99h8.685C38.791,16.855,39.157,16.49,39.157,15.551Z" transform="translate(-6.067 -6.354)" fill="#fff"/>
                <path id="Path_14583" data-name="Path 14583" d="M420.089,147.856l-2.305-2.305a1.028,1.028,0,0,0-1.453,0l-1.495,1.495L418.6,150.8l1.494-1.5A1.027,1.027,0,0,0,420.089,147.856Z" transform="translate(-363.002 -134.429)" fill="#fff"/>
                <path id="Path_14584" data-name="Path 14584" d="M35.277,34.069a.933.933,0,0,1-1.133-1.133l2.162-8.511L48.111,12.617l.946-.946,2.093-2.093.317-.316a3.671,3.671,0,0,1,.357-.294V1.69A1.693,1.693,0,0,0,50.133,0H35.021V10.36a2.076,2.076,0,0,1-2.072,2.074H22.612V36.454A1.693,1.693,0,0,0,24.3,38.145h25.83a1.693,1.693,0,0,0,1.691-1.691V23.865L43.787,31.9Z" fill="#fff"/>
                <path id="Path_14585" data-name="Path 14585" d="M222.35,190.992l-1.281,5.04,5.04-1.282,12.472-12.473-3.758-3.759Zm2.357.854-.854-.854,10.867-10.867.855.855Z" transform="translate(-183.671 -165.218)" fill="#fff"/>
            </g>
          </svg>
        </div><span class="text" t-id="7">Contracts</span>
      </button>
      <button onclick="showMain('account')" id="accountButton">
        <div class="sidebar-icons">
          <svg xmlns="http://www.w3.org/2000/svg" width="35.664" height="35.664" viewBox="0 0 35.664 35.664">
              <path id="account-svgrepo-com" d="M19.832,2A17.832,17.832,0,1,0,37.664,19.832,17.838,17.838,0,0,0,19.832,2Zm0,5.35a5.35,5.35,0,1,1-5.35,5.35A5.342,5.342,0,0,1,19.832,7.35Zm0,25.321a12.84,12.84,0,0,1-10.7-5.742c.053-3.549,7.133-5.492,10.7-5.492,3.549,0,10.646,1.944,10.7,5.492A12.84,12.84,0,0,1,19.832,32.671Z" transform="translate(-2 -2)" fill="#fff"/>
          </svg>
          </div><span class="text" t-id="8">Account</span></button>
          <button onclick="showMain('about')" id="aboutButton"><div class="sidebar-icons">
          <svg xmlns="http://www.w3.org/2000/svg" width="35" height="35" viewBox="0 0 35 35">
            <g id="Page-1" transform="translate(-42.667 -42.667)">
              <g id="drop" transform="translate(42.667 42.667)">
                  <path id="Shape" d="M17.5,0A17.5,17.5,0,1,1,0,17.5,17.5,17.5,0,0,1,17.5,0Zm1.754,15.75h-3.5v10.5h3.5ZM17.518,8.312a2.117,2.117,0,0,0-2.2,2.163,2.188,2.188,0,1,0,4.375.024A2.115,2.115,0,0,0,17.518,8.312Z" transform="translate(0 0)" fill="#fff" fill-rule="evenodd"/>
              </g>
            </g>
          </svg>
          </div><span class="text" t-id="9">About</span></button>
    </div>
    <div class="main markets dashboard-content-wrapper">
      <div class="header2">
        <div class="header-list">
          <a href="#" t-id="10" onclick="changeSearchText('goods', this)">Goods</a>
          <a href="#" t-id="11" onclick="changeSearchText('services', this)">Services</a>
          <a href="#" t-id="12" onclick="changeSearchText('barter', this)">Barter</a>
          <a href="#" t-id="13" onclick="changeSearchText('p2p-trading', this)">P2P Trading</a>
          <!-- <a href="#" t-id="14" onclick="changeSearchText('commodities', this)">Commodities</a> -->
        </div>
      </div>
      <h2 t-id="15">MARKETS</h2>
      <div class="top-bar">
        <button onclick="createContract()" class="square-button" t-id="16">Create Contract/Offer</button>
        <div class="search">
          <!-- <img src="search.png" height="20px" width="20px" alt="Search"> -->
          <!-- <input type="text" id="searchText" placeholder="Search" onkeyup="searchListings(this.value)">
                  <button onclick="searchListings(getElementById('searchText').value, 1)" t-id="17">Search</button> -->
          <div class="header-search-wrapper">
            <div class="header-search-area">
              <input type="text" id="searchText" placeholder="Search" onkeyup="searchListings(this.value)">
              <button onclick="searchListings(getElementById('searchText').value, 1)" t-id="17">Search</button>
            </div>
                    <button id="favorites-button" onclick="searchFavorites()"><span id="star-symbol">&bigstar;</span><span id="favorites-text"></span></button>
          </div>
          <div id="loadingStatus"></div>
          <div class="pagination">
                    <!-- <button onclick="previousPage()" t-id="18"> -->
                      <button onclick="previousPage()">
              <div class="prev-next-icon">
                          <img src="previous-icon.svg" alt="previous-icon"/>
              </div>
            </button>
            <span id="paginationNumbers"></span> <!-- Container for page numbers -->
            <!-- <button onclick="nextPage()" t-id="10"> -->
            <button onclick="nextPage()">
              <div class="prev-next-icon">
                            <img src="next-icon.svg" alt="next-icon"/>
              </div>
            </button>
            <select id="SortBy">
              <option value="default" t-id="20">Sort: Default</option>
              <option value="price-low" t-id="21">Sort: Best price</option>
              <option value="price-high" t-id="22">Sort: High price</option>
            </select>
          </div>
          <select id="SortBy" class="mobile-pagination-select">
            <option value="default" t-id="20">Sort: Default</option>
            <option value="price-low" t-id="21">Sort: Best price</option>
            <option value="price-high" t-id="22">Sort: High price</option>
          </select>
        </div>
      </div>
      <div class="listings">
        <!-- populated by JavaScript -->
      </div>
    </div>
    <div class="main offers offers-categories">
      <h2 t-id="23">OFFERS</h2>
      <div id="myoffers" class="myoffers"></div>
    </div>
    <div class="main contracts offers-categories">
      <h2 t-id="24">CONTRACTS</h2>
      <div id="mycontracts" class="mycontracts"></div>
    </div>
    <div class="main account account-details-wrapper">
      <h2 t-id="25">ACCOUNTS</h2>
      <p id="account" t-id="26">Please connect metamask</p>
      <div class="account-btn-wrapper">
        <button id="loginButton" t-id="53" onclick="login(1)" style="display: none;">Login/Connect</button>
      </div>
      <div class="account-btn-wrapper">
        <button onclick="deposit()" t-id="27">Deposit tokens</button>
        <button onclick="withdraw()" t-id="28">Withdraw tokens</button>
      </div>
      <div class="account-form-wrapper">
        <div class="account-input-box width-28">
          <label for="myContactInfo" t-id="29">Contact Information (email/signal/telegram):</label>
          <input id="myContactInfo" onblur="validateContactInfo(this)" oninput="validateContactInfo(this)">
          <span id="contactInfoWarning" style="color: red; display: none;">Please enter a valid email address.</span>
        </div>
        </div>
        <div class="account-form-wrapper">
        <div class="account-input-box width-28">
          <label for="myPassword" t-id="44">Password(for encryption):</label>
          <input id="myPasswordInput" type="password"></input>
        </div>
        </div>
        <div class="account-form-wrapper">
        <div class="account-input-box account-box-position account-box-mobile width-28">
              <button onclick="registerData()" t-id="30">Register information to my address(contact/encryption/optional)</button>
        </div>
      </div>
      <div id="publicemail"></div>
      <div class="account-form-wrapper checkboxes-form-wrapper">
        <div class="account-input-box input-checkboxes">
          <label for="clearCompleted" t-id="31">
            Automatically clear completed contracts
            <input id="clearCompleted" type="checkbox" checked="checked"></input>
            <span class="checkmark"></span>
          </label>
        </div>
        <div class="account-input-box input-checkboxes">
          <label for="emailClient" t-id="50">
            Attempt to notify prospects through default email client(when applicable)
            <input id="emailClient" type="checkbox" checked></input>
            <span class="checkmark"></span>
          </label>
        </div>
      </div>
      <div class="account-form-wrapper">
        <div class="account-input-box account-box-position account-box-mobile width-28">
          <button onclick="RefreshContracts()" t-id="32">Refresh/restore previously cleared contracts</button>
        </div>
      </div>
      <div class="account-form-wrapper">
        <div class="account-input-box">
          <label for="offerExpiration" t-id="33">Private offers expire: </label>
          <select id="offerExpiration">
            <option value="two-weeks" t-id="35">Two weeks</option>
            <option value="one-month" t-id="36">One month</option>
            <option value="never" t-id="34">Never</option>
          </select>
        </div>
        </div>
        <div class="account-form-wrapper">
        <div class="account-input-box account-box-position ">
          <button onclick="backupLocalStorage()" t-id="37">Backup cached site/user data</button>
        </div>
        <div class="account-input-box account-box-position">
          <button onclick="loadLocalStorage()" t-id="38">Load site/user data from file</button>
        </div>
      </div>
      <div class="account-form-wrapper">
        <div class="account-input-box">
          <label>User Default Ipfs Pinata Gateaway</label>
          <select id="connectMethod">
            <option value="0" t-id="39">Use default IPFS Pinata Gateway</option>
          </select>
        </div>
      </div>
      <div class="account-form-wrapper">
        <div class="account-input-box account-box-position">
          <button onclick="setCustodian()" t-id="51">Set cosigner</button>
        </div>
        <div class="account-input-box account-box-position">
          <button onclick="modifyCustodian()" t-id="54">Remove Cosigner</button>
        </div>
        <div class="account-input-box account-box-position">
          <button onclick="cosign()" t-id="52">Cosign</button>
        </div>
      </div>
      <h2 t-id="45" style="font-size: 16px">Earn</h2>
      <p id="affiliateInfo" t-id="46">Not connected</p>
      <div class="account-form-wrapper">
        <div class="account-input-box account-box-position">
          <button onclick="copyAffiliateLink()" t-id="47">Copy affiliate link</button>
        </div>
        <div class="account-input-box account-box-position">
          <button onclick="changeAffiliate()" t-id="48">Change my affiliate</button>
        </div>
        <div class="account-input-box account-box-position">
          <button onclick="setCustomFee()" t-id="49">Set custom referral fee</button>
        </div>
      </div>
    </div>
    <div class="main about about-us">
      <!-- ss-container tag can be used for custom scrollers but it's not totally cross platform -->
      <div class="about-content-area">
        <div class="tabs-content-wrapper">
          <div class="about-tab">
            <button class="abouttablinks active" t-id="9" onclick="openCity(event, 'About')">About</button>
            <button class="abouttablinks" onclick="openCity(event, 'FAQ')">Frequently Asked Questions</button>
          </div>
          <div id="About" class="abouttabcontent" style="display: block;">
            <h2 t-id="40">ABOUT</h2>
            <div class="about-box-info">
              <p t-id="41">Welcome to the world of unbreakable contracts. These are two party escrow(double deposit) contracts that cannot be broken and require no 3rd party arbiters. Both users place a customizable deposit along with a payment into a joint account. If the deal goes well they both sign off on it. If one party tries to defraud the other the deal will eventually expire and blow up making it so that nobody wins and theft is profitless. This forces the users to be honest and follow through with their agreements since they either win together or they lose together.</p>
              <a href="https://www.youtube.com/watch?v=fge5inFWlkc" class="about-box-img">
                <img src="two-party-escrow.jpg" alt="about box img"/>
              </a> 
              <p t-id="42">The markets themselves run on top of Solidity chains such as Ethereum and Polygon. Offers can range from goods, services, barter and p2p trading. Since this webpage is fully open source and runs on the client side, the user can also download this code from github and run it locally for even greater security. This protocol which was pioneered by BitHalo back in 2014 predated Ethereum and was the worlds first smart contracts. This is a web based interface for fully decentralized markets.</p>
              <p t-id="43">For selling goods, users will definitely want to consider a drop shipping service or a service that provides discount shipping to compete with the shipping rates typically found in major companies. To do this, you should sign up for a 3rd party shipping account which should allow you to save up to 75% in shipping in some cases. Sellers may also charge buyers for shipping while in escrow and buyers should be careful to make sure the amount doesn't exceed the deposits or that they buy the shipping label themselves. Users should try to keep in communication with each other through the escrow process and it's recommended to have a backup of your keys so both parties are protected during escrow. Although these markets could be moderated through AI(such as webgpt) and community driven moderation, users are entirely responsible for the risks of what they post and for their own escrows. With that in mind, it's strongly recommended to not post content that is illegal in the country you reside. For deals that involve cash users should do their own due dilligence and their own 'know your customer' if needed. It's in everyones best interest to use double deposit escrow to get rid of deception in the world of international commerce and services. It is an advantage when users administrate contracts themselves because arbiters are unable to know the truth of a deal ruling unfairly and can collude causing great losses and they also incur a greater cost. Users are forced to work with each other to achieve a desirable outcome. Users are also the ones who host the offers using IPFS. So it's good practice to run your own IPFS node to archive the markets. It's recommended that you register your contact information to the blockchain. This makes it guaranteed that counter-parties in the contract know how to contact you for any questions about the negotiations. The code may be run locally and can also be audited by visiting the github page where the code and website are hosted. This system is ownerless and entirely free to use. However, there is a setting that can be activated for affiliates/referrals which can range from 0-1%. In order to encourage users to engage with affiliates, the fee is burned if it is not paid to an affiliate. This helps market the system by giving users a way to earn. A user of the markets is automatically an affiliate if they complete 10 deals. That allows them to use the markets for free if they choose to(as they can be their own affiliate) and it allows them to send users to the website through an affiliate link. Visiting through a link registers the affiliate to that account when a deal is accepted and let's them benefit from that referral. Also, some sellers may offer a more attractive referral fee which should allow affiliates to net more by mutual consent. For more information on how BitBay works you may visit: <a href="https://bitbay.market" target="_blank">https://bitbay.market</a></p>
            </div>
          </div>
          <div id="FAQ" class="abouttabcontent">
            <div class="faq-accordion">
              <h3></h3>
              <div id="accordionWrapper" class="accordionWrapper"></div>
            </div>
          </div>
        </div>
        <!-- <div class="faq-content-wrapper">
        </div> -->
        <!-- <p t-id="41"></p> -->
      </div>
      <div id="abount-container">
      </div>
    </div>
    <a href="#" class="notification-lottie-file">
      <lottie-player
          src="https://lottie.host/ef562761-9dbd-49d2-8caa-39438d4ee918/p99FGDA20q.json"
          background="transparent" speed="1" loop></lottie-player>
    </a>
    <div id="notification-box" class="notification-box-wrapper">
      <div class="site-loader"><div class="loader"></div></div>
    </div>
  </div>
  <script>
    function setActionActive(actionCode, isActive) {
      activeActions[Crypto.SHA256(actionCode)] = isActive;
    }

    function validateContactInfo(contactInput) {
      const warningSpan = document.getElementById('contactInfoWarning');
      const emailClientCheckbox = document.getElementById('emailClient');
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; // Simple email validation regex

      if (emailClientCheckbox.checked && (contactInput.value === '' || !emailRegex.test(contactInput.value))) {
          warningSpan.style.display = 'block'; // Show warning if invalid
          warningSpan.textContent = translateThis('Please enter a valid email address so you can automatically email users who share their email address.');
      } else {
          warningSpan.style.display = 'none'; // Hide warning if valid
      }
    }
    document.querySelectorAll('button').forEach(button => {
      if (!button.classList.length && !button.closest('.sidebar')) {
        button.classList.add('square-button2');
      }
    });
    function populateLanguageSelect() {
      const languageSelect = document.getElementById("languageSelect");

      langOptions.forEach((lang) => {
        const option = document.createElement("option");
        option.value = lang.substring(0, 2).toLowerCase();
        option.textContent = lang;

        // Create and append flag image
        const flagImg = document.createElement("img");
        flagImg.src = `${lang.toLowerCase()}.png`;
        flagImg.alt = lang;
        option.appendChild(flagImg);

        languageSelect.appendChild(option);
      });
      languageSelect.selectedIndex = 0;
    }

    document.getElementById("languageSelect").addEventListener('change', async function() {
      const languageSelect = document.getElementById("languageSelect");
      const selectedFlagImg = document.getElementById("selectedFlag");
      selectedFlagImg.src = languageSelect.options[languageSelect.selectedIndex].getElementsByTagName('img')[0].src;
      translateDocument(languageSelect.options[languageSelect.selectedIndex].value);
      await loadUser();
      await populateListings();
    });

    function translateThis(mytext) {
      const selectedLanguageCode = document.getElementById("languageSelect").value;
      if(selectedLanguageCode in languages) {
        if(mytext in languages[selectedLanguageCode]) {
          return languages[selectedLanguageCode][mytext];
        }
      }
      return mytext;
    }

    extractedCalls = {'en':{}};
    function extractTranslations() {
      // Get the entire HTML document
      const entireHTML = document.documentElement.outerHTML;

      // Define the regular expression for finding translateThis function calls
      const translateRegex = /translateThis\(['"](.*?)(?:"|')\)/gm;

      // Iterate over matches
      let match;
      while ((match = translateRegex.exec(entireHTML)) !== null) {
        const extractedText = match[1]; // Extracted text from the capturing group
        // Add the extracted text to extractedCalls under 'en'
        extractedCalls['en'][extractedText] = true;
      }

      // Now extractedCalls['en'] contains all the extracted texts
    }

    populateLanguageSelect();

    function translate(text, lang, x) {
      if(lang in languages && x in languages[lang]) {
          return languages[lang][x]["#"+lang];
      } else {
        return text;
      }
    }

    function translateDocument(lang) {
      document.querySelectorAll('[t-id]').forEach(element => {
        const tId = element.getAttribute('t-id');
        const nonTextContent = Array.from(element.childNodes).filter(node => node.nodeType !== 3);
        const textContent = element.textContent;
        languages[tId] = { "#e": textContent };

        // Translate the text content
        const translatedText = translate(textContent, lang, tId);

        // Update the text content
        element.textContent = translatedText;

        // Reinsert the non-text content
        nonTextContent.forEach(node => element.appendChild(node));
      });
      populateAbout(true);
    }

    function populateAbout(isTranslationUpdate = false) {
      const accordionWrapper = document.getElementById('accordionWrapper');
      accordionWrapper.innerHTML = ''; // Clear existing content

      // Translate and set the FAQ heading
      const faqButton = document.querySelector('.about-tab button:nth-child(2)');
       faqButton.textContent = translateThis('Frequently Asked Questions');

      myfaq.forEach((section, index) => {
        if (typeof section === 'string') { // Section title
          const header = document.createElement('h4');
          header.textContent = translateThis(section);
          accordionWrapper.appendChild(header);
        } else { // Questions and Answers
          for (let i = 0; i < section.length; i += 2) {
            const questionText = section[i];
            const answerText = section[i + 1];

            const question = document.createElement('div');
            
            question.classList.add('accordionItem', 'accordion-close');
            question.innerHTML = `<h2 class="accordionItemHeading"><span>${(i/2 + 1).toString().padStart(2, '0')}</span>${translateThis(questionText)}</h2>`;
            const answer = document.createElement('div');
            answer.classList.add('accordionItemContent');
            answer.innerHTML = `<p>${translateThis(answerText)}</p>`;
            answer.style.maxHeight = "0px";
            question.appendChild(answer);

            accordionWrapper.appendChild(question);
          }
        }
      });
      if (isTranslationUpdate) {
        attachAccordionEventListeners();
      }
    }

    function attachAccordionEventListeners() {
      const accordionItems = document.querySelectorAll('.accordionItemHeading');
      accordionItems.forEach(item => {
        item.addEventListener('click', function() {
          const content = this.nextElementSibling;

          document.querySelectorAll('.accordionItemContent').forEach(otherContent => {
            if (otherContent !== content) {
              otherContent.style.maxHeight = "0px";
              otherContent.parentNode.classList.replace('accordion-open', 'accordion-close');
            }
          });

          if (content.style.maxHeight === "0px") {
            content.style.maxHeight = content.scrollHeight + "px";
            this.parentNode.classList.replace('accordion-close', 'accordion-open');
          } else {
            content.style.maxHeight = "0px";
            this.parentNode.classList.replace('accordion-open', 'accordion-close');
          }
        });
      });
    }

    populateAbout();

    var loadedFiles = {};
    // Open or create the IndexedDB database
    var request = indexedDB.open('fileDatabase', 1);

    // Setup the database structure if it doesn't exist
    request.onupgradeneeded = async function(event) {
      db = event.target.result;
      var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
      objectStore.createIndex('hash', 'hash', { unique: true });
    };

    // Assign the database reference once it's successfully opened
    request.onsuccess = function (event) {
      return new Promise(async function (resolve) {
        db = event.target.result;

        // Initialize loadedFiles from IndexedDB
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function (event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});

          resolve(); // Resolve the promise once the asynchronous operation is done
        };
      });
    };

    // Loder-Modal Methods
    function showLoader() {
      const loaderModal = document.getElementById('loader-modal');
      loaderModal.style.display = 'flex';
      loaderModal.style.width = '100%'; // Full screen width
      loaderModal.style.height = '100%'; // Full screen height
      loaderModal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Enable background fading
      document.getElementById('loader-content').style.display = 'block';
      document.getElementById('loader-minimized').style.display = 'none';
    }

    function hideLoader() {
      document.getElementById('loader-modal').style.display = 'none';
    }

    function minimizeLoader() {
      const loaderModal = document.getElementById('loader-modal');
      loaderModal.style.backgroundColor = 'transparent'; // Remove background fading
      loaderModal.style.width = '0'; // Minimize modal size
      loaderModal.style.height = '0'; // Minimize modal size
      document.getElementById('loader-content').style.display = 'none';
      document.getElementById('loader-minimized').style.display = 'block';
    }

    function maximizeLoader() {
      const loaderModal = document.getElementById('loader-modal');
      loaderModal.style.width = '100%'; // Restore full screen width
      loaderModal.style.height = '100%'; // Restore full screen height
      loaderModal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Re-enable background fading
      document.getElementById('loader-content').style.display = 'block';
      document.getElementById('loader-minimized').style.display = 'none';
    }

    // Function to open the IndexedDB database
    async function openDatabase() {
      return new Promise(function(resolve, reject) {
        var request = indexedDB.open('fileDatabase', 1);

        request.onupgradeneeded = function(event) {
          db = event.target.result;
          var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
          objectStore.createIndex('hash', 'hash', { unique: true });
        };

        request.onsuccess = function(event) {
          db = event.target.result;
          resolve();
        };

        request.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to initialize loadedFiles from IndexedDB
    async function initializeLoadedFiles() {
      return new Promise(function(resolve, reject) {
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function(event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});
          resolve();
        };

        transaction.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to get file from IndexedDB
    async function getFile(hash) {
      return new Promise(function (resolve, reject) {
        if(hash=='') {
          resolve(['']);
        }
        // Check if the file hash is in loadedFiles
        if (!(hash in loadedFiles)) {
          // If not, fetch it from IndexedDB
          var transaction = db.transaction(['files'], 'readonly');
          var objectStore = transaction.objectStore('files');

          var request = objectStore.get(hash);

          request.onsuccess = async function (event) {
            var file = event.target.result;
            if (file) {
              loadedFiles[hash] = file.data;
              resolve(loadedFiles[hash]); // Resolve the promise with the file data
            } else {
              resolve(['']); //Image not found in IndexedDB
            }
          };

          request.onerror = async function (event) {
            resolve(['']); //event.target.error
          };
        } else {
          resolve(loadedFiles[hash]); // Resolve the promise with the cached file data
        }
      });
    }


    // Function to store image/file in IndexedDB
    async function storeFile(hash, data) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');
      // Put the file data into the object store
      objectStore.put({ hash: hash, data: data });
      loadedFiles[hash] = data;
    }

    async function storeFiles(files) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');

      for (var hash in files) {
        objectStore.put({ hash: hash, data: files[hash] });
      }
      loadedFiles = files;
    }

    function changeSearchText(newText, element) {
      
      document.querySelectorAll('.header2 a').forEach(tag => {
        tag.classList.remove('active');
      });
      
      element.classList.add('active');


      document.getElementById('searchText').value = newText;
      searchListings(newText, 1);
    }

    document.getElementById('SortBy').addEventListener('change', function () {
      if(currentViewContext == "searchTag") {
        populateListings("", 1);
      } else {
        populateListings();
      }
    });

    showMain('markets');
    var web3 = [];
    var DDEcontract = "";
    var DDEaddy = "0x917ade76a2614A23A94C38425f77627868284f8B"; //Sepolia testnet is default market view
    var myaccounts = "";
    var userpubkey = "";
    var userprivkey = "";
    var accountprivkey = "";
    var gasOptions = [{},{}];    
    var gasSetting = 1;
    var balances = {};
    var baseBalance = 0;
    var newkey = 0;
    var myContactInfo = document.getElementById("myContactInfo");
    var offerExpiration = document.getElementById("offerExpiration");
    var AESkey = Crypto.SHA256("shared key")
    var currentMarketsLength = 0;
    var gasPrice = "";
    var CurrentTimeStamp = new Date().getTime();
    var tokens = [
      {
        address: "0xA66857Da8d75BE2363968a3B01BfE1f417B28202",
        token: "ETH",
        image: "eth.png",
        decimals: "18"
      },
      {
        address: "0xD7567f0841Aae04833C8c004e8685cBF9F1a6b11",
        token: "WALRUS",
        image: "walrus.png",
        decimals: "8"
      }
    ];
    var tokennames = {"0xA66857Da8d75BE2363968a3B01BfE1f417B28202":"ETH","0xD7567f0841Aae04833C8c004e8685cBF9F1a6b11":"WALRUS"}
    web3 = new Web3("https://rpc.ankr.com/eth_sepolia");
    var referral = "0x0000000000000000000000000000000000000000";
    var baseFee = 0;
    var myFavorites = [];
    var DDEcontract2 = new web3.eth.Contract(DDEabi, DDEaddy);
    var marketOffers = {'indices':[], 'results':[]};
    var currentViewContext = '';
    var contextIndex = 0;
    var maxContextLoad = [2,2,2,2];
    //web3[0] = new Web3("https://cloudflare-eth.com");
    //web3[1] = new Web3("https://bsc-dataseed.binance.org");
    //web3[2] = new Web3("https://api-goerli.etherscan.io/");
    var isConnected = false;
    var showOrder = false;
    var body = document.body;
    var isMobile = window.innerWidth <= 992;
    var isFavoritesShown = false;
    var locked = false;
    var activeActions = {};
    const statusDescriptions = {
      "0": "",
      "1": "",
      "2": "",
      "3": "",
      "4": "",
      "5": ""
    };

    const combinedStatusDescriptions = {
        "1,0": "Offer",
        "2,0": "Public Offer",
        "3,0": "Public Offer",
        "0,1": "Private Offer",
        "1,1": "Mutually Accepted",
        "1,2": "Cancelled by One Party, Awaiting Closure",
        "1,3": "Cancelled by One Party, Awaiting Closure",
        "1,4": "Mutually Agreed Cancellation",
        "2,1": "Completed by One Party, Awaiting Closure",
        "2,2": "Completed by One Party, Awaiting Closure",
        "2,3": "Completed by One Party, Awaiting Closure",
        "2,4": "Mutually Agreed Cancellation",
        "3,1": "Completed by One Party, Awaiting Closure",
        "3,2": "Completed by One Party, Awaiting Closure",
        "3,3": "Completed by One Party, Awaiting Closure",
        "3,4": "Mutually Agreed Cancellation",
        "4,1": "Fully Completed",
        "4,2": "Fully Completed",
        "4,3": "Fully Completed",
        "4,4": "Private offer cancelled",
        "5,5": "Expired and Closed"
    };
    var loader = '<div class="site-loader"><div class="loader"></div></div>';
    var notifyFavorites = localStorage.getItem(myaccounts + DDEaddy + ":notifyFavorites");
    if(!notifyFavorites) {
      notifyFavorites = "0";
    }
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    // Detect language
    var qlang = getQueryParam('l') || 'en';  // Default to 'en' if not provided
    var referralCode = getQueryParam('r') || 'default';
    if(referralCode != 'default') {
      referral = referralCode;
      if (!web3.utils.isAddress(referral)) {
        referral = "0x0000000000000000000000000000000000000000";
      }
    }
    if (qlang !== 'en') {
      var languageSelect = document.getElementById('languageSelect');

      // Find the index of the option with the specified value
      var optionIndex = -1;
      for (var i = 0; i < languageSelect.options.length; i++) {
        if (languageSelect.options[i].value === qlang) {
          optionIndex = i;
          break;
        }
      }

      // If the option is found, change the selected index and trigger the "change" event
      if (optionIndex !== -1) {
        languageSelect.selectedIndex = optionIndex;
        var event = new Event('change');
        languageSelect.dispatchEvent(event);
      }
    }

    window.addEventListener('ethereum#initialized', login, {
      once: true,
    });

    defaultvars();
    function defaultvars() {
      DDEcontract = "";
      myaccounts = "";
      DDEaddy = "0x917ade76a2614A23A94C38425f77627868284f8B";
      balances = {};
      baseBalance = 0;
      gasPrice = "";
      document.getElementById("account").innerHTML = translateThis("Not connected.");
      document.getElementById("loginButton").style.display = 'block';
      document.getElementById("myContactInfo").value = '';
      document.getElementById("myoffers").innerHTML = ""; // clear the container first
      document.getElementById("mycontracts").innerHTML = ""; // clear the container first
      document.getElementById('publicemail').innerHTML = "";
      document.getElementById('myPasswordInput').value = "";
      document.getElementById("myPasswordInput").disabled = true;
      offerExpiration.selectedIndex = 0;
      currentMarketsLength = 0;
      userpubkey = "";
      userprivkey = "";
      accountprivkey = "";
      gasOptions = [{},{}];
      gasSetting = 1;
      baseFee = 0;
      myFavorites = [];
      newkey = 0;
      activeActions = {};
    }

    async function login(clear = 0) {
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isMetaMaskInstalled = typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask;

        // Android device but not in MetaMask browser
        if (isAndroid && !isMetaMaskInstalled) {
            Swal.fire({
                title: translateThis('Login using unique password'),
                html:
                    '<select id="network" class="swal2-select">' +
                    '<option value="0">Ethereum</option>' +
                    '<option value="1" selected>Sepolia Testnet</option>' +
                    '</select>' +
                    '<input type="password" id="password" class="swal2-input" placeholder="' + translateThis('Enter Password') + '">' +
                    '<input type="password" id="confirmPassword" class="swal2-input" placeholder="' + translateThis('Confirm Password') + '">',
                focusConfirm: false,
                showCancelButton: true,
                confirmButtonText: translateThis('Confirm'),
                cancelButtonText: translateThis('Cancel'),
                preConfirm: () => {
                    const network = document.getElementById('network').value;
                    const password = document.getElementById('password').value;
                    const confirmPassword = document.getElementById('confirmPassword').value;

                    if (password !== confirmPassword) {
                        Swal.showValidationMessage(translateThis('Passwords do not match'));
                        return false;
                    }

                    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+])[A-Za-z\d!@#$%^&*()_+]{16,}$/;

                    if (!password.match(passwordRegex)) {
                        Swal.showValidationMessage(translateThis('Password must be 16 characters long and contain at least one lowercase letter, one uppercase letter, one number, and one special character.'));
                        return false;
                    }

                    return { network: network, confirmedPassword: password };
                }
            }).then(async (result) => {
                if (result.isConfirmed) {
                    const { network, confirmedPassword } = result.value;
                    showLoader();
                    var hashedPassword = Crypto.SHA256(confirmedPassword);
                    for (var i = 1; i < 50000; i++) {
                        hashedPassword = Crypto.SHA256(hashedPassword);
                    }
                    accountprivkey = '0x' + hashedPassword;
                    userprivkey = cryptico.generateRSAKey(Crypto.SHA256(hashedPassword), 1024);
                    userpubkey = cryptico.publicKeyString(userprivkey);
                    document.getElementById("myPasswordInput").value = Crypto.SHA256("default");
                    document.getElementById("myPasswordInput").disabled = true;
                    if (parseInt(network) === 0) {
                        web3 = new Web3("https://rpc.ankr.com/eth");
                    } else {
                        web3 = new Web3("https://rpc.ankr.com/eth_sepolia");
                    }
                    const account = await web3.eth.accounts.privateKeyToAccount(accountprivkey);
                    const wallet = web3.eth.accounts.wallet;
                    wallet.add(account);
                    hideLoader();
                    isConnected = true;
                    document.getElementById("connectionstatus").innerHTML = translateThis("Connected.");
                    document.getElementById("account").innerHTML = loader;
                    document.getElementById("loginButton").style.display = 'none'; // Hide login button
                    var offersContainer = document.getElementById("myoffers");
                    var contractsContainer = document.getElementById("mycontracts");
                    offersContainer.innerHTML = loader;
                    contractsContainer.innerHTML = loader;
                    await loadUser(1);
                    await populateListings();
                }
            });
            return;
        }

        // Non-Android or MetaMask is installed
        await Swal.fire({
            title: translateThis('Login/connect'),
            text: translateThis('Please choose which way you want to log into this website.'),
            showCancelButton: true,
            confirmButtonText: isMetaMaskInstalled ? translateThis('Connect Using Metamask') : translateThis('Install MetaMask'),
            cancelButtonText: translateThis('Create/access account using password'),
        }).then(async (result) => {
            if (result.isConfirmed) {
                if (isMetaMaskInstalled) {
                    defaultvars();
                    console.log("connecting");
                    await window.ethereum.request({method: 'eth_requestAccounts'});
                    web3 = new Web3(window.ethereum);
                    console.log("success");
                    if (clear == 1) {
                        marketOffers = {'indices': [], 'results': []};
                    }
                    isConnected = true;
                    document.getElementById("connectionstatus").innerHTML = translateThis("Connected.");
                    document.getElementById("account").innerHTML = loader;
                    document.getElementById("loginButton").style.display = 'none'; // Hide login button
                    var offersContainer = document.getElementById("myoffers");
                    var contractsContainer = document.getElementById("mycontracts");
                    offersContainer.innerHTML = loader;
                    contractsContainer.innerHTML = loader;
                    await loadUser(1);
                    await populateListings();
                } else {
                    // Redirect to MetaMask installation page
                    window.location.href = 'https://metamask.io/download.html';
                }
            } else {
                Swal.fire({
                    title: translateThis('Login using unique password'),
                    html:
                        '<select id="network" class="swal2-select">' +
                        '<option value="0">Ethereum</option>' +
                        '<option value="1" selected>Sepolia Testnet</option>' +
                        '</select>' +
                        '<input type="password" id="password" class="swal2-input" placeholder="'+translateThis('Enter Password')+'">' +
                        '<input type="password" id="confirmPassword" class="swal2-input" placeholder="'+translateThis('Confirm Password')+'">',
                    focusConfirm: false,
                    showCancelButton: true,
                    confirmButtonText: translateThis('Confirm'),
                    cancelButtonText: translateThis('Cancel'),
                    preConfirm: () => {
                        const network = document.getElementById('network').value;
                        const password = document.getElementById('password').value;
                        const confirmPassword = document.getElementById('confirmPassword').value;
                        
                        if (password !== confirmPassword) {
                            Swal.showValidationMessage(translateThis('Passwords do not match'));
                            return false;
                        }

                        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+])[A-Za-z\d!@#$%^&*()_+]{16,}$/;

                        if (!password.match(passwordRegex)) {
                            Swal.showValidationMessage(translateThis('Password must be 16 characters long and contain at least one lowercase letter, one uppercase letter, one number, and one special character.'));
                            return false;
                        }

                        return { network: network, confirmedPassword: password };
                    }
                }).then(async (result) => {
                    if (result.isConfirmed) {
                        defaultvars();
                        const { network, confirmedPassword } = result.value;
                        showLoader();
                        var hashedPassword = Crypto.SHA256(confirmedPassword);
                        for(var i=1; i<50000; i++) {
                            hashedPassword = Crypto.SHA256(hashedPassword);
                        }
                        accountprivkey = '0x' + hashedPassword;
                        userprivkey = cryptico.generateRSAKey(Crypto.SHA256(hashedPassword), 1024);
                        userpubkey = cryptico.publicKeyString(userprivkey);
                        document.getElementById("myPasswordInput").value = Crypto.SHA256("default");
                        document.getElementById("myPasswordInput").disabled = true;
                        if(parseInt(network) == 0) {
                            web3 = new Web3("https://rpc.ankr.com/eth");
                        } else {
                            web3 = new Web3("https://rpc.ankr.com/eth_sepolia");
                        }
                        const account = await web3.eth.accounts.privateKeyToAccount(accountprivkey);
                        const wallet = web3.eth.accounts.wallet;
                        wallet.add(account);
                        hideLoader();
                        isConnected = true;
                        if (clear == 1) {
                            marketOffers = {'indices': [], 'results': []};
                        }
                        document.getElementById("connectionstatus").innerHTML = translateThis("Connected.");
                        document.getElementById("account").innerHTML = loader;
                        document.getElementById("loginButton").style.display = 'none'; // Hide login button
                        var offersContainer = document.getElementById("myoffers");
                        var contractsContainer = document.getElementById("mycontracts");
                        offersContainer.innerHTML = loader;
                        contractsContainer.innerHTML = loader;
                        await loadUser(1);
                        await populateListings();
                    }
                });
            }
        });
    }

    async function login2(clear = 0) {
      if (window.ethereum) { //Note: for mobile this only works if the webpage has <head> tag
          console.log("connecting");
          await window.ethereum.request({method: 'eth_requestAccounts'});
          web3 = new Web3(window.ethereum);
          console.log("success");
          if(clear == 1) {
              marketOffers = {'indices':[], 'results':[]};
          }
          isConnected = true;
          document.getElementById("connectionstatus").innerHTML = translateThis("Connected.");
          document.getElementById("account").innerHTML = loader;
          document.getElementById("loginButton").style.display = 'none'; // Hide login button
          var offersContainer = document.getElementById("myoffers");
          var contractsContainer = document.getElementById("mycontracts");
          offersContainer.innerHTML = loader;
          contractsContainer.innerHTML = loader;
          await loadUser(1);
          await populateListings();
      } else {
          isConnected = false;
          document.getElementById("connectionstatus").innerHTML = translateThis("Not connected.");
          document.getElementById("loginButton").style.display = 'block'; // Show login button
      }
    }
    
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    
    async function loadUser(login=0) {
      if (!isConnected) {
        return;
      }
      var myaccounts2 = await web3.eth.getAccounts();
      if (myaccounts2.length == 0 && accountprivkey == "") {
        document.getElementById("connectionstatus").innerHTML = isMobile ? '' : translateThis("Please unlock Metamask so it can connect.");
        return;
      }
      currentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
      var netname = "unknown";
      var netname2 = "ETH";
      if (currentChainId == "11155111") {
        await web3.eth.getGasPrice().then(function (theGasPrice) {
          gasPrice = window.web3.utils.toWei(parseInt(parseInt(DOMPurify.sanitize(theGasPrice)) * 1.5).toString(), 'wei');
                if(parseInt(gasPrice) > 900000000000) {
                    gasPrice = "900000000000";
              }
                if(parseInt(gasPrice) < 2500000000) {
            gasPrice = "2500000000";
          }
        });
        netname = "Sepolia Testnet";
        netname2 = "ETH";
        DDEaddy = "0x917ade76a2614A23A94C38425f77627868284f8B";
        gasOptions[0] = {
          gasLimit: 1500000,
          gasPrice: null,
          maxPriorityFeePerGas: window.web3.utils.toWei('1.5', 'gwei'), // Max priority fee of 1.5 Gwei
          maxFeePerGas: window.web3.utils.toWei('1.6', 'gwei'), // Max base fee of 1.5 Gwei
        };
        gasOptions[1] = {
          gasLimit: 1500000,
          gasPrice: gasPrice
        };
        tokens = [
          {
            address: "0xA66857Da8d75BE2363968a3B01BfE1f417B28202",
            token: "ETH",
            image: "eth.png",
            decimals: "18"
          },
          {
            address: "0xD7567f0841Aae04833C8c004e8685cBF9F1a6b11",
            token: "WALRUS",
            image: "walrus.png",
            decimals: "8"
          }
        ];
        tokennames = {"0xA66857Da8d75BE2363968a3B01BfE1f417B28202":"ETH","0xD7567f0841Aae04833C8c004e8685cBF9F1a6b11":"WALRUS"}
      }
      if (netname == "unknown") {
        document.getElementById("connectionstatus").innerHTML = isMobile? '' : translateThis("Unsupported network");
        return;
      }
      document.getElementById("connectionstatus").innerHTML = isMobile? '' :  translateThis("Connected to") + " " + netname;
      const metabutton = document.querySelector('[t-id="3"]');
      if (metabutton && window.innerWidth <= 800) {
        metabutton.textContent = translateThis('Connected');
      }
      if(accountprivkey != "") {
        myaccounts = await web3.eth.accounts.privateKeyToAccount(accountprivkey).address;
      } else {
        myaccounts = DOMPurify.sanitize(myaccounts2[0]);
      }
      var cached = await getContactInfo(myaccounts);
      document.getElementById("myContactInfo").value = cached;
      cached = await getExpirationInfo(myaccounts);
      var offerExpirationSelect = document.getElementById("offerExpiration");
      if (cached != '') {
        for (let i = 0; i < offerExpirationSelect.options.length; i++) {
          if (offerExpirationSelect.options[i].value === cached) {
            offerExpirationSelect.selectedIndex = i;
            break;
          }
        }
      } else {
        offerExpirationSelect.selectedIndex = 0;
      }
      loadAutoClearState();
      loadEmailClientState();
      const theFavorites =  localStorage.getItem(myaccounts + DDEaddy + ":myFavorites");
      if(theFavorites) {
        myFavorites = JSON.parse(theFavorites);
      }
      checkFavorites();        
      if(document.getElementById("myPasswordInput").value != Crypto.SHA256("default") && newkey == 0 && accountprivkey == "") {
        const newPassHash =  localStorage.getItem(myaccounts + ":mypassword");
        if(!newPassHash) {
          await Swal.fire({
            title: translateThis('Create encryption key'),
            text: translateThis('The program needs to create your encryption key. To do this it will ask you to sign a secret message using your wallet. Please follow the instructions so that encryption may be enabled.')
          });
          var mysignature = "";
          try {
            mysignature = await window.ethereum.request({
              method: 'personal_sign',
              params: ["This message is used to generate your RSA key.", window.ethereum.selectedAddress],
            });
            mysignature=Crypto.SHA256(mysignature);
            localStorage.setItem(myaccounts + ":mypassword", mysignature);
            userprivkey = mysignature;
            showLoader();
            for(var i=1; i<50000; i++) {
              userprivkey=Crypto.SHA256(userprivkey);
            }
            userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
            userpubkey = cryptico.publicKeyString(userprivkey);
            document.getElementById("myPasswordInput").value = Crypto.SHA256("default");
            hideLoader();
          } catch (error) {
            await Swal.fire({
              title: translateThis('Key creation failed'),
              text: translateThis('You may choose to refresh the page to try again or you can attempt to create the key at a later date.')
            });
            hideLoader();
          }
          newkey = 1;
        } else {
          showLoader();
          userprivkey = newPassHash;
          for(var i=1; i<50000; i++) {
            userprivkey=Crypto.SHA256(userprivkey);
          }
          hideLoader();
          userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
          userpubkey = cryptico.publicKeyString(userprivkey);
          document.getElementById("myPasswordInput").value = Crypto.SHA256("default");
          newkey = 1;
        }
      }
      //const userPWHash = localStorage.getItem(myaccounts + ":password");
      //if(userPWHash && document.getElementById("myPasswordInput").value != Crypto.SHA256("default")) {
      //  const userPWHash2 = localStorage.getItem(myaccounts + ":savedpw");
      //  if(!userPWHash2) {
      //    await getUserPassword();
      //  } else {
      //    document.getElementById("myPasswordInput").value = userPWHash2;
      //    userprivkey=userPWHash2;
      //    for(var i=1; i<50000; i++) {
      //      userprivkey=Crypto.SHA256(userprivkey);
      //    }
      //    userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
      //    userpubkey = cryptico.publicKeyString(userprivkey);
      //  }
      //}
      const gasSetting2 = localStorage.getItem(myaccounts + DDEaddy + ":gasOption");
        if(gasSetting2 && gasSetting2 == "1") {
        gasSetting = 1;
      }
      const currentBlockNumber = await web3.eth.getBlockNumber();
      const currentBlock = await web3.eth.getBlock(currentBlockNumber);
      CurrentTimeStamp = DOMPurify.sanitize(currentBlock.timestamp);
      DDEcontract = new web3.eth.Contract(DDEabi, DDEaddy);
      balances = {};
      var btext = [];
      await window.web3.eth.getBalance(myaccounts, function(err, result1) {
        if (err) {
          console.log(err);
          return;
        } else {
          baseBalance = DOMPurify.sanitize(result1);//window.web3.utils.fromWei(result1, "ether");
          // document.getElementById("account").innerHTML = "<bdo>" + DOMPurify.sanitize(translateThis("Current Network:") + "</bdo> " + netname + "<br>" + myaccounts + "<br>" + netname2 + " <bdo>" + translateThis("wallet balance:") + "</bdo> " + window.web3.utils.fromWei(baseBalance, "ether") + btext);
          balances['base'] = {token: "base", decimals: 18, amount: baseBalance};
        }
      });
      for (var i = 0; i < tokens.length; i++) {
          await DDEcontract.methods.userBalance(myaccounts,tokens[i].address).call().then(function (liquid1) {
            balances[tokens[i].address]=({token:tokens[i].token, decimals: tokens[i].decimals, amount: DOMPurify.sanitize(liquid1), amount2: "0", total: web3.utils.toBN(DOMPurify.sanitize(liquid1))});
          });
          if(accountprivkey != "") {
            if(tokens[i].token == tokens[0].token) {
              //balances[tokens[i].address].total=balances[tokens[i].address].total.add(web3.utils.toBN(baseBalance));
            } else {
              var tokenContract = new web3.eth.Contract(ERC20abi, tokens[i].address);
              var base2 = DOMPurify.sanitize(await tokenContract.methods.balanceOf(myaccounts).call());
              //balances[tokens[i].address].total=balances[tokens[i].address].total.add(web3.utils.toBN(base2));                
              balances[tokens[i].address].amount2 = base2;
              btext+="<br>"+balances[tokens[i].address].token+" <bdo>"+translateThis("wallet balance:")+"</bdo> "+displayDecimals(tokens[i].address, balances[tokens[i].address].amount2.toString());
            }
          }
          btext+="<br>"+balances[tokens[i].address].token+" <bdo>"+translateThis("balance deposited to markets:")+"</bdo> "+displayDecimals(tokens[i].address, balances[tokens[i].address].total.toString());
      }
      reputation = [0,0,0];
      reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(myaccounts).call())));
      if((parseInt(reputation[0]) + parseInt(reputation[1])) > 0) {
          btext+="<br><bdo>" + translateThis("Contracting success rate:") + "</bdo> " + (parseFloat(parseFloat(reputation[0]) / (parseFloat(reputation[0]) + parseFloat(reputation[1]))) * parseFloat(100)).toFixed(2) + "% (" + parseInt(reputation[0]) + "/" + (parseInt(reputation[0]) + parseInt(reputation[1])) + ")";
      }
      document.getElementById("account").innerHTML = "<bdo>" + DOMPurify.sanitize(translateThis("Current Network:") + "</bdo> " + netname + "<br>" + myaccounts + "<br>" + netname2 + " <bdo>" + translateThis("wallet balance:") + "</bdo> " + window.web3.utils.fromWei(baseBalance, "ether") + btext);
      try {
          var afee = DOMPurify.sanitize(await DDEcontract.methods.affiliateFee().call());
          var cfee = DOMPurify.sanitize(await DDEcontract.methods.customFee(myaccounts).call());
          var atext = "<bdo>" + translateThis("Base referral fee paid to affiliates:") + "</bdo> " + (afee / 100).toFixed(2) + "%";
          baseFee = afee;
          if(cfee != 0) {
            atext = "<bdo>" + translateThis("Custom referral fee paid to affiliates:") + "</bdo> " + (cfee / 100).toFixed(2) + "%";
          }
          if(reputation[2] >= 10) {
            atext += "<br><bdo>" + translateThis("You are an affiliate! You may market this system using your affiliate link.") + "</bdo>";
          } else {
            var cooldown = DOMPurify.sanitize(await DDEcontract.methods.cooldown(myaccounts).call());
                if(cooldown != 0 && (cooldown - CurrentTimeStamp) > 0) {
              atext += "<br><bdo>" + translateThis("Cooldown between next deal to qualify as an affiliate:") + "</bdo> " + ((parseFloat(cooldown) - parseFloat(CurrentTimeStamp)) / 60 / 60 / 24).toFixed(2) + translateThis("(days)");
            } else {
              var threshold = DOMPurify.sanitize(await DDEcontract.methods.minimumFeeThreshold(tokens[0].address).call());
              atext += "<br><bdo>" + translateThis("Minimum qualifying fee on next deal to become affiliate:") + "</bdo> " + displayDecimals(tokens[0].address, threshold);
            }
            atext += "<br><bdo>" + translateThis("Qualifying contracts remaining until you can become an affiliate:") + "</bdo> " + (10 - reputation[2]);
          }
          var referral2 = DOMPurify.sanitize(await DDEcontract.methods.referral(myaccounts).call());
          if(referral2 == "0x0000000000000000000000000000000000000000" && referral == "0x0000000000000000000000000000000000000000") {
            atext += "<br><bdo>" + translateThis("No affiliate assigned! It's recommended to assign one so the fee is not burned.") + "</bdo>";
          }
          if(referral2 != "0x0000000000000000000000000000000000000000") {
            atext += "<br><bdo>" + translateThis("Current affiliate assigned to account:") + "</bdo> " + referral2;
          }
          if(referral != "0x0000000000000000000000000000000000000000") {
            var arep = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(referral).call())));
            if(arep[2]>=10) {
              atext += "<br><bdo>" + translateThis("Future affiliate assigned on next contract:") + "</bdo> " + referral;
            } else {
              atext += "<br><bdo>" + translateThis("Linked affiliate is not valid because they have not completed 10 qualified deals yet:") + "</bdo> " + referral;
            }
          }
          if(parseInt(reputation[0]) + parseInt(reputation[1]) == 0) {
            atext +=  "<br><br><bdo>" + translateThis("You are new to the markets! Welcome to BitBay.") + "</bdo>";
          } else {
            atext += "<br><br><bdo>" + translateThis("Contracting success rate:") + "</bdo> " + (parseFloat(parseFloat(reputation[0]) / (parseFloat(reputation[0]) + parseFloat(reputation[1]))) * parseFloat(100)).toFixed(2) + "%(" + parseInt(reputation[0]) + "/" + (parseInt(reputation[0]) + parseInt(reputation[1])) + ")";
          }
          document.getElementById("affiliateInfo").innerHTML = atext;
      } catch(e) {
          console.log(e);
      }
      var contact2 = '';
      var datalen = 0;
      var shortPublicKey = '';
      var datatext = '';
      try {
        datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 3).call());
        if(datalen > 0) {
          contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(myaccounts, datalen-1).call()));
          if("mycontact" in contact2) {
            datatext += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
          }
          if("publickey" in contact2) {
            if(datatext != '') {
              datatext += '<br>';
            }
            shortPublicKey = contact2['publickey'].substring(0, 10) + '...<bdo><span id="showMore" style="color:blue">' + translateThis('(show more)') + '</span></bdo>';
            datatext += "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + shortPublicKey;
            document.getElementById('publicemail').innerHTML = datatext;
            document.getElementById('showMore').addEventListener('click', function() {
              var datatext2 = '';
              if("mycontact" in contact2) {
                datatext2 += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
                datatext2 += '<br>';
              }
              document.getElementById('publicemail').innerHTML = datatext2 + "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + contact2['publickey'];
            });
          } else {
            document.getElementById('publicemail').innerHTML = datatext;
          }
        } else {
          document.getElementById('publicemail').innerHTML = "";
        }
      } catch(e) {
        console.log(e);
      }
      if(shortPublicKey == '' && userpubkey != '') {
        shortPublicKey = userpubkey.substring(0, 10) + '...<bdo><span id="showMore">' + translateThis('(show more)') + '</span></bdo>';
        datatext += "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + shortPublicKey;
        document.getElementById('publicemail').innerHTML = datatext;
        document.getElementById('showMore').addEventListener('click', function() {
          var datatext2 = '';
          try {
            if("mycontact" in contact2) {
              datatext2 += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
              datatext2 += '<br>';
            }
          } catch {
          }
          document.getElementById('publicemail').innerHTML = datatext2 + "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + userpubkey;
        });
      }
      if(login == 1) {
        await getUserAPI(currentChainId);        
        await waitLock();
        document.getElementById("loadingStatus").innerHTML = loader;
        currentViewContext = '';
        marketOffers = {'indices':[], 'results':[]};
        locked = true;
        await loadMarkets(0, maxContextLoad[0]);
        locked = false;
        document.getElementById("loadingStatus").innerHTML = '';
      } else {
        await checkMarketUpdate();
      }
      // await updateNotifications();
      await populateOffers();
    }

    async function loadDefaultMarkets() {      
      await waitLock();
      document.getElementById("loadingStatus").innerHTML = loader;
      currentViewContext = '';
      locked = true;
      await loadMarkets(0, maxContextLoad[0]);
      locked = false;
      document.getElementById("loadingStatus").innerHTML = '';
    }

    var breakThis = false;
    async function waitLock(breakLoad = true) {
      waited = 0;
      while(locked) {
        if(waited == 20) {
          break;
        }
        if(breakLoad) {
          breakThis = true;
        }
        await sleep(1000);
        waited += 1;
      }
      breakThis = false;
    }

    async function showError(error) {
      if (error.message.includes("specified gasPrice but also included maxFeePerGas")) {
        await Swal.fire(translateThis("Web3 gas assignment failed. Will change to blockchain recommended gas options."));
        gasSetting = 1;
        localStorage.setItem(myaccounts + DDEaddy + ":gasOption", "1");
      } else if (error.message.includes("DDEcontract.methods is undefined")) {
        await Swal.fire(translateThis("Not connected."));
      }
      else {
        await Swal.fire({title: translateThis("Error sending transaction"), text: error.message, icon: 'error', confirmButtonText: translateThis('OK')});
      }
    }

    function checkFavorites() {
      if(myFavorites.length > 0) {
        document.getElementById("star-symbol").style.color = "#ed5f00";
      } else {
        document.getElementById("star-symbol").style.color = "";
      }
    }

    document.getElementById('favorites-button').addEventListener('mouseover', function() {
      document.getElementById('favorites-text').innerHTML = translateThis('Favorites');
      document.getElementById('favorites-text').style.color = '#322C62';
    });

    document.getElementById('favorites-button').addEventListener('mouseout', function() {
      document.getElementById('favorites-text').innerHTML = '';
      document.getElementById('favorites-text').style.color = '';
    });

    myContactInfo.addEventListener('blur', async function(event) {
      await saveContactInfo(document.getElementById("myContactInfo").value);
    });

    function backupLocalStorage() {
      const localStorageData = JSON.stringify(localStorage);
      const blob = new Blob([localStorageData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = window.prompt(translateThis('Choose a file name for the backup:'), 'localStorageBackup.json');
      anchor.click();
      URL.revokeObjectURL(url);
    }

    function loadLocalStorage() {
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const fileData = JSON.parse(event.target.result);
          Object.keys(fileData).forEach(function(key) {
            localStorage.setItem(key, fileData[key]);
          });
          console.log('Local storage data overwritten with data from file.');
        } catch (error) {
          console.error('Error parsing file data:', error);
        }
      };
      reader.onerror = function(event) {
        console.error('Error loading file:', event.target.error);
      };
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = function(event) {
        const file = event.target.files[0];
        reader.readAsText(file);
      };
      // Trigger a click event on the input element to prompt the user to select a file
      input.click();
    }

    async function RefreshContracts() {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + DDEaddy + ":readmessages3", JSON.stringify({}));
        // await updateNotifications();
        await populateOffers();
      }
    }

    async function saveContactInfo(text) {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + DDEaddy + ":contact", text);
      }
    }

    async function getContactInfo(account) {
      const cached = localStorage.getItem(account + DDEaddy + ":contact");
      if (cached) {
        return cached;
      } else {
        return '';
      }
    }

    const selectAPI = document.getElementById('connectMethod');

    selectAPI.addEventListener('blur', async function(event) {
      await saveAPI();
    });

    async function saveAPI() {
      const myCurrentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
      localStorage.setItem(myaccounts + DDEaddy + myCurrentChainId + ":api", document.getElementById('connectMethod').value);
      await getUserAPI(myCurrentChainId);
    }

    async function getUserAPI(mychainid) {
      mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 4).call());
      const mySelectElement = document.getElementById('connectMethod');

      mySelectElement.innerHTML = '';
      const option1 = document.createElement('option');
      option1.value = 'a';
      option1.text = translateThis('Use default IPFS Pinata Gateway');
      mySelectElement.add(option1);

      // Add additional elements with values based on the size of mylen
      for (let i = 0; i < mylen; i++) {
        const option = document.createElement('option');
        option.value = i.toString();
        option.text = translateThis("Use gateway") + `#${i}`;
        mySelectElement.add(option);
      }

      var selectedAPI = "0";
      const cached = localStorage.getItem(myaccounts + DDEaddy + mychainid + ":api");
      if (cached) {
        const index = Array.from(mySelectElement.options).findIndex(option => option.value === cached.toString());
        mySelectElement.selectedIndex = index;
        selectedAPI = cached.toString();
        if (selectedAPI == 'a') {
          selectedAPI = "0";
        }
      }
      await getAPI(selectedAPI);
    }

    offerExpiration.addEventListener('change', async function(event) {
      await saveExpirationInfo(document.getElementById("offerExpiration").value);
    });

    async function saveExpirationInfo(text) {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + DDEaddy + ":expiration", text);
      }
    }

    async function getExpirationInfo(account) {
      const cached = localStorage.getItem(account + DDEaddy + ":expiration");
      if (cached) {
        return cached;
      } else {
        return '';
      }
    }

    var autoClearCheckbox = document.getElementById("clearCompleted");

    autoClearCheckbox.addEventListener("change", () => {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + DDEaddy + ":autoclear", autoClearCheckbox.checked);
      }
    });

    function loadAutoClearState() {
      const autoClearState = localStorage.getItem(myaccounts + DDEaddy + ":autoclear");
      if (autoClearState === "true") {
        autoClearCheckbox.checked = true;
      } else {
        autoClearCheckbox.checked = false;
      }
    }

    var emailClient = document.getElementById("emailClient");

    emailClient.addEventListener("change", () => {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + DDEaddy + ":emailclient", emailClient.checked);
      }
    });

    function loadEmailClientState() {
      const emailState = localStorage.getItem(myaccounts + DDEaddy + ":emailclient");
      if (emailState === "true") {
        emailClient.checked = true;
      } else {
        emailClient.checked = false;
      }
    }

    document.getElementById("myPasswordInput").addEventListener('blur', async function () {
      const passwordValue = document.getElementById("myPasswordInput").value;
      if(myaccounts != '') {
        if (passwordValue.includes(' ') || passwordValue.length < 10) {
          await Swal.fire(translateThis('Password must not contain spaces and must be at least 10 characters long'));
          document.getElementById("myPasswordInput").value = '';
          return;
        }
        await Swal.fire({
          title: translateThis('Confirm Password'),
          input: 'password',
          inputPlaceholder: translateThis('Enter your password again'),
          showCancelButton: true,
          confirmButtonText: translateThis('Set Password'),
          cancelButtonText: translateThis('Cancel'),
          preConfirm: async (confirmedPassword) => {
            // Compare the entered password with the original password
            if (confirmedPassword === passwordValue || Crypto.SHA256(confirmedPassword) === passwordValue) {
              // Passwords match, proceed to set in localStorage
              var hashedPassword = confirmedPassword;
              hashedPassword = Crypto.SHA256(hashedPassword);
              userprivkey=hashedPassword;
              showLoader();
              for(var i=1; i<50000; i++) {
                userprivkey=Crypto.SHA256(userprivkey);
              }
              userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
              userpubkey = cryptico.publicKeyString(userprivkey);
              document.getElementById("myPasswordInput").value = hashedPassword;
              localStorage.setItem(myaccounts + ':password', Crypto.SHA256(hashedPassword+"1"));
              console.log('Password saved in localStorage:', Crypto.SHA256(hashedPassword+"1"));
              hideLoader();
              await Swal.fire({
                title: translateThis('Register Public Key'),
                text: translateThis('Would you like to register this public key to your account now? This is how users will know how to encrypt their offers to you.'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then(async (result) => {
                if (result.isConfirmed) {
                  await registerData();
                }
              });
              await Swal.fire({
                title: translateThis('Remember Password'),
                text: translateThis('Would you like your device to remember this password? It is convenient to remember it however it is more secure to type it every time you log in.'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then(async (result) => {
                if (result.isConfirmed) {
                  localStorage.setItem(myaccounts + ':savedpw', hashedPassword);
                }
              });
            } else {
              await Swal.fire(translateThis('Passwords do not match'));
              document.getElementById("myPasswordInput").value = '';
            }
          }
        });
      } else {
        document.getElementById("myPasswordInput").value = '';
      }
    });

    async function getUserPassword() {
      const userPWHash = localStorage.getItem(myaccounts + ":password");
      const passwordValue = document.getElementById("myPasswordInput").value;
      if(userPWHash != Crypto.SHA256(passwordValue+"1") && userPWHash != Crypto.SHA256(Crypto.SHA256(passwordValue)+"1")) {
        await Swal.fire({
          title: translateThis('Confirm Password'),
          input: 'password',
          inputPlaceholder: translateThis('Please enter your password'),
          showCancelButton: true,
          confirmButtonText: translateThis('Confirm Password'),
          cancelButtonText: translateThis('Cancel'),
          preConfirm: async (confirmedPassword) => {
            // Compare the entered password with the original password
            if (Crypto.SHA256(Crypto.SHA256(confirmedPassword)+"1") === userPWHash) {
              // Passwords match, proceed to set in localStorage
              var hashedPassword = confirmedPassword;
              hashedPassword = Crypto.SHA256(hashedPassword);
              userprivkey=hashedPassword;
              showLoader();
              for(var i=1; i<50000; i++) {
                userprivkey=Crypto.SHA256(userprivkey);
              }
              document.getElementById("myPasswordInput").value = hashedPassword;
              userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
              userpubkey = cryptico.publicKeyString(userprivkey);
              hideLoader();
            } else {
              await Swal.fire({
                title: translateThis('Passwords do not match'),
                text: translateThis('Please also note that you will not be able to see details on any of your previous encrypted offers until the correct password is entered. Therefore, we do not recommend changing passwords. If you do, the public key registered to your account should also be updated. Please enter the password again on the account page.'),
                icon: 'error',
                customClass: {
                  popup: 'custom-font-size'
                },
                didOpen: () => {
                  // Style adjustments using JavaScript
                  const popup = document.querySelector('.swal2-popup.custom-font-size');
                  if (popup) {
                    popup.style.fontSize = '14px'; // Adjust the font size as needed
                  }
                }
              });
              document.getElementById("myPasswordInput").value = '';
            }
          }
        });
      }
    }

    async function modifyCustodian() {
      const dataLength = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 3).call());
      let custodians = [];
      let custodianOptions = {};

      for (let index = 0; index < dataLength; index++) {
        const custodianAddress = DOMPurify.sanitize(await DDEcontract.methods.custodianList(myaccounts, index).call());
        const isActive = DOMPurify.sanitize(await DDEcontract.methods.isCustodian(myaccounts, custodianAddress).call());
        if (isActive) {
          custodians.push(custodianAddress);
          custodianOptions[custodianAddress] = custodianAddress;
        }
      }

      if (custodians.length === 0) {
        await Swal.fire(translateThis("No active custodians to remove."));
        return;
      }

      await Swal.fire({
        title: translateThis('Remove Cosigners/Custodians'),
        text: translateThis('Remove a cosigner/custodian.'),
        input: 'select',
        inputOptions: custodianOptions,
        inputPlaceholder: translateThis('Select a cosigner to remove'),
        showCancelButton: true,
        confirmButtonText: translateThis('Remove'),
        cancelButtonText: translateThis('Cancel'),
        preConfirm: (selectedAddress) => {
          if (!selectedAddress) {
            Swal.showValidationMessage(translateThis("You need to select a cosigner."));
          }
        }
      }).then(async (result) => {
        if (result.isConfirmed) {
          try {
            setActionActive(myaccounts+"removeCosigner"+result.value, true);
            if (accountprivkey !== "") {
              const gasEstimate = 130000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if (!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.authorizeCustodian(result.value, false).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            Swal.fire(translateThis("Cosigner removal successful."));
          } catch (e) {
            console.log(e);
            hideLoader();
            await showError(e);
          } finally {
            setActionActive(myaccounts+"removeCosigner"+result.value, false);
          }
        }
      });
    }

    async function setCustodian() {
      await Swal.fire({
        title: translateThis('Set Cosigner/Custodian'),
        text: translateThis('Having a cosigner is useful in case you are unable to complete your deals. This should be someone you trust completely. They will only be given authorization to sign on your behalf to confirm or complete contracts so the contracts do not get held up in escrow. Please enter the custodians address below.'),
        input: 'text',
        showCancelButton: true,
        confirmButtonText: translateThis('Submit'),
        cancelButtonText: translateThis('Cancel'),
        inputValidator: (value) => {
          if (!value) {
            return 'You need to enter something!';
          }
        },
      }).then(async (result) => {
        if (result.isConfirmed) {
          if (!web3.utils.isAddress(result.value)) {
            Swal.fire(translateThis("Address was not valid."));
            return;
          }
          try {
            setActionActive(myaccounts+"addCosigner"+result.value, true);
            if(accountprivkey != "") {
              const gasEstimate = 130000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.authorizeCustodian(result.value, true, false).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            Swal.fire(translateThis("Cosigner designation successful. Now you will be asked to authorize the cosigner for contract clearance."));
          } catch (e) {
            console.log(e);
            hideLoader();
            await showError(e);
            return;
          } finally {
            setActionActive(myaccounts+"addCosigner"+result.value, false);
          }
          try {
            setActionActive(myaccounts+"addCosigner"+result.value, true);
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.authorizeContract(result.value, "0x", true).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            Swal.fire(translateThis("Success!"));
          } catch (e) {
            console.log(e);
            hideLoader();
            await showError(e);
            return;
          } finally {
            setActionActive(myaccounts+"addCosigner"+result.value, false);
          }
        }
      });
    }

    async function cosign() {
      var swalOptions = {};
      var swalOptions2 = {};
      var y = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 5).call());
      var tot = 0;
      for(let x = 0; x < y; x++) {
        try {
          var coaddy = DOMPurify.sanitize(await DDEcontract.methods.custodianList2(myaccounts, x).call());
          var active = DOMPurify.sanitize(await DDEcontract.methods.isCustodian(coaddy, myaccounts).call());
          if(active) {
            swalOptions[coaddy] = coaddy;
            tot+=1;
          }
        } catch (e) {
          console.log(e);
          await(showError(e));
          return;
        }
      }
      if(tot == 0) {
        await Swal.fire("You are currently not a cosigner for any active user");
        return;
      }
      await Swal.fire({
        title: translateThis('Select address to cosign for:'),
        input: 'select',
        inputOptions: swalOptions,
        showCancelButton: true,
        confirmButtonText: translateThis('Confirm'),
        cancelButtonText: translateThis('Cancel'),
      }).then(async (result) => {
        if (result.isConfirmed) {
          const addy = result.value;
          var contracts = {};
          var readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + addy + ":escrows")) || {};
          try {
            var y = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(addy, 2).call());
            var auth = DOMPurify.sanitize(await DDEcontract.methods.isAuthorized(addy, myaccounts, "0x").call());
          } catch (e) {
            console.log(e);
            await(showError(e));
            return;
          }
          for(let x = 0; x < y; x++) {
            try {
              if(x in readMessages) {
                continue;
              }
              var hash = DOMPurify.sanitize(await DDEcontract.methods.escrows(addy, x).call());
              var jsondata = await getOrderHash(hash);
              if(parseInt(jsondata.status[0]) < 4 && parseInt(jsondata.status[1]) < 4) {
                if(!auth) {
                  var auth2 = DOMPurify.sanitize(await DDEcontract.methods.isAuthorized(addy, myaccounts, hash).call());
                  if(!auth2) {
                    continue;
                  }
                }
                const currentBlockNumber = await web3.eth.getBlockNumber();
                const currentBlock = await web3.eth.getBlock(currentBlockNumber);
                const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
                const timeRemaining = (parseFloat(parseInt(jsondata.timelimit[0]) - parseInt(blockTimestamp)) / parseFloat(60 * 60 * 24)).toFixed(2);
                jsondata.timeRemaining = timeRemaining;
                var escrowInfo = '';
                if (jsondata.status[0] != 4 && jsondata.status[1] != 4) {
                  if(parseFloat(timeRemaining) < parseFloat(2)) {
                    escrowInfo += "<div>" + translateThis('WARNING: Funds are about to expire. Resolve the escrow with your counter-party or all funds risk being burned.') + "</div>";
                  }
                  if(parseFloat(timeRemaining) <= parseFloat(0)) {
                    escrowInfo += "<div>" + translateThis("The time limit has expired and the funds have been burned. This contract is no longer available.") + "</div>";
                    jsondata.expired = 2;
                  }
                }
                var skipthis = 0;
                if(jsondata.timelimit[0] == jsondata.timelimit[1] && jsondata.timelimit[1] == jsondata.timelimit[2]) {
                  skipthis = 1;
                }
                if(jsondata.timelimit[1] != 0 && skipthis != 1) {            
                  const timeExtension = Math.abs(parseFloat(parseInt(jsondata.timelimit[1]) - parseInt(jsondata.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
                  escrowInfo += "<div>" + translateThis("Sender has requested a time extension for: ") + timeExtension + " " + translateThis("days") + "</div>";
                }
                if(jsondata.timelimit[2] != 0 && skipthis != 1) {            
                  const timeExtension2 = Math.abs(parseFloat(parseInt(jsondata.timelimit[2]) - parseInt(jsondata.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
                  escrowInfo += "<div>" + translateThis("Recipient has requested a time extension for: ") + timeExtension2 + " " + translateThis("days") + "</div>";
                }
                if (skipthis == 1) {
                  escrowInfo += "<div>" + translateThis("Time extension granted.") + "</div>";
                }
                if (jsondata.status[0] == 2) {
                  if(addy == jsondata.sender) {
                    escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
                  } else {
                    escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
                  }
                }
                if (jsondata.status[0] == 3) {
                  if(addy == jsondata.sender) {
                    escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
                  } else {
                    escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
                  }
                }
                if (jsondata.status[1] == 2) {
                  if(addy == jsondata.sender) {
                    escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
                  } else {
                    escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
                  }
                }
                if (jsondata.status[1] == 3) {
                  if(addy == jsondata.sender) {
                    escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
                  } else {
                    escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
                  }
                }
                if (jsondata.status[0] == 4 || jsondata.status[1] == 4) {
                  if(jsondata.status[0] == 4) {
                    escrowInfo += "<div>" + translateThis("Contract completed!") + "</div>";;
                  }
                  if(jsondata.status[1] == 4) {
                    escrowInfo += "<div>" + translateThis("Contract cancelled!") + "</div>";;
                  }
                  jsondata.expired = 1;
                }
                jsondata.escrowInfo = escrowInfo;
                jsondata.index = x;
                jsondata.originalUser = addy;
                contracts[hash] = JSON.parse(JSON.stringify(jsondata));
                swalOptions2[hash] = hash;
              } else {
                readMessages[x] = true;
              }
            } catch (e) {
              console.log(e);
              await(showError(e));
              return;
            }
          }
          localStorage.setItem(myaccounts + DDEaddy + addy + ":escrows", JSON.stringify(readMessages));
          await Swal.fire({
            title: translateThis('Select contract:'),
            input: 'select',
            inputOptions: swalOptions2,
            showCancelButton: true,
            confirmButtonText: translateThis('Confirm'),
            cancelButtonText: translateThis('Cancel'),
          }).then((result) => {
            if (result.isConfirmed) {
              showListing(contracts[result.value],4);
            }
          });
        }
      });
    }

    async function registerData(contactInfo) {
      myemail = contactInfo || document.getElementById('myContactInfo').value;
      const { value: formValues } = await Swal.fire({
        title: '',
        html:
          '<input id="checkbox1" type="checkbox" name="registerEmail"> ' +
          '<label for="checkbox1">' + translateThis('Register email/contact information') + '</label><br>' +
          '<input id="checkbox2" type="checkbox" name="registerPublicKey"> ' +
          '<label for="checkbox2">' + translateThis('Register public key for privacy/encryption') + '</label>',
        focusConfirm: false,
        showCancelButton: true,
        preConfirm: () => {
          return {
            registerEmail: document.getElementById('checkbox1').checked,
            registerPublicKey: document.getElementById('checkbox2').checked
          };
        }
      });
      var myuserdata = {};
      // Output the selected values
      if (formValues) {
        if(formValues.registerEmail) {
          myuserdata.mycontact = myemail
        }
        if(formValues.registerPublicKey) {
          myuserdata.publickey = userpubkey;
          if(myuserdata.publickey == "") {
            Swal.fire(translateThis("Public key unknown."));
            return;
          }
        }
      }
      if(Object.keys(myuserdata).length === 0) {
        return;
      }
      if('mycontact' in myuserdata && myuserdata.mycontact == "") {
        await Swal.fire(translateThis("Email is blank, try again"));
        return;
      }
      try {
        setActionActive(myaccounts+"register"+JSON.stringify(myuserdata), true);
        if(accountprivkey != "") {
            const gasEstimate = 150000;
            var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
            if(!res) {
              return;
            }
          }
        showLoader();
        await DDEcontract.methods.adduserdata(JSON.stringify(myuserdata)).send({ "from": myaccounts, ...gasOptions[gasSetting] });
        hideLoader();
        await Swal.fire(translateThis("Data added!"));
      } catch (error) {
        console.error(error);
        hideLoader();
        await showError(error);
      } finally {
        setActionActive(myaccounts+"register"+JSON.stringify(myuserdata), false);
      }
    }

    async function copyAffiliateLink() {
      var currentUrl = window.location.href;
      if(currentUrl.includes('?')) {
        currentUrl = currentUrl.split('?')[0];
      }
      const urlWithSlash = currentUrl.endsWith('/') ? currentUrl : currentUrl + '/';
      const swalOptions = {};
      langOptions.forEach((lang) => {
        swalOptions[lang] = lang;
      });
      var arep = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(myaccounts).call())));
      if(arep[2]<10) {
        Swal.fire(translateThis("You have not completed 10 deals with the minimum threshold and requirements yet. Only then can you become an affiliate."));
        return;
      }
      // Ask the user to select a language
      await Swal.fire({
        title: translateThis('Select Language'),
        input: 'select',
        inputOptions: swalOptions,
        inputValue: 'English',
        inputPlaceholder: translateThis('Select a language'),
        showCancelButton: true,
        confirmButtonText: translateThis('Copy to Clipboard'),
        cancelButtonText: translateThis('Cancel'),
      }).then((result) => {
        if (result.isConfirmed) {
          const selectedLanguage = result.value.substring(0, 2).toLowerCase();
          const newUrl = `${urlWithSlash}?l=${selectedLanguage}&r=${myaccounts}`;
          // Create a text area for manual copying
          const textArea = document.createElement('textarea');
          textArea.value = newUrl;
          textArea.style.position = 'fixed'; // Make it invisible and fixed to avoid interference
          document.body.appendChild(textArea);
          textArea.select();
          try {
            // Attempt to execute the copy command
            document.execCommand('copy');

            // Show a success message
            Swal.fire({
              icon: 'success',
              title: translateThis('URL Copied'),
              text: translateThis('The modified URL has been copied to the clipboard.'),
            });
          } catch (err) {
            console.error('Copy command failed:', err);
            Swal.fire({
              icon: 'info',
              title: translateThis('Copy Manually'),
              text: translateThis('The modified URL is:') + '\n\n' + newUrl + '\n\n' + translateThis('Please copy it manually.'),
            });
          } finally {
            // Clean up: remove the temporary text area
            document.body.removeChild(textArea);
          }
        }
      });
    }
    async function changeAffiliate() {
      await Swal.fire({
        title: translateThis('Please enter preferred affiliate'),
        input: 'text',
        showCancelButton: true,
        confirmButtonText: translateThis('Submit'),
        cancelButtonText: translateThis('Cancel'),
        inputValidator: (value) => {
          if (!value) {
            return 'You need to enter something!';
          }
        },
      }).then(async (result) => {
        if (result.isConfirmed) {
          const affiliate = result.value;
          if (!web3.utils.isAddress(affiliate)) {
            Swal.fire(translateThis("Address was not valid."));
            return;
          }
          var reputation = [0,0,0];
          reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(affiliate).call())));
          if(reputation[2] >= 10) {
            try {
              setActionActive(myaccounts+"changeAffiliate"+affiliate, true);
              if(accountprivkey != "") {
                const gasEstimate = 50000;
                var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                if(!res) {
                  return;
                }
              }
              showLoader();
              await DDEcontract.methods.changeAffiliate(affiliate).send({ "from": myaccounts, ...gasOptions[gasSetting] });
              hideLoader();
              Swal.fire(translateThis("Success!"));
              referral = affiliate;
            } catch (e) {
              console.log(e);
              hideLoader();
              await showError(e);
              return;
            } finally {
              setActionActive(myaccounts+"changeAffiliate"+affiliate, false);
            }
          } else {
            Swal.fire(translateThis("This person has not completed enough qualified deals yet."));
          }
        }
      });
    }
    async function setCustomFee() {
      await Swal.fire({
        title: translateThis('Set base affiliate fee'),
        text: translateThis('Please enter the percentage fee that you wish to offer to affiliates who help find customers for you.'),
        input: 'range',
        inputAttributes: {
          min: (baseFee / 100).toFixed(1),
          max: 50,
          step: 0.1,
          value: 0 // Set the initial value as needed
        },
        inputValue: (baseFee / 100).toFixed(1), // Set the initial value as needed
        showCancelButton: true,
        inputLabel: 'Percentage',
        preConfirm: (value) => {
        }
      }).then(async (result) => {
        if (result.isConfirmed) {
          var value = parseInt(result.value) * parseInt(100);
          try {
            setActionActive(myaccounts+"changeFee"+value, true);
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.changeCustomFee(value).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            Swal.fire(translateThis("Success!"));
          } catch (e) {
            console.log(e);
            hideLoader();
            await showError(e);
          } finally {
            setActionActive(myaccounts+"changeFee"+value, false);
          }
        }
      });
    }

    async function postOfferData(text) {
      // Hash the text using web3 keccak
      const hash = web3.utils.keccak256(text);

      // Check if the hash is already stored in localStorage
      const cached = await getFile(hash);
      if (!Array.isArray(cached)) {
        return JSON.parse(cached).ipfsHash;
      }

      // If not, pin the text to Pinata IPFS and get the IPFS hash
      const ipfsHash = await pinToPinataIPFS(text);
      console.log("Offer posted to IPFS");
      console.log(ipfsHash);
      if(ipfsHash == "error") {
        return "error";
      }

      // Store the hashed text and IPFS hash in localStorage
      const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
      await storeFile(hash, data);
      await storeFile(ipfsHash, hash);

      return ipfsHash;
    }

    async function getOfferData(hash) {
      // Check if the hash is an IPFS hash or a text hash
      let ipfsHash = hash;
      var cached = '';
      var text = '';
      if (hash.length !== 46) { // IPFS hashes are 46 characters long
        // Look up the hash in localStorage
        cached = await getFile(hash);
        if (!Array.isArray(cached)) {
          text = JSON.parse(cached).text;
          return text;
        }
      } else {
        cached = await getFile(hash);
        if (!Array.isArray(cached)) {
          cached = await getFile(cached);
          if (!Array.isArray(cached)) {
            text = JSON.parse(cached).text;
            try {
              const mytest = JSON.parse(text);
              return text;
            } catch {
              console.log("Fetching data")
            }
          }
        }
      }
      // Get the text from Pinata IPFS using the IPFS hash
      text = await retrieveFromPinataIPFS(ipfsHash);
        if(text == "error") {
        text = await retrieveFromIPFS(ipfsHash);
            if(text == "error") {
          return "error";
        }
      }

      // Hash the text using web3 keccak and check if it matches the stored text hash
      hash = web3.utils.keccak256(text);
      // Store the hashed text and IPFS hash in localStorage
      const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
      await storeFile(hash, data);
      await storeFile(ipfsHash, hash);
      return text;
    }

    var pinataApiKey = '';
    var pinataSecretApiKey = '';
    var pinataGateway = 'https://azure-faithful-anteater-219.mypinata.cloud/ipfs/';
    var pinataToken = 'vgbqHzLAN_A5OI0suZED_RyzKacw5SfNjq25y45oB_CMVoOa1T4IfNrDJOkGysCP';
    // Function to post a file to Pinata IPFS
    async function pinToPinataIPFS (text) {
      const url = 'https://api.pinata.cloud/pinning/pinFILEToIPFS';

      const formData = new FormData();
      const blob = new Blob([text], { type: 'text/plain' });
      formData.append('file', blob, 'file.txt');
      try {
        const response = await axios.post(url, formData, {
          headers: {
            'Content-Type': `multipart/form-data; boundary=${formData._boundary}`,
            'pinata_api_key': pinataApiKey,
            'pinata_secret_api_key': pinataSecretApiKey
          }
        });
        // console.log(response.data.IpfsHash);
        return DOMPurify.sanitize(response.data.IpfsHash);
      } catch (error) {
        console.log(error);
        return 'error';
      }
    };

    var maxFileSize = (1024 * 1024) * 7;
    async function customFetch(url, maxSize, onProgress) {
      return new Promise((resolve, reject) => {
        let downloadedContent = ''; // Accumulate downloaded content
        fetch(url).then(response => {
          if (!response.ok) {
            reject(new Error(`Network response was not ok: ${response.statusText}`));
            return;
          }

          const reader = response.body.getReader();

          function read() {
            reader.read().then(({ done, value }) => {
              if (done) {
                resolve(downloadedContent);
                return;
              }

              // Check if the downloaded content exceeds the maxSize
              if (downloadedContent.length + value.length > maxSize) {
                reject(new Error('File size exceeds the maximum allowed size.'));
                return;
              }

              // Update downloaded content
              downloadedContent += new TextDecoder().decode(value);

              // Call the onProgress callback with the current progress
              onProgress(downloadedContent.length);

              // Continue reading the next chunk
              read();
            });
          }

          // Start reading the response stream
          read();
        }).catch(error => {
          reject(error);
        });
      });
    }

    // Function to retrieve a file from IPFS
    const retrieveFromIPFS = async (hash) => {
      var url = "https://ipfs.io/ipfs/"+hash;
      try {
        //const response = await fetch(url);
        const response = await customFetch(url, maxFileSize, progress => {
          //console.log(`Download progress: ${progress} bytes`);
          //Users may potentially be notified about download progress of files
        });
        //var result = await response.text();
        var result = DOMPurify.sanitize(response);
      } catch (error) {
        console.error(`Error during download: ${error.message}`);
        return "error";
      }
      return result;
    }
    const retrieveFromPinataIPFS = async (hash) => {
      var url = pinataGateway + hash;
      if(pinataGateway != "https://gateway.pinata.cloud/ipfs/") {
          if(pinataToken == '') {
          url = "https://gateway.pinata.cloud/ipfs/" + hash;
        } else {
          url += "?pinataGatewayToken=" + pinataToken;
        }
      }
      try {
        //const response = await fetch(url);
        const response = await customFetch(url, maxFileSize, progress => {
          //console.log(`Download progress: ${progress} bytes`);
          //Users may potentially be notified about download progress of files
        });
        //var result = await response.text();
        var result = DOMPurify.sanitize(response);
      } catch (error) {
        console.error(`Error during download: ${error.message}`);
        return "error";
      }
      return result;
    };

    async function checkMarketUpdate() {
      const timethis = 900000; // 15 minutes in milliseconds
      const lastTimestamp = localStorage.getItem('lastTimestamp');
      var marketsLength = 0;
      await DDEcontract.methods.marketslength().call().then(async function (result) {
        marketsLength = DOMPurify.sanitize(result);
      });
      const currentTimestamp2 = new Date().getTime();

      if (!lastTimestamp) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
      } else if (currentTimestamp2 - lastTimestamp >= timethis) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
        await loadDefaultMarkets();
        currentMarketsLength = marketsLength;
        return;
      }

      if (parseInt(currentMarketsLength) !== parseInt(marketsLength)) {
        await loadDefaultMarkets();
      }
    }
    function setAutoUpdate() {
      const currentTimestamp2 = new Date().getTime();
      localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
    }
    //Currently everything is loaded at once with a basic search. There is the option to post key words to the chain
    //although this could get expensive depending on the blockchain. Costs can be reduced by using a p2p search index.
    //Searches check different key words and then they can further check each listing for it's relevant key words.
    //When the markets get larger, searches can be randomized to vary what orders are shown.
    //AI such as WebGPT can be used for content filtration with settings tweaked by the user ideally. If the user doesn't have
    //the graphics card to moderate, they can call a list of volunteer services who run AI WebGPT to filter it(and maybe recommend tags)
    //for them based on their criteria. One way to enforce a search protocol is have those who post to markets do so from a separate contract.
    //This way they can also be the ones required to remove the search tags and the contract manages everything.
    var tempCurator = "0x25A2c592DDD5F930a9CB271b9AC3e72bbBc3d351";
    async function loadMarkets(low = 0, high = 1, searchText = '') {
        var DDEcontract3 = DDEcontract;
        if(DDEcontract == '') {
            DDEcontract3 = DDEcontract2;
        }
        var mlength = 0;
        await DDEcontract3.methods.marketslength().call().then(async function (result) {
            currentMarketsLength = DOMPurify.sanitize(result);
            mlength = parseInt(DOMPurify.sanitize(result));
        });
        var listlen = DOMPurify.sanitize(await DDEcontract3.methods.getArrayLength(tempCurator,3).call());
        var udata = {};
        if(listlen > 0) {
          var udata2 = JSON.parse(DOMPurify.sanitize(await DDEcontract3.methods.userdata(tempCurator, listlen-1).call()));
          if(typeof udata2 === 'object' && 'users' in udata2) {
            for(var uinx = 0; uinx < udata2['users'].length; uinx++) {
              udata[udata2['users'][uinx]] = 1;
            }
          }
        }
        setAutoUpdate();
        var index = low;
        var jsondata = {};
        var sortHits = 0;
        if(low == 0) {
          marketOffers['results'] = [];
        }
        if(showOrder == false) {
          var qpar = getQueryParam("o") || "default";
          if(qpar != "default") {
            searchText = "offer:" + qpar;
            document.getElementById('searchText').value = searchText;
          }
          showOrder = true;
        }
        if(document.getElementById('searchText').value.includes("offer:")) {
          searchText = document.getElementById('searchText').value;
        }
        contextIndex = index;
        if (searchText !== '') {
          if (Array.isArray(searchText)) { //Favorites
            var expiredOffers = [];
            var tot = 0;
            var mlen = searchText.length;
            for (var myinx = contextIndex; myinx < searchText.length; myinx++) {              
              if(tot == high || breakThis) {
                break;
              }
              try {
                const hash = searchText[myinx];
                const offerID = parseInt(DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call()));
                if (offerID == 0) {
                  expiredOffers.push(hash);
                  mlen -= 1;
                } else {
                  jsondata = await getOrderHash(hash);
                  if(udata.hasOwnProperty(jsondata.sender) || udata.hasOwnProperty(jsondata.recipient)) {
                    mlen -= 1;
                    continue;
                  }
                  if(parseInt(jsondata.timelimit[1]) != 0) {
                    if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                      if(!marketOffers.hasOwnProperty(offerID)) {
                        marketOffers.indices.push(offerID);
                      }
                      marketOffers[offerID] = hash;
                      marketOffers[hash] = jsondata;
                      contextIndex = myinx + 1;
                      if(!marketOffers['results'].includes(hash)) {
                        tot+=1;
                        marketOffers.results.push(hash);                        
                      }
                    } else {
                      expiredOffers.push(hash);
                      mlen -= 1;
                    }
                  } else {
                    if(!marketOffers.hasOwnProperty(offerID)) {
                      marketOffers.indices.push(offerID);
                    }
                    marketOffers[offerID] = hash;
                    marketOffers[hash] = jsondata;
                    contextIndex = myinx + 1;
                    if(!marketOffers['results'].includes(hash)) {
                      tot+=1;
                      marketOffers.results.push(hash);                      
                    }
                  }
                }
                updatePaginationControls(marketOffers.results.length, mlen);
                await populateListings("", 2);
              } catch (e) {
                  console.log("Error loading offer: ",e);
              }
            }
            contextIndex = myinx;
            if(expiredOffers.length > 0) {
              for (var myinx = 0; myinx < expiredOffers.length; myinx++) {
                contextIndex -= 1;
                myFavorites.splice(myFavorites.indexOf(expiredOffers[myinx]),1);
              }
              localStorage.setItem(myaccounts + DDEaddy + ':myFavorites', JSON.stringify(myFavorites));
            }
            updatePaginationControls(marketOffers.results.length, mlen);
            await populateListings("", 2);
            return;
          } else if(searchText.includes("userStore:")){
            var expiredOffers = [];
            const userAddress = searchText.split("userStore:")[1].trim();
            var added = 0;
            try {
              var mylen = 0;
              if(!web3.utils.isAddress(userAddress)) {
              } else {
                mylen = DOMPurify.sanitize(await DDEcontract3.methods.getArrayLength(userAddress, 0).call());
                var cached = localStorage.getItem(userAddress + DDEaddy + ":userStoreCache");
                if (cached) {
                  expiredOffers = JSON.parse(cached);
                }
              }
              var tot = 0;
              var truetot = mylen;
              for (var myinx = contextIndex; myinx < mylen; myinx++) {
                if(tot == high || breakThis) {
                  break;
                }
                if(expiredOffers.includes(myinx)) {
                  truetot -= 1;
                  continue;
                }                
                try {
                  const hash = DOMPurify.sanitize(await DDEcontract3.methods.openOffers(userAddress, myinx).call());
                  const offerID = parseInt(DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call()));
                  if (offerID == 0) {
                    truetot -= 1;
                    expiredOffers.push(myinx);
                    added = 1;
                  } else {
                    jsondata = await getOrderHash(hash);
                    if(udata.hasOwnProperty(jsondata.sender) || udata.hasOwnProperty(jsondata.recipient)) {
                      truetot -= 1;
                      continue;
                    }
                    if(parseInt(jsondata.timelimit[1]) != 0) {
                      if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                        if(!marketOffers.hasOwnProperty(offerID)) {
                          marketOffers.indices.push(offerID);
                        }
                        marketOffers[offerID] = hash;
                        marketOffers[hash] = jsondata;
                        contextIndex = myinx + 1;
                        if(!marketOffers['results'].includes(hash)) {
                          tot++;                          
                          marketOffers.results.push(hash);                          
                        }
                      } else {
                        truetot -= 1;
                        expiredOffers.push(myinx);
                        added = 1;
                      }
                    } else {
                        if(!marketOffers.hasOwnProperty(offerID)) {
                          marketOffers.indices.push(offerID);
                        }
                        marketOffers[offerID] = hash;
                        marketOffers[hash] = jsondata;
                        contextIndex = myinx + 1;
                        if(!marketOffers['results'].includes(hash)) {
                          tot++;
                          marketOffers.results.push(hash);                          
                        }
                    }
                  }
                  updatePaginationControls(marketOffers.results.length, truetot);
                  await populateListings("", 2);
                } catch (e) {
                    console.log("Error loading offer: ",e);
                }
              }
              contextIndex = myinx;
              if(expiredOffers.length > 0 && added == 1) {
                localStorage.setItem(userAddress + DDEaddy + ':userStoreCache', JSON.stringify(expiredOffers));
              }
            } catch (e) {
              console.log("Error loading offer: ",e);
            }
            await populateListings("", 2);
            return;
          } else if(searchText.includes("offer:")){
            const hash = searchText.split("offer:")[1].trim();
            try {
              const offerID = parseInt(DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call()));
              if (offerID == 0) {
              } else {
                jsondata = await getOrderHash(hash);
                if(udata.hasOwnProperty(jsondata.sender) || udata.hasOwnProperty(jsondata.recipient)) {
                  throw new Error('a');
                }
                if(parseInt(jsondata.timelimit[1]) != 0) {
                  if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                    if(!marketOffers.hasOwnProperty(offerID)) {
                        marketOffers.indices.push(offerID);
                    }
                    marketOffers[offerID] = hash;
                    marketOffers[hash] = jsondata;
                    if(!marketOffers['results'].includes(hash)) {
                        marketOffers.results.push(hash);
                        updatePaginationControls(marketOffers.results.length);
                    }
                  }
                } else {
                  if(!marketOffers.hasOwnProperty(offerID)) {
                      marketOffers.indices.push(offerID);
                  }
                  marketOffers[offerID] = hash;
                  marketOffers[hash] = jsondata;
                  if(!marketOffers['results'].includes(hash)) {
                      marketOffers.results.push(hash);
                      updatePaginationControls(marketOffers.results.length);
                  }
                }
              }
            } catch (e) {
                console.log("Error loading offer: ",e);
            }
            await populateListings("", 2);
            return;
          } else {
            sortHits = 1;
            var longestKey = 0;
            const keywords = searchText.split(/[,\s]+/); // Split by commas and one or more whitespace characters
            if(low == 0) {
              contextIndex = new Array(keywords.length).fill(0);
              longestKey = 0;
            } else {
              longestKey = prevBatch;
            }
            var pos = 0;
            for (let k = 0; k < keywords.length; k++) {
              var keyword = keywords[k];
              // Perform operations on each keyword
              if (keyword.length === 0) {
                pos+=1;
                continue; // Skip further execution for empty keyword
              }
              let keywordIndex = 0; // Declare a separate index for each keyword iteration
              let keywordLength = 0;
              await DDEcontract3.methods.taglength(keyword.toLowerCase()).call().then(async function (result) {
                  keywordIndex = 0;
                  keywordLength = parseInt(DOMPurify.sanitize(result));
                  if(low == 0) {
                    longestKey += keywordLength;
                  }
                  var tot = 0;
                  for (keywordIndex = contextIndex[pos]; keywordIndex < keywordLength; keywordIndex++) {
                      if(tot == high) {
                        break;
                      }
                      try {
                          await DDEcontract3.methods.hashtag(keyword.toLowerCase(), keywordIndex).call().then(async function (hash) {
                              hash = DOMPurify.sanitize(hash);
                              if(hash == "0x0000000000000000000000000000000000000000000000000000000000000000") {
                                longestKey -= 1;
                                return;
                              }
                              const offerID = parseInt(DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call()));
                              if (offerID == 0) {
                                longestKey -= 1;
                                return;
                              }
                              if(hash in marketOffers) {
                                if(!('searchTerms' in marketOffers[hash])) {
                                  marketOffers[hash]['searchTerms'] = [];                                  
                                }
                                if(!marketOffers[hash]['searchTerms'].includes(keyword.toLowerCase())) {                                  
                                  marketOffers[hash]['searchTerms'].push(keyword.toLowerCase())
                                }
                                jsondata = marketOffers[hash];
                              } else {
                                jsondata = await getOrderHash(hash);
                                if(udata.hasOwnProperty(jsondata.sender) || udata.hasOwnProperty(jsondata.recipient)) {
                                  longestKey -= 1;
                                  return;
                                }
                                if(!marketOffers.hasOwnProperty(offerID)) {
                                  marketOffers.indices.push(offerID);
                                }
                                marketOffers[offerID] = hash;
                                if(parseInt(jsondata.timelimit[1]) != 0) {
                                  if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                                    marketOffers[hash] = jsondata;
                                  } else {
                                    longestKey -= 1;
                                    return;
                                  }
                                } else {
                                  marketOffers[hash] = jsondata;
                                }
                                if(!('searchTerms' in marketOffers[hash])) {
                                  marketOffers[hash]['searchTerms'] = [];
                                }
                                if(!marketOffers[hash]['searchTerms'].includes(keyword.toLowerCase())) {
                                  marketOffers[hash]['searchTerms'].push(keyword.toLowerCase())
                                }
                              }
                              if(!marketOffers['results'].includes(hash)) {                                
                                tot += 1;
                                marketOffers.results.push(hash);                                
                              } else {
                                longestKey -= 1;
                              }
                          });
                          updatePaginationControls(marketOffers.results.length, longestKey);
                          await populateListings("", 1);
                      } catch (e) {
                          console.log("Error loading offer: ",e);
                      }
                  }
                  contextIndex[pos] = keywordIndex;                    
              });
              pos+=1;
            };            
            if(marketOffers.results.length==0) {              
              await populateListings(searchText);
            } else {
              updatePaginationControls(marketOffers.results.length, longestKey);
              await populateListings("", 1);
            }
            return;
          }
        } else {
            var searchThis = [];
            var trueLength = mlength - 1;
            var tot = 0;
            for (index; index < mlength; index++) {
                if(index == 0) {
                  continue;
                }
                if(tot == high || breakThis) {
                  break;
                }
                searchThis = [];
                try {
                    await DDEcontract3.methods.markets(index).call().then(async function (hash) {
                        hash = DOMPurify.sanitize(hash);
                        jsondata = await getOrderHash(hash);
                        if(udata.hasOwnProperty(jsondata.sender) || udata.hasOwnProperty(jsondata.recipient)) {
                          trueLength -= 1;                          
                          return;
                        }
                        if(parseInt(jsondata.timelimit[1]) != 0) {
                            if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                              if(!marketOffers.hasOwnProperty(index)) {
                                  marketOffers.indices.push(index);
                              }
                              marketOffers[index] = hash;
                              if(hash in marketOffers) {
                                  searchThis = marketOffers[hash]['searchTerms'];
                              }
                              marketOffers[hash] = jsondata;
                              marketOffers[hash]['searchTerms'] = searchThis;
                            } else {
                              trueLength -= 1;                              
                              return;
                            }
                        } else {
                            if(!marketOffers.hasOwnProperty(index)) {
                                marketOffers.indices.push(index);
                            }
                            marketOffers[index] = hash;
                            if(hash in marketOffers) {
                                searchThis = marketOffers[hash]['searchTerms'];
                            }
                            marketOffers[hash] = jsondata;
                            marketOffers[hash]['searchTerms'] = searchThis;
                        }
                        if(!marketOffers['results'].includes(hash)) {
                            marketOffers.results.push(hash);
                            tot+=1;                            
                        }
                    });
                    updatePaginationControls(marketOffers.results.length, trueLength);
                    await populateListings();
                } catch (e) {
                    console.log("Error loading offer: ",e);
                }
            }
            contextIndex = index;
        }
        if(DDEcontract == '') {
            await populateListings("", sortHits);
        }
    }


    function sortByHits() {
      marketOffers['results'].sort((hashA, hashB) => {
        const hitsA = marketOffers[hashA]['searchTerms'].length;
        const hitsB = marketOffers[hashB]['searchTerms'].length;
        return hitsB - hitsA; // Sort in descending order based on the number of hits
      });
    }
    function sortByAmountHigh() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountB - amountA; // Sort in descending order based on the 'amount' key
      });
    }
    function sortByAmountLow() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountA - amountB; // Sort in ascending order based on the 'amount' key
      });
    }

    async function getOrderHash(hash) {
      var jsondata = {};
      var DDEcontract3 = DDEcontract;
      if(DDEcontract == '') {
        DDEcontract3 = DDEcontract2;
      }
      await DDEcontract3.methods.getContract(DOMPurify.sanitize(hash)).call().then(async function (data) {
        var text = '';
        try {
          text = await getOfferData(DOMPurify.sanitize(data.message));
          //if(text=="error") {
          //  return false
          //}
          try {
            var testdata = JSON.parse(text);
            if('recipient' in testdata && 'sender' in testdata) {
              var cached = await getFile(Crypto.SHA256(text));
              if (!Array.isArray(cached)) {
                text = cached;
              } else {
                if(DOMPurify.sanitize(data.sender) == myaccounts) {
                  var message = cryptico.decrypt(testdata['sender'].cipher, userprivkey).plaintext;
                  console.log(message)
                  var padding = message.split("#*#*#")[1];
                  if(padding.length > 30) {
                    text = message.split("#*#*#")[0];
                  } else {
                    throw new Error("Not enough padding");
                  }
                } else if(DOMPurify.sanitize(data.recipient) == myaccounts) {
                  var message = cryptico.decrypt(testdata['recipient'].cipher, userprivkey).plaintext;
                  var padding = message.split("#*#*#")[1];
                  if(padding.length > 30) {
                    text = message.split("#*#*#")[0];
                  } else {
                    throw new Error("Not enough padding");
                  }
                }
              }
            }
          } catch (e) {
            console.log(e);
            console.log("Decryption failed");
          }
        } catch (e) {
          console.log(e);
        }
        jsondata = {
          sender: DOMPurify.sanitize(data.sender),
          recipient: DOMPurify.sanitize(data.recipient),
          token: DOMPurify.sanitize(data.token),
          referred: DOMPurify.sanitize(data.referred),
          amount: DOMPurify.sanitize(data.amount),
          depositSender: DOMPurify.sanitize(data.depositSender),
          depositRecipient: DOMPurify.sanitize(data.depositRecipient),
          quantity: [
            DOMPurify.sanitize(data.quantity[0]),
            DOMPurify.sanitize(data.quantity[1]),
          ],
          rfee: DOMPurify.sanitize(data.rfee),
          timelimit: [
            DOMPurify.sanitize(data.timelimit[0]),
            DOMPurify.sanitize(data.timelimit[1]),
            DOMPurify.sanitize(data.timelimit[2]),
          ],
          status: [
            DOMPurify.sanitize(data.status[0]),
            DOMPurify.sanitize(data.status[1]),
          ],
          message:DOMPurify.sanitize(text)
        };
        try {
          var reputation = [0,0,0];
          if(jsondata.sender != "0x0000000000000000000000000000000000000000") {
            reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getCompleted(jsondata.sender).call())));
            jsondata.reputationSender = reputation;
          }
          if(jsondata.recipient != "0x0000000000000000000000000000000000000000") {
            reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getCompleted(jsondata.recipient).call())));
            jsondata.reputationRecipient = reputation;
          }
        } catch (e) {
          console.log("Error loading reputation data");
        }
        try {
          jsondata.tags = [];
          jsondata.tags = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getTags(hash).call())));
        } catch (e) {
          console.log("Error loading tags");
        }
        if(text != '') {
          try {
            var messageData = JSON.parse(jsondata.message);
            if('recipient' in messageData && 'cipher' in messageData.recipient) {
              jsondata.image = [''];
              jsondata.message = DOMPurify.sanitize(text);
              jsondata.contact = '';
            } else {
              var myimg = Array.isArray(messageData.image) ? messageData.image : [''];
              storeFile(Crypto.SHA256(JSON.stringify(myimg)), myimg);
              jsondata.image = Crypto.SHA256(JSON.stringify(myimg));
              jsondata.message = messageData.message;
              jsondata.contact = messageData.contact;
            }
          } catch (e) {
            console.log("Error loading data");
            jsondata.image = [''];
            jsondata.message = DOMPurify.sanitize(text);
            jsondata.contact = '';
          }
        } else {
          jsondata.image = [''];
          jsondata.message = '';
        }
        jsondata.hash = hash;
      });
      return jsondata;
    }
    lastNotified = 0;
    lastNotified2 = 0;

    async function populateOffers() {
      const offersContainer = document.getElementById("myoffers");
      const contractsContainer = document.getElementById("mycontracts");
      offersContainer.innerHTML = loader;
      contractsContainer.innerHTML = loader;
      var list = document.createElement("ul");
      list.classList.add('offers-list-box');
      var readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":readmessages")) || {};
      var notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":notifications")) || {};
      var mylen = 0;
      var notify = 0;
      var myhash = '';
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 0).call());
      } catch(error) {
        console.log(error);
      }
      for (var i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash = DOMPurify.sanitize(await DDEcontract.methods.openOffers(myaccounts, i).call());
          const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(offerHash).call());
          if (offerID == 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts + DDEaddy + ":readmessages", JSON.stringify(readMessages));
            continue;
          }
          const offerData = await getOrderHash(offerHash);
          if(parseInt(offerData.timelimit[1]) != 0) {
            if(parseInt(offerData.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              if(offerData.sender != "0x0000000000000000000000000000000000000000" && offerData.recipient != "0x0000000000000000000000000000000000000000") {
                readMessages[i] = true;
                localStorage.setItem(myaccounts + DDEaddy + ":readmessages", JSON.stringify(readMessages));
                continue;
              }
            }
          }
          const li = document.createElement("listElement");
          const counterpartyAddress = offerData.sender === myaccounts ? offerData.recipient : offerData.sender;
          const counterpartyLabel = counterpartyAddress === "0x0000000000000000000000000000000000000000" ? translateThis("Market Offer") : counterpartyAddress;
          if(offerData.status[0] == 0 || offerData.status[0] == 2) {
            notenough = 0;
            if(myaccounts==offerData.sender && ((web3.utils.toBN(offerData.amount).add(web3.utils.toBN(offerData.depositSender))).mul(web3.utils.toBN(offerData.quantity[1]))).gt(web3.utils.toBN(balances[offerData.token].amount))) {
              notenough = 1;
            }
            if(myaccounts==offerData.recipient && (web3.utils.toBN(offerData.depositRecipient).mul(web3.utils.toBN(offerData.quantity[1]))).gt(web3.utils.toBN(balances[offerData.token].amount))) {
              notenough = 1;
            }
            if(parseInt(new Date().getTime()/1000) > lastNotified2 + 300 && notenough == 1) {
              lastNotified2 = parseInt(new Date().getTime()/1000);
              await Swal.fire({text:translateThis("You do not have enough funds to cover some of your pending offers if they were to be accepted. Please review your offers and deposit more funds or modify the offers. This can be true for autoaccept enabled offers, offers with high quantities and private offers.")});
            }
          }
          const svgString = jdenticon.toSvg(offerHash, 25);
          const base64String = btoa(svgString);
          const dataUrl = `data:image/svg+xml;base64,${base64String}`;
          var offerHashDisp = offerHash;
          if(window.innerWidth < 550) {
            offerHashDisp = offerHashDisp.substring(0, 32) + '...';
          }
          li.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl}" width="25" height="25"></img> ${offerHashDisp}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData.token, offerData.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData.quantity[0])}` + translateThis('(Total)') + ` - ${parseInt(offerData.quantity[1])}` + translateThis('(Maximum)') + `</div>
            <div><bdo>` + translateThis('Time Limit:') + `</bdo> ${parseInt(offerData.timelimit[0]) / (60 * 60 * 24 * 7)} ` + translateThis('weeks') + `</div>
            <div><bdo>` + translateThis('Message:') + `</bdo> ${offerData.message.slice(0, 20)}...</div><br>
          `;
          myhash = web3.utils.keccak256(li.innerHTML);
          if(offerHash in notifications) {
            if(notifications[offerHash] != myhash) {
              updateNotifications(notifications[offerHash], myhash, offerHash, offerData, 1);
              notifications[offerHash] = myhash;
              notify = 1;
            }
          } else {
            notifications[offerHash] = myhash;
            notify = 1;
            updateNotifications(notifications[offerHash], myhash, offerHash, offerData, 1);
          }
          li.onclick = function() {
            document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
            showListing(offerData, 1);
          };
          list.appendChild(li);
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "";
      }
      localStorage.setItem(myaccounts + DDEaddy + ":notifications", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":notifications2")) || {};
      var list2 = document.createElement("ul");
      list2.classList.add("offers-list-box");
      readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":readmessages2")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 1).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash2 = DOMPurify.sanitize(await DDEcontract.methods.privateOffers(myaccounts, i).call());
          const offerData2 = await getOrderHash(offerHash2);
          if(offerData2.message.includes('"recipient":') && offerData2.message.includes('"cipher":') && offerData2.message.includes('"status":')) {
            const testThis = JSON.parse(offerData2.message)
            if('recipient' in testThis && 'cipher' in testThis.recipient && parseInt(new Date().getTime()/1000) > lastNotified + 300) {
              lastNotified = parseInt(new Date().getTime()/1000);
              await Swal.fire(translateThis("Decryption error! Please attempt to decrypt your order manually with the correct password."));
            }
          }
          if (offerData2.status[0] > 0 && offerData2.status[1] > 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts + DDEaddy + ":readmessages2", JSON.stringify(readMessages));
            continue;
          }
          if(parseInt(offerData2.timelimit[1]) != 0) {
            if(parseInt(offerData2.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              readMessages[i] = true;
              localStorage.setItem(myaccounts + DDEaddy + ":readmessages2", JSON.stringify(readMessages));
              continue;
            }
          }
          if(parseInt(new Date().getTime()/1000) > lastNotified2 + 300) {
            notenough = 0;
            if(myaccounts==offerData2.sender && (web3.utils.toBN(offerData2.amount).add(web3.utils.toBN(offerData2.depositSender))).gt(web3.utils.toBN(balances[offerData2.token].amount))) {
              if(offerData2.status[0] == 1) {
                notenough = 1;
              }
            }
            if(myaccounts==offerData2.recipient && (web3.utils.toBN(offerData2.depositRecipient)).gt(web3.utils.toBN(balances[offerData2.token].amount))) {
              if(offerData2.status[1] == 1) {
                notenough = 1;
              }
            }
            if(notenough == 1) {
              lastNotified2 = parseInt(new Date().getTime()/1000);
              await Swal.fire({text:translateThis("You do not have enough funds to cover some of your pending offers if they were to be accepted. Please review your offers and deposit more funds or modify the offers. This can be true for autoaccept enabled offers, offers with high quantities and private offers.")});
            }
          }
          const li2 = document.createElement("listElement");
          const counterpartyAddress2 = offerData2.sender === myaccounts ? offerData2.recipient : offerData2.sender;
          const counterpartyLabel2 = counterpartyAddress2;
          const svgString2 = jdenticon.toSvg(offerHash2, 25);
          const base64String2 = btoa(svgString2);
          const dataUrl2 = `data:image/svg+xml;base64,${base64String2}`;
          var offerHashDisp2 = offerHash2;
          if(window.innerWidth < 550) {
            offerHashDisp2 = offerHashDisp2.substring(0, 32) + '...';
          }
          li2.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl2}" width="25" height="25"></img> ${offerHashDisp2}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel2}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData2.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData2.token, offerData2.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData2.quantity[0])}</div>
            <div><bdo>` + translateThis('Time Limit:') + `</bdo> ${parseInt(offerData2.timelimit[0]) / (60 * 60 * 24 * 7)} ` + translateThis('weeks') + `</div>
            <div><bdo>` + translateThis('Message:') + `</bdo> ${offerData2.message.slice(0, 20)}...</div><br>
          `;
          myhash = web3.utils.keccak256(li2.innerHTML);
          offerData2.index = i;
          if(offerHash2 in notifications) {
            let mode;
            if(myaccounts == offerData2.sender && offerData2.status[0] == 1) {
              mode = 1;
            }
            if(myaccounts == offerData2.sender && offerData2.status[0] == 0) {
              mode = 2;
            }
            if(myaccounts == offerData2.recipient && offerData2.status[1] == 1) {
              mode = 1;
            }
            if(myaccounts == offerData2.recipient && offerData2.status[1] == 0) {
              mode = 2;
            }
            var mslen = parseInt(DOMPurify.sanitize(await DDEcontract.methods.getMessageLength(offerHash2, counterpartyAddress2).call()));
            var msIndex = localStorage.getItem(myaccounts + DDEaddy + offerHash2 + counterpartyAddress2 + 'lastMessageIndex') || 0;
            if(mslen > msIndex) {
              offerData2.newMessage = true;
            }
            if(notifications[offerHash2] != myhash || offerData2.newMessage == true) {
              updateNotifications(notifications[offerHash2], myhash, offerHash2, offerData2, mode);
              notifications[offerHash2] = myhash;
              notify = 1;
            }
          } else {
            notifications[offerHash2] = myhash;
            notify = 1;
            updateNotifications(notifications[offerHash2], myhash, offerHash2, offerData2, mode);
          }          
          if(myaccounts == offerData2.sender && offerData2.status[0] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.sender && offerData2.status[0] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts + DDEaddy + ":notifications2", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":notifications3")) || {};
    
      offersContainer.innerHTML = ""; // clear the container first
      offersContainer.classList.add("offers-container");

      const sentOffersHeader = document.createElement("div");
      sentOffersHeader.classList.add("offers-header");
      sentOffersHeader.textContent = translateThis("Sent Offers");
      //offersContainer.appendChild(sentOffersHeader);
      list.setAttribute("style", "");
      //offersContainer.appendChild(list);

      const receivedOffersHeader = document.createElement("div");
      receivedOffersHeader.classList.add("offers-header");
      receivedOffersHeader.textContent = translateThis("Received Offers");
      //offersContainer.appendChild(receivedOffersHeader);
      list2.setAttribute("style", "");
      //offersContainer.appendChild(list2);

      const sentContainer = document.createElement("div");
      sentContainer.id = "senttab";
      sentContainer.classList.add("tabcontent");
      sentContainer.appendChild(sentOffersHeader);
      if (list.children.length === 0) {
          const noContractsMsg = document.createElement("p");
          noContractsMsg.textContent = translateThis("No Sent Offers");
          list.appendChild(noContractsMsg);
      }
      sentContainer.appendChild(list);

      const receivedContainer = document.createElement("div");
      receivedContainer.id = "receivedtab";
      receivedContainer.classList.add("tabcontent");
      receivedContainer.appendChild(receivedOffersHeader);
      if (list2.children.length === 0) {
          const noContractsMsg = document.createElement("p");
           noContractsMsg.textContent = translateThis("No Received contracts");
          list2.appendChild(noContractsMsg);
      }
      receivedContainer.appendChild(list2);

      const tabContainer = document.createElement("div");
      tabContainer.innerHTML = `
        <div class="offers-tab-container">
          <button class="tablinks" onclick="openTab(event, 'senttab')">` + translateThis('Sent Offers') + `</button>
          <button class="tablinks" onclick="openTab(event, 'receivedtab')">` + translateThis('Received Offers') + `</button>
          <br><br>
        </div>
      `;
      tabContainer.appendChild(sentContainer);
      tabContainer.appendChild(receivedContainer);
      offersContainer.appendChild(tabContainer);

      var list3 = document.createElement("ul");
      list3.classList.add('offers-list-box');
      readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":readmessages3")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 2).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash3 = DOMPurify.sanitize(await DDEcontract.methods.escrows(myaccounts, i).call());
          const offerData3 = await getOrderHash(offerHash3);
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if (autoClearCheckbox.checked) {
              readMessages[i] = true;
              localStorage.setItem(myaccounts + DDEaddy + ":readmessages3", JSON.stringify(readMessages));
              continue;
            }
          }
          const li3 = document.createElement("listElement");

          const counterpartyAddress3 = offerData3.sender === myaccounts ? offerData3.recipient : offerData3.sender;
          const counterpartyLabel3 = counterpartyAddress3;
          const svgString3 = jdenticon.toSvg(offerHash3, 25);
          const base64String3 = btoa(svgString3);
          const dataUrl3 = `data:image/svg+xml;base64,${base64String3}`;

          const currentBlockNumber = await web3.eth.getBlockNumber();
          const currentBlock = await web3.eth.getBlock(currentBlockNumber);
          const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
          const timeRemaining = (parseFloat(parseInt(offerData3.timelimit[0]) - parseInt(blockTimestamp)) / parseFloat(60 * 60 * 24)).toFixed(2);
          var offerHashDisp3 = offerHash3;
          if(window.innerWidth < 550) {
            offerHashDisp3 = offerHashDisp3.substring(0, 32) + '...';
          }
          li3.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl3}" width="25" height="25"></img> ${offerHashDisp3}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel3}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData3.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData3.token, offerData3.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData3.quantity[0])}</div>
            <div><bdo>` + translateThis('Time Until Funds Expire:') + `</bdo> ${timeRemaining} ` + translateThis('days') + `</div>
          `;
          offerData3.timeRemaining = timeRemaining;
          var escrowInfo = '';
          if (offerData3.status[0] != 4 && offerData3.status[1] != 4) {
            if(parseFloat(timeRemaining) < parseFloat(2)) {
              escrowInfo += "<div>" + translateThis('WARNING: Funds are about to expire. Resolve the escrow with your counter-party or all funds risk being burned.') + "</div>";
            }
            if(parseFloat(timeRemaining) <= parseFloat(0)) {
              escrowInfo += "<div>" + translateThis("The time limit has expired and the funds have been burned. This contract is no longer available.") + "</div>";
              offerData3.expired = 2;
            }
          }
          var skipthis = 0;
          if(offerData3.timelimit[0] == offerData3.timelimit[1] && offerData3.timelimit[1] == offerData3.timelimit[2]) {
            skipthis = 1;
          }
          if(offerData3.timelimit[1] != 0 && skipthis != 1) {            
            const timeExtension = Math.abs(parseFloat(parseInt(offerData3.timelimit[1]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += "<div>" + translateThis("Sender has requested a time extension for: ") + timeExtension + " " + translateThis("days") + "</div>";
          }
          if(offerData3.timelimit[2] != 0 && skipthis != 1) {            
            const timeExtension2 = Math.abs(parseFloat(parseInt(offerData3.timelimit[2]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += "<div>" + translateThis("Recipient has requested a time extension for: ") + timeExtension2 + " " + translateThis("days") + "</div>";
          }
          if (skipthis == 1) {
            escrowInfo += "<div>" + translateThis("Time extension granted.") + "</div>";
          }
          if (offerData3.status[0] == 2) {
            if(myaccounts == offerData3.sender) {
              escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
            } else {
              escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
            }
          }
          if (offerData3.status[0] == 3) {
            if(myaccounts == offerData3.sender) {
              escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
            } else {
              escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
            }
          }
          if (offerData3.status[1] == 2) {
            if(myaccounts == offerData3.sender) {
              escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
            } else {
              escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
            }
          }
          if (offerData3.status[1] == 3) {
            if(myaccounts == offerData3.sender) {
              escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
            } else {
              escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
            }
          }
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if(offerData3.status[0] == 4) {
              escrowInfo += "<div>" + translateThis("Contract completed!") + "</div>";;
            }
            if(offerData3.status[1] == 4) {
              escrowInfo += "<div>" + translateThis("Contract cancelled!") + "</div>";;
            }
            offerData3.expired = 1;
          }
          offerData3.escrowInfo = escrowInfo;
          li3.innerHTML += escrowInfo;
          li3.innerHTML += `<div>` + translateThis("Message:") + `${offerData3.message.slice(0, 20)}...</div><br>`
          const lineToExcludeRegex = new RegExp("<div>" + translateThis("Time Until Funds Expire:") + ".*" + translateThis("days") + "</div>");
          const inputString = li3.innerHTML.replace(lineToExcludeRegex, '');
          myhash = web3.utils.keccak256(inputString);
          offerData3.index = i;
          if(offerHash3 in notifications) {
            var mslen2 = parseInt(DOMPurify.sanitize(await DDEcontract.methods.getMessageLength(offerHash3, counterpartyAddress3).call()));
            var msIndex2 = localStorage.getItem(myaccounts + DDEaddy + offerHash3 + counterpartyAddress3 + 'lastMessageIndex') || 0;
            if(mslen2 > msIndex2) {
              offerData3.newMessage = true;
            }
            if(notifications[offerHash3] != myhash || offerData3.newMessage == true) {
              updateNotifications(notifications[offerHash3], myhash, offerHash3, offerData3, 4);
              notifications[offerHash3] = myhash;
              notify = 1;              
            }
          } else {
            notifications[offerHash3] = myhash;
            notify = 1;
            updateNotifications(notifications[offerHash3], myhash, offerHash3, offerHash3, 4);
          }          
          li3.onclick = function() {
            document.getElementById("contractsButton").style.backgroundColor = "#f2f2f2";
            showListing(offerData3, 4);
          };
          list3.appendChild(li3);
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("contractsButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts + DDEaddy + ":notifications3", JSON.stringify(notifications));
      const escrowContainer = document.getElementById("mycontracts");
      escrowContainer.innerHTML = ""; // clear the container first
      escrowContainer.classList.add("escrow-container");

      const escrowOffersHeader = document.createElement("div");
      escrowOffersHeader.classList.add("escrow-header");
      escrowOffersHeader.textContent = translateThis("Active contracts");
      escrowContainer.appendChild(escrowOffersHeader);
      list3.setAttribute("style", "");
      if (list3.children.length === 0) {
        // If no 'li' elements, append a message indicating no active contracts
        const noContractsMsg = document.createElement("p");
        noContractsMsg.textContent = translateThis("No active contracts");
        list3.appendChild(noContractsMsg);
      }
      escrowContainer.appendChild(list3);
      // syncNotifications();
    }

    function openTab(evt, tabName) {
      // Declare all variables
      let i, tabcontent, tablinks;
      // Get all elements with class="tabcontent"
      tabcontent = document.getElementsByClassName("tabcontent");
      let isCurrentlyVisible = document.getElementById(tabName).style.display === 'block';

      // Get all elements with class="tablinks" and remove the class "active"
      tablinks = document.getElementsByClassName("tablinks");
      for (i = 0; i < tablinks.length; i++) {
          tablinks[i].classList.remove("active");
      }

      // If the clicked tab is already visible, toggle the visibility of the other tabs
      if (isCurrentlyVisible) {
          for (i = 0; i < tabcontent.length; i++) {
              if (tabcontent[i].id !== tabName) {
                  tabcontent[i].style.display = tabcontent[i].style.display === 'none' ? 'block' : 'none';
              }
          }
      } else {
          // Hide all tabs first
          for (i = 0; i < tabcontent.length; i++) {
              tabcontent[i].style.display = "none";
          }
          // Show the clicked tab
          document.getElementById(tabName).style.display = 'block';
          evt.currentTarget.classList.add("active");
      }
    }

    function showMain(menu) {
      let sidebar = document.getElementById('sidebar');
      // Check if sidebar is active on mobile devices and close it
      if (window.innerWidth <= 991 && sidebar.classList.contains('active')) {
          toggleSidebar();
      }
      // hide all main divs
      var mains = document.querySelectorAll('.main');
      for (var i = 0; i < mains.length; i++) {
        mains[i].classList.remove('show');
      }

      // show the main div for the selected menu
      var main = document.querySelector('.main.' + menu);
      main.classList.add('show');

      // Remove active class from all sidebar buttons
      var buttons = document.querySelectorAll('.sidebar button');
      for (var i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
      }

      // Add active class to the clicked button
      var activeButton = document.getElementById(menu + 'Button');
      if (activeButton) {
        activeButton.classList.add('active');
      }
    }
    //**************MARKETS TAB//**************
    // global variables for pagination
    var currentPage = 1;
    var listingsPerPage = 2;

    async function populateListings(searchText = "", sortHits = 0) {
      if(sortHits == 1) {
        sortByHits();
      } else {
        var sortBy = document.getElementById("SortBy").value;
        if(sortBy == "price-low") {
          sortByAmountLow();
        }
        if(sortBy == "price-high") {
          sortByAmountHigh();
        }
      }
      var listingsDiv = document.querySelector('.main.markets .listings');
      listingsDiv.innerHTML = '';
      
      var startIndex = (currentPage - 1) * listingsPerPage;
      var endIndex = startIndex + listingsPerPage;
      if (endIndex > marketOffers.indices.length) {
        endIndex = marketOffers.indices.length;
      }
      searchText = searchText.toLowerCase();
      if (searchText !== "") {
        endIndex = marketOffers.indices.length;
      }
      var shown = 0;
      var offer;
      var myhashes = {};

      var gridContainer = document.createElement('div');
      gridContainer.classList.add('listings-grid');
      for (var i = startIndex; i < endIndex; i++) {
        if (shown == listingsPerPage) {
          break;
        }
        if (!marketOffers.hasOwnProperty(marketOffers.indices[i])) {
          continue;
        }
        if (parseInt(marketOffers.indices[i]) >= parseInt(currentMarketsLength)) {
          continue;
        }
        if (searchText !== "") {
          if(currentViewContext == '') {
            if (i < marketOffers.results.length) {
              offer = marketOffers[marketOffers.results[i]];
            } else {
              offer = marketOffers[marketOffers[marketOffers.indices[i]]];
            }
          } else {
            if (i < marketOffers.results.length) {
              offer = marketOffers[marketOffers.results[i]];
            } else {
              break;
            }
          }
          const keywords = searchText.split(/[,\s]+/);
          let foundKeyword = false;

          for (const keyword of keywords) {
            if (keyword.length === 0) {
              continue;
            }
            if (offer.message.toLowerCase().includes(keyword.toLowerCase())) {
              foundKeyword = true;
              break;
            }
            try {
              if (offer['searchTerms'].includes(keyword.toLowerCase())) {
                foundKeyword = true;
                break;
              }
            } catch {
              continue;
            }
          }
          if (!foundKeyword) {
            continue;
          }
        } else {
          if(marketOffers.results.length > 0 || sortHits == 2) {
            if (i < marketOffers.results.length) {
              offer = marketOffers[marketOffers.results[i]];
            } else {
              if(sortHits == 2) {
                continue;
              }
              if(currentViewContext == '') {
                offer = marketOffers[marketOffers[marketOffers.indices[i]]];
              } else {
                continue;
              }
            }
          } else {
            offer = marketOffers[marketOffers[marketOffers.indices[i]]];
          }
        }
        if (offer.hash in myhashes) {
          continue;
        } else {
          myhashes[offer.hash] = 1;
        }    
        var gridItem = document.createElement('div');
        gridItem.classList.add('listing-grid-item');
        var myimg = await getFile(offer.image);
        var tempimg = '<img src="./blank-image.jpg" alt="">'; 
        var foundImage = false; 

        if (myimg.length > 0) {
          const imageMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'];

          for (let j = 0; j < myimg.length; j++) {
              const mimeType = myimg[j].match(/^data:(.*?);/)[1].toLowerCase();

              if (imageMimeTypes.includes(mimeType)) {
                  tempimg = '<img src="' + myimg[j] + '" alt="./blank-image.jpg">';
                  foundImage = true;
                  break; 
              }
          }

          if (!foundImage) {
              tempimg = '<img src="./blank-image.jpg" alt="Document Placeholder">';
          }
        }

        gridItem.innerHTML = `
            <div class="listing-image">${tempimg}</div>
            <div class="listing-details">
                <div class="token-ammount-content">
                  <div class="token">` + '<bdo class="theText">' + translateThis("Currency:") + '</bdo>' + ` ${tokennames[offer.token]}</div>
                  <div class="amount">` + '<bdo class="theText">' + translateThis("Amount:") + '</bdo>'  + ` ${displayDecimals(offer.token, offer.amount)}</div>
                </div>
                <div class="message">` + '<bdo class="theText">' + translateThis("Details:") + '</bdo>' + ` ${offer.message.slice(0, 20) + (offer.message.length > 20 ? "..." : "")}</div>
            </div>
        `;

        // create a closure to bind the offer variable to the onclick function
        (function (offer) {
          gridItem.onclick = function () {
            showListing(offer);
          };
        })(offer);

        gridContainer.appendChild(gridItem);
        shown++;
      }
      listingsDiv.appendChild(gridContainer);
      // Inject CSS styles into a style tag
      var style = document.createElement('style');
      style.textContent = `
        `;
      document.head.appendChild(style);
    }

    function updateNotifications(oldHash, newHash, offerHash, newOfferData, mode) {
      try {
        if (oldHash === undefined || newHash === undefined) {
          console.log("One or both hashes are undefined. No action taken.");
          return;
        }

        var notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":unifiedNotifications")) || {};
        var oldOfferData = notifications[offerHash] ? notifications[offerHash].listing : null;

        if (oldHash !== newHash || newOfferData.newMessage == true) {
          let message = generateNotificationMessage(oldOfferData, newOfferData);
          newOfferData.newMessage = false;
          notifications[offerHash] = {
            isRead: false,
            message: message,
            listing: {hash:offerHash,newMessage:false,timeRemaining:newOfferData.timeRemaining,status:newOfferData.status,escrowInfo:newOfferData.escrowInfo,image:newOfferData.image,index:newOfferData.index},
            timestamp: new Date().toISOString(),
            mode
          };

          localStorage.setItem(myaccounts + DDEaddy + ":unifiedNotifications", JSON.stringify(notifications));

          displayNotifications();
          updateBellIcon(notifications);
        }
      } catch (error) {
        console.error("Error processing notification update:", error);
      }
    }

    function generateNotificationMessage(oldOfferData, newOfferData) {
      if (!oldOfferData) return [translateThis("New Offer"), translateThis("A new offer has been posted.")];

      let title = translateThis("Contract Update");
      let details = [];

      // Check for changes in message content
      if (newOfferData.newMessage == true) {
        title = translateThis("New Message");
        details.push(translateThis("You have unread messages"));
      }

      // Check for changes in the status
      if (oldOfferData.status.join(',') !== newOfferData.status.join(',')) {
        let statusKey = newOfferData.status.join(',');
        let statusMessage = combinedStatusDescriptions[statusKey] || "Status updated";
        title = translateThis("Notification on Contract");
        details.push(translateThis(statusMessage));
      }

      // Check for changes in time remaining
      if (oldOfferData.timeRemaining !== undefined && newOfferData.timeRemaining !== undefined && oldOfferData.timeRemaining !== newOfferData.timeRemaining) {        
        if (newOfferData.timeRemaining < 7 && oldOfferData.timeRemaining - newOfferData.timeRemaining > .5) {
          title = translateThis("Time Update");
          details.push(translateThis("Time Until Funds Expire:") + " " + newOfferData.timeRemaining + " " + translateThis("days"));
        }
      }

      // Check for changes in escrow information
      if (oldOfferData.escrowInfo !== newOfferData.escrowInfo) {
        title = translateThis("Escrow Update");
        details.push(translateThis("Notification on escrow"));
      }

      // Default message if no specific changes are detected
      if (details.length === 0) {
        details.push(translateThis("Changes detected in the offer details."));
      }

      return [title, details.join(' ')];
    }

    function updateBellIcon(notifications){
      const notificationBell = document.querySelector(".notification-lottie-file lottie-player");
      const unreadNotifications = Object.keys(notifications).filter(hash => !notifications[hash].isRead).length;
      if (myaccounts === "" || unreadNotifications ===  0) {
        notificationBell.stop();
      } else {
        notificationBell.play();
      }
    }

    async function displayNotifications() {
      const notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":unifiedNotifications") || "{}");
      const notificationBox = document.getElementById("notification-box");

      // Clear existing notifications
      notificationBox.innerHTML = '';
      if (myaccounts === "") {
        notificationBox.innerHTML = `<div class="notification-empty">${translateThis("Login to see notifications")}</div>`;
      } else {
        const unreadNotifications = Object.entries(notifications).filter(([hash, notification]) => !notification.isRead);
          if (Object.keys(unreadNotifications).length === 0) {
            notificationBox.innerHTML = `<div class="notification-empty">${translateThis("You have no unread notifications")}</div>`;
          } else {
            unreadNotifications.forEach(async ([hash, notification]) => {
            const notificationContent = document.createElement('div');
            notificationContent.className = 'notification-box-content';

            const notificationButton = document.createElement('button');
            notificationButton.className = 'notification-box-content-button';

            let myimg = await getFile(notification.listing.image);
            let tempimg = '<img src="./blank-image.jpg" alt="No image available">'; 
            let foundImage = false;

            // Check if there are any images returned and process them
            if (myimg && myimg.length > 0) {
              const imageMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'];

              for (let i = 0; i < myimg.length; i++) {
                const mimeTypeMatch = myimg[i].match(/^data:(.*?);/);
                if (mimeTypeMatch && imageMimeTypes.includes(mimeTypeMatch[1].toLowerCase())) {
                  tempimg = `<img src="${myimg[i]}" alt="Notification image">`;
                  foundImage = true;
                  break;
                }
              }

              if (!foundImage) {
                tempimg = '<img src="./blank-image.jpg" alt="Document Placeholder">';
              }
            }

            notificationButton.innerHTML = `
              <div class="notification-badge">
                ${tempimg}
              </div>
              <div class="notification-box-content-info">
                <h6>${notification.message[0] || "Default Title"}</h6>
                <p>${notification.message[1] || "No details available."}</p>
              </div>
            `;

            notificationButton.addEventListener('click', async () => {
              var mylisting = await getOrderHash(notification.listing.hash);
              if(notification.mode == 4) {
                const currentBlockNumber = await web3.eth.getBlockNumber();
                const currentBlock = await web3.eth.getBlock(currentBlockNumber);
                const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
                mylisting.timeRemaining = (parseFloat(parseInt(mylisting.timelimit[0]) - parseInt(blockTimestamp)) / parseFloat(60 * 60 * 24)).toFixed(2);
                mylisting.escrowInfo = notification.listing.escrowInfo;
                mylisting.index = notification.listing.index;
              }
              showListing(mylisting, notification.mode);
            });
            notificationContent.appendChild(notificationButton);

            notificationBox.appendChild(notificationContent);
          });
        }
      }
    }

    function markAllNotificationsAsRead() {
      const notifications = JSON.parse("{}");
      localStorage.setItem(myaccounts + DDEaddy + ":unifiedNotifications", "{}");
      updateBellIcon(notifications);
    }

    document.querySelector(".notification-lottie-file").addEventListener('click', () => {
      const notifications = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":unifiedNotifications") || "{}");
      const notificationBox = document.getElementById("notification-box");
      const notificationBell = document.querySelector(".notification-lottie-file lottie-player");
      if (myaccounts === "") {
        notificationBox.innerHTML = `<div class="notification-empty">${translateThis("Login to see notifications")}</div>`;
      } else {
        const unreadNotifications = Object.entries(notifications).filter(([hash, notification]) => !notification.isRead);
        if (unreadNotifications.length === 0) {
          notificationBox.innerHTML = `<div class="notification-empty">${translateThis("You have no unread notifications")}</div>`;
        } else {
          displayNotifications();
          notificationBell.stop();
        }
      }
      notificationsToggle();
    });

    function notificationsToggle() {
      const notificationBox = document.getElementById('notification-box');
      const isActive = notificationBox.classList.toggle('active');
      if (!isActive) {
        markAllNotificationsAsRead();
      }
    }
    
    function displayDecimals(token, amountString) {
      var formattedAmount = '';
      for (var i = 0; i < tokens.length; i++) {
            if(tokens[i].address == token) {
          const length = amountString.length;

          if (length <= tokens[i].decimals) {
            const zerosToAdd = tokens[i].decimals - length;
            amountString = '0'.repeat(zerosToAdd) + amountString;
          }
          const position = length - tokens[i].decimals;
          formattedAmount = amountString.substring(0, position) + '.' + amountString.substring(position);
          // Remove leading zeros
          formattedAmount = formattedAmount.replace(/^0+/, '');
          // If the string starts with a '.', prepend '0'
          formattedAmount = formattedAmount.replace(/^\./, '0.');
          // Remove trailing zeros
          formattedAmount = formattedAmount.replace(/0+$/, '');
          // If the string ends with a '.', remove it
          formattedAmount = formattedAmount.replace(/\.$/, '');
          break;
        }
      }
      return formattedAmount || '0';
    }

    // function for searching the listings
    async function searchListings(searchText, deep=0) {
      // filter the marketOffers array based on the searchText
      // and update the currentPage to 1
      currentPage = 1;
      if (searchText.trim() === "") {        
        if(deep == 1) {          
          await loadDefaultMarkets();
        }
        return;
      }      
      if (deep == 1) {
        await waitLock();
        document.getElementById("loadingStatus").innerHTML = loader;
        currentViewContext = 'searchTag';
        locked = true;
        await loadMarkets(0, maxContextLoad[1], searchText);
        locked = false;
        document.getElementById("loadingStatus").innerHTML = "";
      } else {
        await populateListings(searchText);
      }
    }

    // async function searchFavorites() {
    //   document.getElementById("loadingStatus").innerHTML = translateThis("Loading...");
    //   await loadMarkets(0, 50, myFavorites);
    //   document.getElementById("loadingStatus").innerHTML = "";
    // }

    async function searchFavorites() {
      await waitLock();
      document.getElementById("loadingStatus").innerHTML = loader;     
      if (!isFavoritesShown) {
          const favorites = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":myFavorites")) || [];
          if (favorites.length === 0) {
              document.getElementById("loadingStatus").innerHTML = translateThis("No favorites found.");
             return;
         }
         currentViewContext = 'favorites';
         locked = true;
         await loadMarkets(0, maxContextLoad[2], favorites);
         locked = false;
         isFavoritesShown = true;
       } else {
           currentViewContext = '';
           locked = true;
           await loadMarkets(0, maxContextLoad[0]);
           locked = false;
           isFavoritesShown = false;
       }       
       document.getElementById("loadingStatus").innerHTML = "";
    }

    var prevLength = 0;
    var prevBatch = 0;
    function updatePaginationControls(totalItems = currentMarketsLength, batchLength = 0, mdefault = 0) {      
      if(mdefault == 0) {
        prevLength = totalItems;
        prevBatch = batchLength;
      } else {
        totalItems = prevLength;
        batchLength = prevBatch;
      }
      var totalPages = Math.ceil(totalItems / listingsPerPage);
      var prevButton = document.querySelector('[onclick="previousPage()"]');
      var nextButton = document.querySelector('[onclick="nextPage()"]');
      var paginationNumbers = document.getElementById('paginationNumbers');

      paginationNumbers.innerHTML = '';

      if (currentPage > 1) {
          createPageButton(currentPage - 1);
      }
      createPageButton(currentPage);
      if (currentPage < totalPages) {
          createPageButton(currentPage + 1);
      }

      // Disable or enable buttons based on the current page
      prevButton.disabled = currentPage === 1;
      nextButton.disabled = false;
      if(totalItems >= batchLength) {
        nextButton.disabled = currentPage * listingsPerPage >=  totalItems;
      }
      prevButton.classList.toggle('button-disabled', currentPage === 1);
      nextButton.classList.toggle('button-disabled', nextButton.disabled);

      function createPageButton(page) {
        let pageButton = document.createElement('button');
        pageButton.textContent = page;
        pageButton.className = 'page-number';
        pageButton.onclick = function () { goToPage(page, totalItems); };
        if (page === currentPage) {
          pageButton.classList.add('active'); // Highlight the current page
        }
        paginationNumbers.appendChild(pageButton);
      }

      // populateListings();

    }

    async function goToPage(pageNumber, totalItems){
      currentPage = pageNumber;
      await populateListings();
      updatePaginationControls(0,0,1);
    }

    // async function previousPage() {
    //   if (currentPage > 1) {
    //     currentPage--;
    //     await populateListings();
    //     updatePaginationControls(marketOffers.indices.length);
    //   }
    // }

    async function previousPage() {
        if (currentPage > 1) {
            currentPage--;
            await populateListings();
            updatePaginationControls(0,0,1);
        }
    }

    async function getTotalItemsForUserStore(userStoreKey) {
        try {
            const totalItems = await DDEcontract3.methods.getArrayLength(userStoreKey, 0).call();
            return DOMPurify.sanitize(totalItems);
        } catch (error) {
            console.error("Error fetching total items for user store:", error);
            return 0;
        }
    }

    async function nextPage() {
        var totalItems = marketOffers['results'].length;
        var startIndex = currentPage * listingsPerPage;
        var totalPages = Math.ceil(totalItems / listingsPerPage);
        if(currentPage < totalPages) {
          currentPage += 1;
          updatePaginationControls(0,0,1);
        }
        // Handle different contexts for loading markets        
        switch (currentViewContext) {
            case 'favorites':
                const favorites = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":myFavorites")) || [];
                if (startIndex >= totalItems) {
                  currentPage += 1;
                  await waitLock();
                  document.getElementById("loadingStatus").innerHTML = loader;
                  locked = true;
                  await loadMarkets(contextIndex, maxContextLoad[2], favorites);
                  locked = false;
                  document.getElementById("loadingStatus").innerHTML = "";
                }
                break;
            case 'userStore':
                const userStoreKey = document.getElementById("searchText").value.split("userStore:")[1].trim();
                if (startIndex >= totalItems) {
                  currentPage += 1;
                  await waitLock();
                  document.getElementById("loadingStatus").innerHTML = loader;
                  locked = true;
                  await loadMarkets(contextIndex, maxContextLoad[3], "userStore:" + userStoreKey);
                  locked = false;
                  document.getElementById("loadingStatus").innerHTML = "";
                }
                break;
            case 'searchTag':
                if (startIndex >= totalItems) {
                  currentPage += 1;
                  await waitLock();
                  document.getElementById("loadingStatus").innerHTML = loader;
                  locked = true;
                  await loadMarkets(contextIndex, maxContextLoad[1], document.getElementById("searchText").value);
                  locked = false;
                  document.getElementById("loadingStatus").innerHTML = "";
                }
                break;
            default:
                if (startIndex >= totalItems) {
                  currentPage += 1;
                  await waitLock();
                  document.getElementById("loadingStatus").innerHTML = loader;
                  locked = true;
                  await loadMarkets(contextIndex, maxContextLoad[0]);
                  locked = false;
                  document.getElementById("loadingStatus").innerHTML = "";
                }
                break;
        }        
        await populateListings();        
    }

    //   async function nextPage() {
    //   var totalItems = marketOffers.indices.length;
    //   var totalPages = Math.ceil(totalItems / listingsPerPage);

    //   if (currentPage < totalPages) {
    //       currentPage++;
    //       await populateListings();
    //       updatePaginationControls(totalItems);
    //   } else {
    //       document.getElementById("loadingStatus").innerHTML = loader;
    //       await loadMarkets(totalItems, totalItems + 5); // Fetch next listings
    //       document.getElementById("loadingStatus").innerHTML = "";
    //       if (currentPage < totalPages) {
    //           currentPage++;
    //       }
    //       await populateListings();
    //       updatePaginationControls(totalItems + 5);
    //   }
    // }
    // populateListings();
    // Function to show the details popup for a listing
    async function showListing(listing, mode = 0) {
      var theuser = myaccounts;
      if(mode == 4 && listing.sender != myaccounts && listing.recipient != myaccounts) {
        theuser = listing.originalUser;
      }
      if(notifyFavorites == "0" && mode == 0) {
        await Swal.fire({
          icon: 'info',
          title: translateThis('Welcome'),
          text: translateThis('Welcome to the markets. As you browse you may choose to add orders to your favorites list by clicking the star. This may function as a useful cart or history for deals you wish to revisit. Please review the amount, currency, deposits, time limit and deal structure carefully before accepting. Always attempt to remain in close contact with your counter-party to ensure success. With that said enjoy using one of the safest escrows in the world!'),
        });
        notifyFavorites = "1";
        localStorage.setItem(myaccounts + DDEaddy + ":notifyFavorites", notifyFavorites);
      }
      if(listing.message.includes('"recipient":') && listing.message.includes('"cipher":') && listing.message.includes('"status":')) {
        await Swal.fire({
          title: translateThis('Encrypted listing'),
          text: translateThis('It seems like you did not have the decryption key for this order. Would you like to enter the password to decrypt it now?'),
          showCancelButton: true,
          confirmButtonText: translateThis('Yes'),
          cancelButtonText: translateThis('No'),
          icon: 'question',
        }).then(async (result) => {
          if (result.isConfirmed) {
            var thisText = listing.message;
            try {
              userprivkey2='';
              await Swal.fire({
                title: translateThis('Confirm Password'),
                input: 'password',
                inputPlaceholder: translateThis('Please enter decryption password'),
                showCancelButton: true,
                confirmButtonText: translateThis('Confirm Password'),
                cancelButtonText: translateThis('Cancel'),
                preConfirm: async (confirmedPassword) => {
                  var hashedPassword = confirmedPassword;
                  hashedPassword = Crypto.SHA256(hashedPassword);
                  userprivkey2=hashedPassword;
                  showLoader();
                  for(var i=1; i<50000; i++) {
                    userprivkey2=Crypto.SHA256(userprivkey2);
                  }
                  userprivkey2 = cryptico.generateRSAKey(userprivkey2, 1024);
                  hideLoader();
                }
              });
              var testdata = JSON.parse(thisText);
              var successful = 0;
              if(DOMPurify.sanitize(listing.sender) == theuser) {
                var message = cryptico.decrypt(testdata['sender'].cipher, userprivkey2).plaintext;
                var padding = message.split("#*#*#")[1];
                if(padding.length > 30) {
                  thisText = message.split("#*#*#")[0];
                  successful = 1;
                } else {
                  throw new Error("Not enough padding");
                }
              } else if(DOMPurify.sanitize(listing.recipient) == theuser) {
                var message = cryptico.decrypt(testdata['recipient'].cipher, userprivkey2).plaintext;
                var padding = message.split("#*#*#")[1];
                if(padding.length > 30) {
                  thisText = message.split("#*#*#")[0];
                  successful = 1;
                } else {
                  throw new Error("Not enough padding");
                }
              }
              if(successful == 0) {
                throw new Error("Failed");
              }
              var messageData = JSON.parse(thisText);
              var myimg = Array.isArray(messageData.image) ? messageData.image : [''];
              storeFile(Crypto.SHA256(JSON.stringify(myimg)), myimg);
              storeFile(Crypto.SHA256(listing.message), thisText);
              listing.image = Crypto.SHA256(JSON.stringify(myimg));
              listing.message = messageData.message;
              listing.contact = messageData.contact;
            } catch (e) {
              console.log(e);
              console.log("Decryption failed");
              await Swal.fire(translateThis("Decryption failed"));
              hideLoader();
            }
          }
        });
      }
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');

      const popup = document.createElement('div');
      const popupWrapper = document.createElement('div');
      popupWrapper.classList.add('offer-popup-wrapper');
      popup.classList.add('popup');
      popup.classList.add('offer-popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      const imageContainer = document.createElement('div');
      imageContainer.classList.add('image-container');

      const leftArrow = document.createElement('span');
      leftArrow.innerHTML = '&#10094;';
      leftArrow.classList.add('arrow', 'left-arrow');
      leftArrow.onclick = function() { plusSlides(-1); this.style.color = '#ccc'; setTimeout(() => this.style.color = '', 200); };
      leftArrow.title = translateThis('Previous Image');
      leftArrow.style.cursor = 'pointer';
      const rightArrow = document.createElement('span');
      rightArrow.innerHTML = '&#10095;';
      rightArrow.classList.add('arrow', 'right-arrow');
      rightArrow.onclick = function() { plusSlides(1); this.style.color = '#ccc'; setTimeout(() => this.style.color = '', 200); };
      rightArrow.title = translateThis('Next Image');
      rightArrow.style.cursor = 'pointer';
      let slideIndex = 1;

      function plusSlides(n) {
        showSlides(slideIndex += n);
      }

      function showSlides(n) {
        const slides = document.getElementsByClassName('popup-image');
        if (slides.length === 0) return;

        if (n > slides.length) {
            slideIndex = 1;
        } else if (n < 1) {
            slideIndex = slides.length;
        } else {
            slideIndex = n;
        }

        for (let i = 0; i < slides.length; i++) {
            if (slides[i]) slides[i].style.display = 'none'; 
        }

        if (slides[slideIndex - 1]) {
            slides[slideIndex - 1].style.display = 'block'; 
        }
      }
      const imageList = document.createElement('ul');
      const arrowsContainer = document.createElement('div');
      const downloadContainer = document.createElement('div');
      downloadContainer.classList.add('download-container');
      var myimgs = await getFile(listing.image);
      var downloadLinks = [];
      var imageCount = 0;
      if (myimgs.length > 0) {
        imageList.classList.add('image-list');
        imageList.style.listStyle = 'none';
        imageList.onclick = function() { plusSlides(1); };

        for (let i = 0; i < myimgs.length; i++) {
          const li = document.createElement('li');
          const fileData = myimgs[i];
          const [fileTypePrefix, base64Content] = fileData.split(';base64,');

          // Check if the file type is an image
          if (fileTypePrefix.startsWith('data:image')) {
              const img = document.createElement('img');
              img.src = fileTypePrefix + ';base64,' + base64Content;
              img.classList.add('popup-image');
              li.appendChild(img);
              imageCount++;
          } else {
              downloadLinks.push(fileTypePrefix + ';base64,' + base64Content);
          }

          imageList.appendChild(li);
        }

        if (imageCount > 0) {
          arrowsContainer.classList.add('arrows-container');
          arrowsContainer.style.position = 'relative';

          if (imageCount > 1) {
            arrowsContainer.appendChild(leftArrow);
            arrowsContainer.appendChild(rightArrow);
          }

          imageContainer.appendChild(imageList);
          imageContainer.appendChild(arrowsContainer);
        } else {
          imageContainer.style.display = 'none';
        }
      } else {
        imageContainer.style.display = 'none';
      }
      popup.appendChild(imageContainer);
      if (downloadLinks.length > 0 && mode !== 3) {
        const downloadAllLink = document.createElement('a');
        downloadAllLink.textContent = translateThis('Download Files');
        downloadAllLink.href = '#';
        downloadAllLink.addEventListener('click', async function (event) {
            event.preventDefault();
            const result = await Swal.fire({
                icon: 'warning',
                title: translateThis('Security Warning'),
                text: translateThis('You are about to download files. Please make sure you trust any files being sent before proceeding.'),
                showCancelButton: true,
                confirmButtonText: translateThis('Proceed'),
                cancelButtonText: translateThis('Cancel'),
            });
            if (result.isConfirmed) {
                downloadLinks.forEach(link => {
                    const tempLink = document.createElement('a');
                    tempLink.href = link;
                    tempLink.download = ''; 
                    document.body.appendChild(tempLink);
                    tempLink.click();
                    document.body.removeChild(tempLink);
                });
            }
        });
        downloadContainer.appendChild(downloadAllLink);
        // imageContainer.appendChild(downloadContainer); 
      }

      // popup.appendChild(downloadContainer);
      const details = document.createElement('div');
      details.classList.add('popup-details');

      function copyToClipboard(mytext) {
        const tempInput = document.createElement('input');
        document.body.appendChild(tempInput);
        tempInput.value = mytext;
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        Swal.fire(translateThis('Address copied to clipboard!'));
      }

      const sender = document.createElement('p');
      sender.classList.add("modal-funds-text");
      var text = "<bdo>" + translateThis("Sender:") + "</bdo> ";
      if(listing.sender == "0x0000000000000000000000000000000000000000") {
        if(theuser != listing.recipient) {
          text = translateThis("You are the one paying/sending the funds.");
        } else {
          text = translateThis("You are the one receiving the funds.");
        }
        sender.innerHTML = "<br>" + text;
      } else {
        sender.innerHTML = "<br>" + text;
        const senderContainer = document.createElement('span');
        const senderTextSpan = document.createElement('span');
        senderTextSpan.style.fontSize = '12px';
        senderTextSpan.textContent = listing.sender;
        senderTextSpan.style.cursor = 'pointer';
        senderTextSpan.style.textDecoration = 'underline';

        const copyButton = document.createElement('button');
        copyButton.textContent = '';
        copyButton.onclick = function() {
          copyToClipboard(listing.sender);
        };

        senderTextSpan.onclick = function() {
          Swal.fire({
            title: translateThis('Show listings'),
            text: translateThis('Would you like to see more listings from this user?'),
            showCancelButton: true,
            confirmButtonText: translateThis('Yes'),
            cancelButtonText: translateThis('No'),
            icon: 'question',
          }).then(async (result) => {
            if (result.isConfirmed) {
              popupContainer.remove();
              showMain('markets');
              document.getElementById("searchText").value="userStore:"+listing.sender;              
              await waitLock();
              currentViewContext = 'userStore';
              document.getElementById("loadingStatus").innerHTML = loader;
              locked = true;
              await loadMarkets(0, maxContextLoad[3], "userStore:"+listing.sender);
              locked = false;
              document.getElementById("loadingStatus").innerHTML = "";
            }
          });
        };

         // Check if the recipient supports encryption and display badge
        
        var { supportsEncryption: senderSupportsEncryption } = await userSupportsEncryption(listing.sender);

        var senderEncryptionBadge = document.createElement('p');
        senderEncryptionBadge.textContent = ` ${translateThis('Encryption Supported')}`;
        senderEncryptionBadge.style.color = 'green';
        senderEncryptionBadge.style.fontSize = '12px';
        senderEncryptionBadge.style.marginLeft = '10px';

        senderContainer.appendChild(senderTextSpan);
        senderContainer.appendChild(document.createTextNode('\u00A0'));
        senderContainer.appendChild(copyButton);
        if(senderSupportsEncryption) {
          senderContainer.appendChild(senderEncryptionBadge);
        }
        sender.appendChild(senderContainer);
      }
      const recipient = document.createElement('p');
      var text2 = "<bdo>" + translateThis("Recipient:") + "</bdo> ";
      if(listing.recipient == "0x0000000000000000000000000000000000000000") {
        if(theuser != listing.sender) {
          text2 = translateThis("You are the one receiving the funds.");
        } else {
          text2 = translateThis("You are the one paying/sending the funds.");
        }
        recipient.innerHTML = text2;
      } else {
        recipient.innerHTML = text2;
        const recipientContainer = document.createElement('span');
        const recipientTextSpan = document.createElement('span');
        recipientTextSpan.style.fontSize = '';
        recipientTextSpan.textContent = listing.recipient;
        recipientTextSpan.style.cursor = 'pointer';
        recipientTextSpan.style.textDecoration = 'underline';
        const copyButton = document.createElement('button');
        copyButton.textContent = '';
          copyButton.onclick = function() {
          copyToClipboard(listing.recipient);
        };
          recipientTextSpan.onclick = function() {
          Swal.fire({
            title: translateThis('Show listings'),
            text: translateThis('Would you like to see more listings from this user?'),
            showCancelButton: true,
            confirmButtonText: translateThis('Yes'),
            cancelButtonText: translateThis('No'),
            icon: 'question',
          }).then(async (result) => {
            if (result.isConfirmed) {
              popupContainer.remove();
              showMain('markets');
                document.getElementById("searchText").value="userStore:"+listing.recipient;                
                await waitLock();
                currentViewContext = 'userStore';
                document.getElementById("loadingStatus").innerHTML = loader;
                locked = true;
                loadMarkets(0, maxContextLoad[3], "userStore:"+listing.recipient);
                locked = false;
                document.getElementById("loadingStatus").innerHTML = "";
            }
          });
        };
        // Check if the recipient supports encryption and display badge
        var { supportsEncryption: recipientSupportsEncryption} = await userSupportsEncryption(listing.recipient);
        var recipientEncryptionBadge = document.createElement('p');
        recipientEncryptionBadge.textContent = ` ${translateThis('Encryption Supported')}`;
        recipientEncryptionBadge.style.color = 'green';
        recipientEncryptionBadge.style.fontSize = '12px';
        recipientEncryptionBadge.style.marginLeft = '10px';

        recipientContainer.appendChild(recipientTextSpan);
        recipientContainer.appendChild(document.createTextNode('\u00A0'));
        recipientContainer.appendChild(copyButton);
        if(recipientSupportsEncryption) {
          recipientContainer.appendChild(recipientEncryptionBadge);
        }
        recipient.appendChild(recipientContainer);
      }

      const token = document.createElement('p');
      token.innerHTML = "<bdo>" + translateThis('Token:') + '</bdo> ' + tokennames[listing.token];

      const amount = document.createElement('p');
      amount.innerHTML = "<bdo>" + translateThis('Amount:') + '</bdo> ' + displayDecimals(listing.token,listing.amount);      

      if(listing.rfee != 0) {
        var theFee = document.createElement('p');
        theFee.innerHTML = "<bdo>" + translateThis('Referral fee(estimated):') + '</bdo> ' + (listing.rfee / 100).toFixed(2) + "%";
      }
      if(listing.referred != "0x0000000000000000000000000000000000000000") {
        var theReferred = document.createElement('p');
        const theReferredTextSpan = document.createElement('span');
        theReferredTextSpan.style.fontSize = '12px';
        theReferredTextSpan.textContent = listing.referred;
        theReferred.innerHTML = "<bdo>" + translateThis('Referral address:') + '</bdo> ';
        theReferred.appendChild(theReferredTextSpan);
      }
      if(listing.tags && listing.tags.length != 0) {
        var theTags = document.createElement('p');
        theTags.innerHTML = translateThis('Tags:') + ' ' + listing.tags.join(', ');
      }

      const depositSender = document.createElement('p');
      depositSender.innerHTML = "<bdo>" + translateThis('Deposit Sender:') + '</bdo> ' + displayDecimals(listing.token,listing.depositSender);

      const depositRecipient = document.createElement('p');
      depositRecipient.innerHTML = "<bdo>" + translateThis('Deposit Recipient:') + '</bdo> ' + displayDecimals(listing.token,listing.depositRecipient);

      const quantity = document.createElement('p');
      quantity.innerHTML = "<bdo>" + translateThis('Quantity:') + '</bdo> ' + parseInt(listing.quantity[0]);
      if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
        quantity.innerHTML = "<bdo>" + translateThis('Quantity:') + '</bdo> ' + parseInt(listing.quantity[0]) + "" + translateThis('(Total)') + '- ' + parseInt(listing.quantity[1]) + "" + translateThis('(Maximum)') + "";
      }

      const timelimit = document.createElement('p');
      timelimit.innerHTML = "<bdo>" + translateThis('Time limit:') + '</bdo> ' + Math.floor(parseInt(listing.timelimit[0]) / (60 * 60 * 24 * 7)) + ' ' + "" + translateThis('weeks') + "";

      const message = document.createElement('p');
      message.innerHTML = '<bdo>' + translateThis('Details:') + '</bdo>' + listing.message;
      const message2 = document.createElement('p');
      if (typeof listing.contact !== 'undefined') {
        message2.innerHTML = '<bdo>' + translateThis('Contact information:') + '</bdo>' + listing.contact;
      }
      var contact2 = '';
      var datalen = 0;
      var reputation = [0,0,0];
      if(theuser != listing.recipient && listing.recipient != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
        try {
          datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.recipient, 3).call());
          if(datalen > 0) {
            contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.recipient, datalen-1).call()));
            if(typeof contact2 === 'object' && 'mycontact' in contact2) {
              if(listing.contact != contact2['mycontact']) {
                message.innerHTML += '<br><br><bdo>' + translateThis('Recipients contact information:') + '</bdo><br>' + contact2['mycontact'];
              }
            }
          }
          reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(listing.recipient).call())));
          if(reputation[0] == 0 && reputation[1] == 0) {
            message.innerHTML += '<br><br>' + translateThis('Recipient is a new user of the markets.') + '<br>';
          } else {
            message.innerHTML += '<br><br>' + translateThis('Recipients success rate:') + '<br><br><bdo>' + translateThis('Completed:') + '</bdo> ' + reputation[0] + '<br><br><bdo>' + translateThis('Failed:') + '</bdo> ' + reputation[1];
          }
        } catch(e) {
          console.log(e);
        }
      }
      if(theuser != listing.sender && listing.sender != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
        try {
          datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.sender, 3).call());
          if(datalen > 0) {
            contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.sender, datalen-1).call()));
            if(typeof contact2 === 'object' && 'mycontact' in contact2) {
              if(listing.contact != contact2['mycontact']) {
                message.innerHTML += '<br><br><bdo>' + translateThis('Senders contact information:') + '</bdo><br>' + contact2['mycontact'];
              }
            }
          }
          reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(listing.sender).call())));
          if(reputation[0] == 0 && reputation[1] == 0) {
            message.innerHTML += '<br><br>' + translateThis('Sender is a new user of the markets.') + '<br>';
          } else {
            message.innerHTML += '<br><br>' + translateThis('Senders success rate:') + '<br><bdo>' + translateThis('Completed:') + '</bdo> ' + reputation[0] + '<br><bdo>' + translateThis('Failed:') + '</bdo> ' + reputation[1];
          }
        } catch(e) {
          console.log(e);
        }
      }

      const buttonContainer = document.createElement('div');
      buttonContainer.classList.add('button-container');

      if(mode == 0 || mode == 2) {
        const acceptButton = document.createElement('button');
        acceptButton.classList.add('btn-filled');
        acceptButton.innerHTML = translateThis('Accept offer');
        acceptButton.onclick = () => {acceptOffer(listing); popupContainer.remove();};

        const counterButton = document.createElement('button');
        counterButton.classList.add('btn-gray');
        counterButton.innerHTML = translateThis('Counter-offer');
        counterButton.onclick = () => {counterOffer(listing); popupContainer.remove();};

        buttonContainer.appendChild(acceptButton);
        if(parseInt(listing.status[0]) != 2 && parseInt(listing.status[0]) != 3) {
          buttonContainer.appendChild(counterButton);
        }
      }
      if(mode == 1) {
        if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
          const quantityButton = document.createElement('button');
          quantityButton.classList.add("btn-gray");
          quantityButton.innerHTML = translateThis('Update Quantity');
          quantityButton.onclick = async () => {await updateQuantity(listing); popupContainer.remove();};
          buttonContainer.appendChild(quantityButton);
          const feeButton = document.createElement('button');
          feeButton.classList.add("btn-gray");
          feeButton.innerHTML = translateThis('Edit referral fee');
          feeButton.onclick = async () => {await updateFee(listing); popupContainer.remove();};
          buttonContainer.appendChild(feeButton);
        }
        const cancelButton = document.createElement('button');
        cancelButton.classList.add("btn-gray");
        cancelButton.innerHTML = translateThis('Cancel offer');
        cancelButton.onclick = async () => {await cancelOffer(listing); popupContainer.remove();};
        buttonContainer.appendChild(cancelButton);
      }
      if(mode == 2) {
        const cancelButton = document.createElement('button');
        cancelButton.classList.add("btn-gray");
        cancelButton.innerHTML = translateThis('Cancel offer');
        cancelButton.onclick = async () => {await cancelOffer(listing, 1); popupContainer.remove();};
        buttonContainer.appendChild(cancelButton);
      }
      if(mode == 3) {
        imageContainer.style.display = 'none';
        arrowsContainer.style.display = 'none';
        const confirmButton = document.createElement('button');
        confirmButton.classList.add("btn-gray");
        confirmButton.innerHTML = translateThis('Confirm');
        confirmButton.id = 'confirmButton';
        buttonContainer.appendChild(confirmButton);
        const cancelButton = document.createElement('button');
        cancelButton.classList.add("btn-gray");
        cancelButton.innerHTML = translateThis('Cancel');
        cancelButton.id = 'cancelButton';
        buttonContainer.appendChild(cancelButton);
      }
      if(mode == 4) {
        if(listing.expired == 1 || listing.expired == 2) {
          const clearButton = document.createElement('button');
          clearButton.innerHTML = translateThis('Clear Contract');
          clearButton.id = 'clearButton';
          buttonContainer.appendChild(clearButton);
          clearButton.onclick = async function() {
            var returnThis = 0;
            if(listing.expired == 2 && listing.status[0] < 5) {
              Swal.fire({
                title: translateThis('Contract destroyed'),
                text: translateThis('It seems like this deal timed out. If this was due to any disagreement then before you clear the order would you like to report the result to the blockchain for reputation tracking?'),
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
                icon: 'question',
              }).then(async (result) => {
                if (result.isConfirmed) {
                  try {
                    setActionActive(myaccounts+"expireEscrow"+listing.hash, true);
                    if(accountprivkey != "") {
                      const gasEstimate = 100000;
                      var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                      if(!res) {
                        return;
                      }
                    }
                    showLoader();
                    await DDEcontract.methods.expireEscrow(listing.hash, theuser).send({ "from": myaccounts, ...gasOptions[gasSetting] });
                    hideLoader();
                    await Swal.fire(translateThis("Transaction result registered!"));
                    popupContainer.remove();
                    returnThis = 1;
                  } catch (error) {
                    console.error(error);
                    hideLoader();
                    await showError(error);
                  } finally {
                    setActionActive(myaccounts+"expireEscrow"+listing.hash, false);
                  }
                }
              });
            }
            if(returnThis==1) {
              return;
            }
            if(theuser == myaccounts) {
              const readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":readmessages3")) || {};
              readMessages[listing.index] = true;
              localStorage.setItem(myaccounts + DDEaddy + ":readmessages3", JSON.stringify(readMessages));
            }
            await loadUser();
            popupContainer.remove();
          };
        } else {
          var skipthis = 0;
          if(listing.timelimit[0] == listing.timelimit[1] && listing.timelimit[1] == listing.timelimit[2]) {
            skipthis = 1
          }
          if(listing.timelimit[1] != 0 && skipthis != 1) {
            if(theuser != listing.sender) {
              const acceptTime = document.createElement('button');
              acceptTime.innerHTML = translateThis('Accept Time Extension Request');
              acceptTime.id = 'acceptTime';
              acceptTime.onclick = async function() {
                try {
                  setActionActive(myaccounts+"acceptExtend"+listing.hash, true);
                  if(accountprivkey != "") {
                    const gasEstimate = 70000;
                    var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                    if(!res) {
                      return;
                    }
                  }
                  showLoader();
                  await DDEcontract.methods.requestExtension(listing.hash, theuser, listing.timelimit[1]).send({ "from": myaccounts, ...gasOptions[gasSetting] });
                  hideLoader();
                  await Swal.fire(translateThis("Time extended!"));
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                  hideLoader();
                  await showError(error);
                } finally {
                  setActionActive(myaccounts+"acceptExtend"+listing.hash, false);
                }
              }
              buttonContainer.appendChild(acceptTime);
            }
          }
          if(listing.timelimit[2] != 0 && skipthis != 1) {
            if(theuser == listing.sender) {
              const acceptTime = document.createElement('button');
              acceptTime.innerHTML = translateThis('Accept Time Extension Request');
              acceptTime.id = 'acceptTime';
              acceptTime.onclick = async function() {
                try {
                  setActionActive(myaccounts+"acceptExtend"+listing.hash, true);
                  if(accountprivkey != "") {
                    const gasEstimate = 70000;
                    var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                    if(!res) {
                      return;
                    }
                  }
                  showLoader();
                  await DDEcontract.methods.requestExtension(listing.hash, theuser, listing.timelimit[2]).send({ "from": myaccounts, ...gasOptions[gasSetting] });
                  hideLoader();
                  await Swal.fire(translateThis("Time extended!"));
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                  hideLoader();
                  await showError(error);
                } finally {
                  setActionActive(myaccounts+"acceptExtend"+listing.hash, false);
                }
              }
              buttonContainer.appendChild(acceptTime);
            }
          }
          const extendTime = document.createElement('button');
          extendTime.classList.add('btn-gray');
          extendTime.innerHTML = translateThis('Request Time Extension');
          extendTime.id = 'extendTime';
          extendTime.onclick = async function() {
            try {
              const dialog = document.createElement("div");
              dialog.innerHTML = `
                <div>` + translateThis('Please enter the number of days you wish to extend:') + `<br></div>
                  <input id="new-time" type="number" min="1"></input><br><br>
                <div>
                  <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
                  <button id="cancel-btn">` + translateThis('Cancel') + `</button>
                </div>
              `;
              dialog.style.display = "block";
              dialog.style.position = "fixed";
              dialog.style.zIndex = 999;
              dialog.style.backgroundColor = "white";
              dialog.style.padding = "20px";
              dialog.style.borderRadius = "10px";
              dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
              dialog.style.top = "50%";
              dialog.style.left = "50%";
              dialog.style.transform = "translate(-50%, -50%)";

              document.body.appendChild(dialog);

              const confirmBtn = dialog.querySelector("#confirm-btn");
              const cancelBtn = dialog.querySelector("#cancel-btn");
              cancelBtn.addEventListener("click", async () => {
                dialog.remove();
              });

              confirmBtn.addEventListener("click", async () => {
                const newtime = parseInt(listing.timelimit[0]) + parseInt(parseInt(dialog.querySelector("#new-time").value) * 24 * 60 * 60);
                dialog.remove();
                setActionActive(myaccounts+"requestExtend"+listing.hash, true);
                if(accountprivkey != "") {
                  const gasEstimate = 70000;
                  var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                  if(!res) {
                    return;
                  }
                }
                showLoader();
                await DDEcontract.methods.requestExtension(listing.hash, theuser, newtime).send({ "from": myaccounts, ...gasOptions[gasSetting] });
                hideLoader();
                await Swal.fire(translateThis("Time extension requested!"));
                await loadUser();
                popupContainer.remove();
              });
            } catch (error) {
              hideLoader();
              console.error(error);
              await showError(error);
            } finally {
              setActionActive(myaccounts+"requestExtend"+listing.hash, false);
            }
          }
          buttonContainer.appendChild(extendTime);
          const cancelButton = document.createElement('button');
          cancelButton.classList.add('btn-gray');
          cancelButton.innerHTML = translateThis('Cancel Contract');
          cancelButton.id = 'cancelButton';
          cancelButton.onclick = async function() {
            try {
              if(theuser == listing.sender) {
                if(listing.status[1] == 2) {
                  await Swal.fire(translateThis("Contract cancellation request was already sent!"));
                  return;
                }
              } else {
                if(listing.status[1] == 3) {
                  await Swal.fire(translateThis("Contract cancellation request was already sent!"));
                  return;
                }
              }
              setActionActive(myaccounts+"requestCancel"+listing.hash, true);
              if(accountprivkey != "") {
                const gasEstimate = 70000;
                var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                if(!res) {
                  return;
                }
              }
              showLoader();
              await DDEcontract.methods.cancelEscrow(listing.hash, theuser).send({ "from": myaccounts, ...gasOptions[gasSetting] });
              hideLoader();
              if (listing.status[1] == 1) {
                await Swal.fire(translateThis("Contract cancellation request sent!"));
              } else {
                await Swal.fire(translateThis("Contract cancelled!"));
              }
              await loadUser();
              popupContainer.remove();
            } catch (error) {
              console.error(error);
              hideLoader();
              await showError(error);
            } finally {
              setActionActive(myaccounts+"requestCancel"+listing.hash, false);
            }
          }
          buttonContainer.appendChild(cancelButton);
          const confirmButton = document.createElement('button');
          confirmButton.classList.add('btn-gray');
          confirmButton.innerHTML = translateThis('Complete Contract');
          confirmButton.id = 'confirmButton';
          confirmButton.onclick = async function() {
            try {
                  if(theuser == listing.sender) {
                    if(listing.status[0] == 2) {
                  await Swal.fire(translateThis("Contract completion request was already sent!"));
                  return;
                }
              } else {
                    if(listing.status[0] == 3) {
                  await Swal.fire(translateThis("Contract completion request was already sent!"));
                  return;
                }
              }
              setActionActive(myaccounts+"requestComplete"+listing.hash, true);
              if(accountprivkey != "") {
                    const gasEstimate = 150000;
                    var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
                    if(!res) {
                      return;
                    }
              }
              showLoader();
              await DDEcontract.methods.completeEscrow(listing.hash, theuser).send({ "from": myaccounts, ...gasOptions[gasSetting] });
              hideLoader();
              if (listing.status[1] == 1) {
                await Swal.fire(translateThis("Contract completion request sent!"));
              } else {
                await Swal.fire(translateThis("Contract completed!"));
              }
              await loadUser();
              popupContainer.remove();
            } catch (error) {
              console.error(error);
              hideLoader();
              await showError(error);
            } finally {
              setActionActive(myaccounts+"requestComplete"+listing.hash, false);
            }
          }
          buttonContainer.appendChild(confirmButton);
        }
      }

      details.appendChild(sender);
      details.appendChild(recipient);
      details.appendChild(token);
      details.appendChild(amount);
      details.appendChild(depositSender);
      details.appendChild(depositRecipient);
      details.appendChild(quantity);
      details.appendChild(timelimit);
      if(listing.rfee != 0) {
        details.appendChild(theFee);
      }
      if(listing.referred != "0x0000000000000000000000000000000000000000") {
        details.appendChild(theReferred);
      }
      if(listing.tags && listing.tags.length != 0) {
        details.appendChild(theTags);
      }

      if(mode == 4) {
        timelimit.innerHTML = "<bdo>" + translateThis('Time Until Funds Expire:') + '</bdo> ' + listing.timeRemaining + ' <bdo>' + translateThis('days') + "</bdo>";
        const extra = document.createElement('p');
        extra.innerHTML = '<br><bdo>' + translateThis('Notifications:') + '</bdo><br>' + listing.escrowInfo;
        details.appendChild(extra)
      }
      message.style.whiteSpace = 'normal';
      details.appendChild(message);
      details.appendChild(message2);

      const topBar = document.createElement('div');
      topBar.classList.add('fav-icons-wrapper');
      if(mode == 0 && (listing.sender=="0x0000000000000000000000000000000000000000" || listing.recipient=="0x0000000000000000000000000000000000000000" )) {
        const starButton = document.createElement('span');
        starButton.style.fontSize = "20px";
        starButton.innerHTML = '&star;';
        starButton.classList.add('favorites-button2');
        starButton.style.left = 10;
        if(myFavorites.includes(listing.hash)) {
          starButton.style.color = "#ed5f00";
          starButton.innerHTML = '&bigstar;';
        }
        starButton.onclick = function() {
          if(myFavorites.includes(listing.hash)) {
            myFavorites.splice(myFavorites.indexOf(listing.hash),1);
            starButton.innerHTML = '&star;';
          } else {
            myFavorites.push(listing.hash);
            starButton.innerHTML = '&bigstar;';
            starButton.style.color = "#ed5f00";
          }
          checkFavorites();
          localStorage.setItem(myaccounts + DDEaddy + ':myFavorites', JSON.stringify(myFavorites));
        };
        // starButton.onclick = function () {
        //   const isFavorited = myFavorites.includes(listing.hash);
        //   if (isFavorited) {
        //     // Remove from favorites
        //     myFavorites.splice(myFavorites.indexOf(listing.hash), 1);
        //     starButton.innerHTML = '&star;';
        //     starButton.style.color = ""; // Reset color to default
        //   } else {
        //     // Add to favorites
        //     myFavorites.push(listing.hash);
        //     starButton.innerHTML = '&bigstar;';
        //     starButton.style.color = "#ed5f00";
        //   }
        //   // Update favorites in local storage
        //   localStorage.setItem(myaccounts + DDEaddy + ':myFavorites', JSON.stringify(myFavorites));
        //   checkFavorites();

        //   // If the current view is set to show favorites, remove the listing from view if unfavorited
        //   // if (isFavorited && currentView === 'favorites') {
        //   //     removeListingFromView(listing);
        //   // }
        // };
        starButton.addEventListener('mouseover', function () {
          this.style.cursor = 'pointer';
        });
        starButton.addEventListener('mouseout', function() {
          this.style.cursor = 'auto';
        });
        topBar.appendChild(starButton);

        const linkButton = document.createElement('span');
        linkButton.style.fontSize = "15px";
        linkButton.innerHTML = '&#128279;';
        linkButton.classList.add('favorites-button3');
        linkButton.style.left = 50;
        linkButton.addEventListener('mouseover', function() {
          this.style.cursor = 'pointer';
        });
        linkButton.addEventListener('mouseout', function() {
          this.style.cursor = 'auto';
        });
        linkButton.onclick = function() {
          var currentURL = new URL(window.location.href);
          var newUrl = window.location.href;
          // Check if the current URL already has queries
          if (newUrl.indexOf('?') !== -1) {
            if (currentURL.searchParams.has('o')) {
              currentURL.searchParams.set('o', encodeURIComponent(listing.hash));
              newUrl = currentURL.href;
            } else {
              newUrl += '&o=' + encodeURIComponent(listing.hash);
            }
          } else {
            // If there are no queries, add the first query
            newUrl = newUrl.endsWith('/') ? newUrl : newUrl + '/';
            newUrl += '?o=' + encodeURIComponent(listing.hash);
          }
          // Create a text area for manual copying
          const textArea = document.createElement('textarea');
          textArea.value = newUrl;
          textArea.style.position = 'fixed'; // Make it invisible and fixed to avoid interference
          document.body.appendChild(textArea);
          textArea.select();
          try {
            // Attempt to execute the copy command
            document.execCommand('copy');

            // Show a success message
            Swal.fire({
              icon: 'success',
              title: translateThis('URL Copied'),
              text: translateThis('The modified URL has been copied to the clipboard.'),
            });
          } catch (err) {
            console.error('Copy command failed:', err);
            Swal.fire({
              icon: 'info',
              title: translateThis('Copy Manually'),
              text: translateThis('The modified URL is:') + '\n\n' + newUrl + '\n\n' + translateThis('Please copy it manually.'),
            });
          } finally {
            // Clean up: remove the temporary text area
            document.body.removeChild(textArea);
          }
        };
        topBar.appendChild(linkButton);
      }
      var notesButton = document.createElement('span');
      notesButton.innerHTML = '&#128221;';
      notesButton.style.fontSize = "15px";
      notesButton.classList.add('favorites-button3');
      notesButton.style.marginLeft = "10px";
      notesButton.addEventListener('mouseover', function() {
        this.style.cursor = 'pointer';
      });
      notesButton.addEventListener('mouseout', function() {
        this.style.cursor = 'auto';
      });
      notesButton.onclick = function() {
        const existingNotes = localStorage.getItem(myaccounts + DDEaddy +'notes_' + listing.hash) || '';
        Swal.fire({
          title: translateThis('Enter your notes for this offer'),
          input: 'textarea',
          inputValue: existingNotes,
          showCancelButton: true,
          confirmButtonText: translateThis('Save'),
          cancelButtonText: translateThis('Cancel'),
        }).then((result) => {
          if (result.isConfirmed && result.value !== undefined) {
            localStorage.setItem(myaccounts + DDEaddy +'notes_' + listing.hash, result.value);
            Swal.fire({
              icon: 'success',
              title: translateThis('Notes Saved'),
              text: translateThis('Your notes have been saved successfully.'),
            });
          }
        });
      };

      const messageButton = document.createElement('span');
      messageButton.innerHTML = '&#9993;'; // Unicode for envelope (message icon)
      messageButton.classList.add('message-button');
      messageButton.style.fontSize = "20px";
      messageButton.style.marginLeft = "10px";

      const messageCountIndicator = document.createElement('span');
      messageCountIndicator.classList.add('message-count-indicator');
      messageCountIndicator.style.display = 'none'; // Hide initially
      messageButton.appendChild(messageCountIndicator);

      messageButton.addEventListener('mouseover', function() {
        this.style.cursor = 'pointer';
      });
      messageButton.addEventListener('mouseout', function() {
        this.style.cursor = 'auto';
      });
      if(mode !== 3){
        topBar.appendChild(notesButton);
        if(listing.sender != "0x0000000000000000000000000000000000000000" && listing.recipient != "0x0000000000000000000000000000000000000000" ) {
          topBar.appendChild(messageButton);
        }
      }
      topBar.appendChild(closeButton);
      popup.appendChild(topBar);
      popup.appendChild(popupWrapper);
      popupWrapper.appendChild(imageContainer);
      popupWrapper.appendChild(downloadContainer);
      details.style.whiteSpace = 'nowrap';
      details.style.marginRight = '10px';
      details.style.marginLeft = '10px';
      popupWrapper.appendChild(details);
      popupWrapper.appendChild(buttonContainer);
      popupContainer.appendChild(popup);

      document.body.appendChild(popupContainer);

      if(mode !== 3) {
        const hash = listing.hash;
        const statusKey = listing.status.join(',');

        const validStatusesForMessaging = ["1,0", "0,1", "1,1", "1,2", "2,1", "1,3", "3,1", "2,2", "2,3", "3,2", "3,3"];
        const isStatusValid = validStatusesForMessaging.includes(statusKey);

        // Simulate contract checks
        const isParticipant = (listing.sender === theuser || listing.recipient === theuser);
        const isContractActive = (listing.status[0] < 4 && listing.status[1] < 4);
        const isLoggedIn = (myaccounts !== "");

        messageButton.onclick = async function() {
          messageCountIndicator.style.display = 'none';
          if (isStatusValid && isContractActive && isLoggedIn) {
            messageButton.style.display = 'inline-flex';
            await fetchMessages(listing.hash, theuser);
          } else {
            messageButton.style.display = 'none';
          }

          if(theuser == listing.sender) {
            var recipientAddress = listing.recipient;
            var senderAddress = listing.sender;
          } else {
            var senderAddress = listing.recipient;
            var recipientAddress = listing.sender;
          }
          const { supportsEncryption: recipientSupportsEncryption, publicKey: recipientPublicKey } = await userSupportsEncryption(recipientAddress);
          const { supportsEncryption: senderSupportsEncryption } = await userSupportsEncryption(senderAddress);
          if(!isParticipant) {
            senderSupportsEncryption = false;
          }          
          if (!recipientSupportsEncryption && !senderSupportsEncryption) {
            Swal.fire({
              icon: 'warning',
              title: translateThis('Encryption Not Supported by Both Parties'),
              text: translateThis('Neither you nor the recipient support encryption. Any private messages sent will be visible to anyone.'),
              showCancelButton: true,
              confirmButtonText: translateThis('Send Anyway'),
              cancelButtonText: translateThis('Cancel'),
            }).then(async (result) => {
              if (result.isConfirmed) {
               await handleSendMessage(listing.hash, recipientAddress, false, null, listing.sender, listing.recipient);
              }
            });
          } else if (!recipientSupportsEncryption) {
            Swal.fire({
              icon: 'warning',
              title: translateThis('Recipient Does Not Support Encryption'),
              text: translateThis('Please be aware, the recipient does not support encryption. Any private messages sent will be visible to anyone.'),
              showCancelButton: true,
              confirmButtonText: translateThis('Send Anyway'),
              cancelButtonText: translateThis('Cancel'),
            }).then(async (result) => {
              if (result.isConfirmed) {
                await handleSendMessage(listing.hash, recipientAddress, false, null, listing.sender, listing.recipient);
              }
            });
          } else if (!senderSupportsEncryption) {
            Swal.fire({
              icon: 'warning',
              title: translateThis('Your Encryption Key is Not Registered'),
              text: translateThis('Warning: your encryption key is not registered, messages you receive will be visible to everyone.'),
              showCancelButton: true,
              confirmButtonText: translateThis('Send Anyway'),
              cancelButtonText: translateThis('Cancel'),
            }).then(async (result) => {
              if (result.isConfirmed) {
                await handleSendMessage(listing.hash, recipientAddress, recipientSupportsEncryption, recipientPublicKey, listing.sender, listing.recipient);
              }
            });
          } else {
            await handleSendMessage(listing.hash, recipientAddress, true, recipientPublicKey, listing.sender, listing.recipient);
          }
        };
      }

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        
      `;
      document.head.appendChild(style);
      //SimpleScrollbar.initEl(popup);

      if(myimgs.length !== 0) {
        showSlides(1);
      }
      if(mode == 3) {
        return new Promise(resolve => {
          const confirmButton = buttonContainer.querySelector("#confirmButton");
          const cancelButton = buttonContainer.querySelector("#cancelButton");

          confirmButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(true);
          });

          cancelButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(false);
          });
        });
      }
    }

   
    async function handleSendMessage(hash, recipient, encrypt = false, recipientPublicKey = null, listingSender, listingRecipient) {
      const existingMessages = await fetchMessages(hash, recipient);
      const messagesContainer = createMessagePopup(existingMessages, listingSender, listingRecipient);      

      const messagePopup = document.querySelector('.popup-container');
      messagePopup.appendChild(messagesContainer);
      messagesContainer.style.display = 'block';

      const input = messagesContainer.querySelector('textarea');
      const sendButton = messagesContainer.querySelector('button');      

      sendButton.onclick = async () => {
        try {
          const message = input.value;
          let finalMessage = message;
          let storedMessage = message; // Message to store locally in plaintext

          if (encrypt && recipientPublicKey) {
            const timestamp = new Date().getTime();
            const padding = Crypto.SHA256(timestamp).substring(0, 16);
            finalMessage = "ENC:" + cryptico.encrypt(message + "#*#*#" + timestamp + padding, recipientPublicKey, userprivkey).cipher;
          }

          // Encrypt message for local storage if sender's public key is available
          if (userpubkey != "") {
            const timestamp = new Date().getTime();
            const padding = Crypto.SHA256(timestamp).substring(0, 16);
            storedMessage = "ENC:" + cryptico.encrypt(message + "#*#*#" + timestamp + padding, userpubkey).cipher;
          }
          setActionActive(myaccounts+"sendMessage"+finalMessage, true);
          showLoader();
          var mslen = parseInt(DOMPurify.sanitize(await DDEcontract.methods.getMessageLength(hash, listingSender).call())) + 1;
          const sendResult = await DDEcontract.methods.sendMessage(hash, listingSender, finalMessage).send({ from: myaccounts });
          if (sendResult) {
              const newMessage = {
                  message: storedMessage,
                  sender: listingSender,
                  timestamp: new Date().getTime(),
                  index: mslen + ":" + listingSender
              };
              if (!existingMessages.some(msg => msg.timestamp === newMessage.timestamp && msg.message === newMessage.message)) {
                  existingMessages.push(newMessage);
                  localStorage.setItem(myaccounts + DDEaddy + hash + 'messages', JSON.stringify(existingMessages));
              }
          }
          hideLoader();
          Swal.fire({
            icon: 'success',
            title: translateThis('Message Sent'),
            text: translateThis('Your message has been sent successfully.'),
          });

          input.value = '';
          messagesContainer.remove();
        } catch (error) {
          hideLoader();
          console.error(error);
          await showError(error);
          messagesContainer.remove();
          console.error('Failed to send message:', error);
        } finally {
          hideLoader();
          setActionActive(myaccounts+"sendMessage"+finalMessage, false);
          messagesContainer.remove();
        }
      }
    }


    function createMessagePopup(messages, sender, recipient) {
      const decryptedMessages = messages.map(msg => {
          if (userpubkey != "" && msg.message.startsWith("ENC:")) {
              const encryptedPart = msg.message.substring(4);
              const decryptionResult = cryptico.decrypt(encryptedPart, userprivkey);
              if (decryptionResult.status === "success") {
                  const messageParts = decryptionResult.plaintext.split("#*#*#");
                  if (messageParts.length === 2) {
                    const timestampAndPadding = messageParts[1];
                    const timestamp = timestampAndPadding.slice(0, 13);
                    const padding = timestampAndPadding.slice(13);
                    if (padding.length === 16 && !isNaN(timestamp)) {
                      return { ...msg, message: messageParts[0] }; // Only return the actual message part
                    } else {
                      console.error("Invalid padding or timestamp length");
                      return { ...msg, message: "Failed to decrypt message" };
                    }
                  } else {
                    console.error("Invalid padding length");
                    return { ...msg, message: "Failed to decrypt message" };
                  }
              } else {
                  console.error("Decryption failed:", decryptionResult.status);
                  return { ...msg, message: "Failed to decrypt message" };
              }
          } else {
              return msg; // Return the plaintext message if not encrypted
          }
      });

      const popup = document.createElement('div');
      popup.className = 'message-popup';
      popup.innerHTML = `
          <div class="message-header">
            ${translateThis('Messages')}
            <span class="close-btn">&times;</span>
          </div>
          <div class="message-body">
            <div class="message-body-inner">
              ${decryptedMessages.sort((a, b) => a.timestamp - b.timestamp).map(msg => {
                  const isCurrentUser = msg.sender === myaccounts;
                  const messageClass = isCurrentUser ? 'message-sender' : 'message-receiver';
                  const displayName = isCurrentUser 
                      ? (sender === myaccounts ? translateThis('Sender (You)') : translateThis('Recipient (You)')) 
                      : (sender === msg.sender ? translateThis('Sender') : translateThis('Recipient'));
                  return `<p class="${messageClass}"><b>${displayName}:</b> ${msg.message}</p>`;
              }).join('')}
            </div>
            <textarea placeholder="${translateThis('Type your message here...')}"></textarea>
            <button>${translateThis('Send')}</button>
          </div>
      `;

      // Close button functionality
      popup.querySelector('.close-btn').onclick = function() {
          popup.remove();
      };

      return popup;
    }


    async function fetchMessages(hash, user) {
      var startIndex = localStorage.getItem(myaccounts + DDEaddy + hash + user + 'lastMessageIndex') || 0;
      let storedMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + hash + 'messages') || '[]');
      let index = parseInt(startIndex);
      let newMessagesFetched = false;
      let unreadMessageCount = 0;

      try {
          var mslen = parseInt(DOMPurify.sanitize(await DDEcontract.methods.getMessageLength(hash, user).call()));
          while (index < mslen) {
              const message = DOMPurify.sanitize(await DDEcontract.methods.messages(hash, user, index).call());
              if (!message) break;
              var msgtimestamp =  new Date().getTime();
              let decryptedMessage = message;
              if (message.startsWith("ENC:")) {
                const decryptionResult = cryptico.decrypt(message.substring(4), userprivkey);
                if (decryptionResult.status === "success") {
                  const messageParts = decryptionResult.plaintext.split("#*#*#");
                  if (messageParts.length === 2) {
                      const timestampAndPadding = messageParts[1];
                      msgtimestamp = timestampAndPadding.slice(0, 13);
                      const padding = timestampAndPadding.slice(13);
                      if (padding.length === 16 && !isNaN(timestamp)) {
                          decryptedMessage = messageParts[0];
                      } else {
                          console.error("Invalid padding or timestamp length");
                          decryptedMessage = "Failed to decrypt message";
                      }
                  } else {
                      console.error("Invalid message format");
                      decryptedMessage = "Failed to decrypt message";
                  }
                } else {
                    console.error("Decryption failed:", decryptionResult.status);
                    decryptedMessage = "Failed to decrypt message";
                }
              }
              if (!storedMessages.some(msg => msg.index === index+":"+user)) {
                  storedMessages.push({ message: decryptedMessage, sender: user, timestamp: msgtimestamp, index: index+":"+user });
                  newMessagesFetched = true;
                  unreadMessageCount++;
              }
              index++;
          }
      } catch (error) {
          console.error('Error fetching messages:', error);
      } finally {
          if (newMessagesFetched) {
              localStorage.setItem(myaccounts + DDEaddy + hash + 'messages', JSON.stringify(storedMessages));
              localStorage.setItem(myaccounts + DDEaddy + hash + user + 'lastMessageIndex', index.toString());
              updateMessageCountIndicator(unreadMessageCount);
          }
      }
      return storedMessages;
    }

    function updateMessageCountIndicator(count) {
      const indicator = document.querySelector('.message-count-indicator');
      if (count > 0) {
        indicator.textContent = count;
        indicator.style.display = 'inline-block';
      } else {
        indicator.style.display = 'none';
      }
    }
   
    function removeListingFromView(listing) {
      const listingElement = document.querySelector(`#listing-${listing.hash}`); // Assuming listings have an ID based on their hash
      if (listingElement) {
        listingElement.remove();
      }
    }

    async function deposit(skipthis = 0) {
      if (!isConnected) {
        await Swal.fire(translateThis("Please Login/Connect to Continue."));
        return;
      }
      if (!myaccounts || myaccounts.length === 0 || balances['base'] === undefined) {
        await Swal.fire(translateThis("Please wait for your account data to load."));
        return;
      }
      if(accountprivkey != "" && skipthis == 0) {
        var depOptions = 0;
        const tokenNames = tokens.map(token => token.token);
        await Swal.fire({
          title: translateThis('Select Token:'),
          input: 'select',
          inputOptions: tokenNames.reduce((acc, tokenName) => {
            acc[tokenName] = tokenName;
            return acc;
          }, {}),
          inputPlaceholder: 'Select a token',
          showCancelButton: true,
          inputValidator: (value) => {
            if (!value) {
              return 'You need to choose a token';
            }
          }
        }).then(async (result) => {
          console.log(result.value);
          var baseBal = 0;
          try {
            for(let i=0; i<tokens.length; i++) {
              if(tokens[i].token == result.value) {
                if(i != 0) {
                  if(parseInt(balances[tokens[i].address].amount2) != 0) {
                    baseBal = 1;
                  }
                  if(parseInt(balances['base'].amount) == 0) {
                    await Swal.fire({
                      title: translateThis('Deposit'),
                      html: translateThis('Please be aware that to transact in alternative coins you should also deposit the base currency to be able to process gas fees.') + "<br><br>" + translateThis('Base currency:') + " " + tokens[0].token
                    });
                  }
                } else {
                  if(parseInt(balances['base'].amount) != 0) {
                    baseBal = 1;
                  }
                }
                break;
              }
            }
          } catch (e) {
            await Swal.fire(translateThis("Not connected."));
            return; 
          }
          if (result.isConfirmed) {            
            if(baseBal != 0) {
              result2 = await Swal.fire({
                title: translateThis('Deposit'),
                text: translateThis("You have funds in your wallet. The wallet funds are not able to be used for contracts until they are moved directly to the markets/trading account. For the base currency some funds are needed for gas(paid from the wallet) and some are used for contracts(paid from the markets/trading account). For altcoins it's recommended to move all of the funds to the trading account."),                
                confirmButtonText: translateThis("Move funds from wallet to trading/markets account."),
                cancelButtonText: translateThis("Show wallet address for receiving more funds"),
                showCancelButton: true
              });
              if(result2.isConfirmed) {
                depOptions = 1;
              }
            }
            if(depOptions == 0) {
              await Swal.fire({
                title: translateThis('Deposit'),
                html: `
                  <div>
                    ${translateThis('Please deposit to the following address:')}<br>
                    <span style="font-size: 11px;">${myaccounts}</span><br>
                  </div>
                `,
                showCancelButton: true,
                showConfirmButton: true,
                confirmButtonText: translateThis("Copy to Clipboard"),
                cancelButtonText: translateThis("Cancel"),
                preConfirm: () => {
                  // Copy address to clipboard logic here
                  const textarea = document.createElement('textarea');
                  textarea.value = myaccounts;
                  document.body.appendChild(textarea);
                  textarea.select();
                  document.execCommand('copy');
                  document.body.removeChild(textarea);
                }
              });
            }
          }
        });
        if(depOptions == 0) {
          return;
        }
      }
      // Populate the token select dropdown for Swal
      const tokenOptions = tokens.map((token, index) => ({
        value: index,
        text: token.token,
      }));
      // Show Swal modal
      const { value: formValues, isConfirmed } = await Swal.fire({
        customClass: "withdraw-swal-wrapper",
        title: translateThis('Deposit tokens to your balance'),
        html:
          `<select id="token-select2" class="swal2-input">
             ${tokenOptions.map(option => `<option value="${option.value}">${option.text}</option>`).join('')}
           </select>
           <input id="amount-input2" class="swal2-input" placeholder=${translateThis('Amount:')}>`,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: translateThis('Deposit'),
        cancelButtonText: translateThis('Cancel'),
        preConfirm: () => {
          const selectedIndex = document.getElementById('token-select2').value;
          const amount = document.getElementById('amount-input2').value;
          if (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
            Swal.showValidationMessage(translateThis('Please enter a valid destination and a positive amount.'));
            return false;
          }
          return { selectedIndex, amount };
        }
      });
      if (isConfirmed && formValues) {
        var { selectedIndex, amount } = formValues;
        var token = tokens[selectedIndex].token;
        var tokenAddress = tokens[selectedIndex].address;
        var decimals = parseInt(tokens[selectedIndex].decimals);
        if (token === tokens[0].token) {
          // If the selected token is ETH/BASE, deposit WETH instead
          try {
            var value = web3.utils.toWei(amount.toString(), 'ether');
            if(accountprivkey != "") {
              const gasEstimate = 90000;
              var res = await confirmTransaction(gasEstimate, value, tokenAddress);
              if(!res) {
                return;
              }
            }
            setActionActive(myaccounts+"depositWETH"+value, true);
            showLoader();
            await DDEcontract.methods.depositWETH().send({ "from": myaccounts, "value": value, ...gasOptions[gasSetting] });
            hideLoader();
            await Swal.fire(translateThis("Deposit success!"));
            await loadUser();
          } catch (error) {
            hideLoader();
            console.error(error);
            await showError(error);
          } finally {
            setActionActive(myaccounts+"depositWETH"+value, false);
          }
        } else {
          // If the selected token is not ETH, deposit the selected token
          try {
            // var tokenContract = new web3.eth.Contract(ERC20abi, tokenAddress);
            // var allowance = DOMPurify.sanitize(await tokenContract.methods.allowance(myaccounts, DDEaddy).call());
            var value = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toString()
            setActionActive(myaccounts+"deposit"+tokenAddress+value, true);
            await getApproval(tokenAddress, value);
            if(accountprivkey != "") {
                const gasEstimate = 90000;
                var res = await confirmTransaction(gasEstimate, value, tokenAddress);
                if(!res) {
                  return;
              }
            }
            showLoader();
            await DDEcontract.methods.deposit(tokenAddress, value).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            await Swal.fire(translateThis("Deposit success!"));
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            popupContainer.remove();
            console.error(error);
            hideLoader();
            await showError(error);
          } finally {
            popupContainer.remove();
            setActionActive(myaccounts+"deposit"+tokenAddress+value, false);
          }
        }
      };
    }

    async function getApproval(tokenAddress, value) {
      if(tokennames[tokenAddress] != tokens[0].token) {
        var tokenContract = new web3.eth.Contract(ERC20abi, tokenAddress);
        var allowance = DOMPurify.sanitize(await tokenContract.methods.allowance(myaccounts, DDEaddy).call());
        if (web3.utils.toBN(allowance).lt(web3.utils.toBN(value))) {
          await Swal.fire(translateThis("Waiting for approval..."));
          await tokenContract.methods.approve(DDEaddy, web3.utils.toHex(web3.utils.toBN(2).pow(web3.utils.toBN(256)).sub(web3.utils.toBN(1)))).send({"from":myaccounts,...gasOptions[gasSetting]});
        }
      }
    }
      
    async function confirmTransaction(gasEstimate, value, tokenAddress) {
      var mybase = web3.utils.toBN(balances['base'].amount);
      var glimit = web3.utils.toBN(gasOptions[gasSetting].gasLimit).mul(web3.utils.toBN(gasPrice));
      if(mybase.lt(glimit)) {
        await Swal.fire({title: translateThis("Not enough funds"), html: translateThis("Please deposit funds to cover the minimum gas limit. This amount is needed to process all types of transactions. However, transactions will usually cost less than this limit.") + "<br><br>" + "Gas limit:" + " " + gasOptions[gasSetting].gasLimit + "<br>" + "Gas price:" + " " + gasPrice + "<br>" + "Minimum cost:" + " " + displayDecimals(tokens[0].address,glimit.toString()) + " " + tokens[0].token});
        return false;
      }
      const confirmation = await Swal.fire({
        title:  translateThis('Confirm Transaction'),
        html:  translateThis('Estimated gas cost:') + " " + gasEstimate + '<br>' + translateThis('Gas limit:') + " " + gasOptions[gasSetting].gasLimit + '<br>' + translateThis('Gas price:') + " " + gasPrice + '<br>' + translateThis('Estimated fee:') + " " + displayDecimals(tokens[0].address,web3.utils.toBN(gasEstimate).mul(web3.utils.toBN(gasPrice)).toString()) + " " +  tokens[0].token + '<br>' + translateThis('Maximum fee:') + " " + displayDecimals(tokens[0].address,glimit.toString()) + " " +  tokens[0].token + '<br>' + translateThis('Total(in coins):') + " " + displayDecimals(tokenAddress, value.toString()) + " " + tokennames[tokenAddress],
        showCancelButton: true,
        confirmButtonText: translateThis('Submit'),
        cancelButtonText: translateThis('Cancel'),
      });
      if (confirmation.isConfirmed) {
        return true;
      }
      return false;
    }

    async function withdraw() {
      if (!isConnected) {
        await Swal.fire(translateThis("Please Login/Connect to Continue."));
        return;
      }
      if (!myaccounts || myaccounts.length === 0 || balances['base'] === undefined) {
        await Swal.fire(translateThis("Please wait for your account data to load."));
        return;
      }
      // Populate the token select dropdown for Swal
      const tokenOptions = tokens.map((token, index) => ({
        value: index,
        text: token.token,
      }));

      // Show Swal modal
      const { value: formValues, isConfirmed } = await Swal.fire({
        customClass: "withdraw-swal-wrapper",
        title: translateThis('Withdraw tokens from your balance'),
        html:
          `<select id="token-select3" class="swal2-input">
             ${tokenOptions.map(option => `<option value="${option.value}">${option.text}</option>`).join('')}
           </select>
           <input id="amount-input3" class="swal2-input" placeholder=${translateThis('Amount:')}>
           <input id="destination-input" class="swal2-input" placeholder=${translateThis('Recipient:')}>`,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: translateThis('Withdraw'),
        cancelButtonText: translateThis('Cancel'),
        preConfirm: () => {
          const selectedIndex = document.getElementById('token-select3').value;
          const amount = document.getElementById('amount-input3').value;
          const destination = document.getElementById('destination-input').value;
          // Validate destination is not blank, amount is a valid number, and amount is greater than zero
          if (destination.trim() === '' || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0 || !(/^(0x)?[0-9a-fA-F]{40}$/.test(destination))) {
            Swal.showValidationMessage(translateThis('Please enter a valid destination and a positive amount.'));
            return false;
          }
          return { selectedIndex, amount, destination };
        }
      });

      if (isConfirmed && formValues) {
        const { selectedIndex, amount, destination } = formValues;
        const tokenAddress = tokens[selectedIndex].address;
        const decimals = parseInt(tokens[selectedIndex].decimals);
        const value = (new BigNumber(amount).times(new BigNumber(10).pow(decimals))).toFixed(0);
        try {
          setActionActive(myaccounts+"withdraw"+tokenAddress+value, true);
          if(accountprivkey == "") {
            showLoader();
            await DDEcontract.methods.withdraw(tokenAddress, value, destination).send({"from":myaccounts,...gasOptions[gasSetting]});
            hideLoader();
          } else {
            if(web3.utils.toBN(value).lte(web3.utils.toBN(balances[tokenAddress].amount))) {
              const gasEstimate = 70000;
              var res = await confirmTransaction(gasEstimate, value, tokenAddress);
              if(!res) {
                return;
              }
              showLoader();              
              await DDEcontract.methods.withdraw(tokenAddress, value, destination).send({"from":myaccounts,...gasOptions[gasSetting]});
              hideLoader();
            } else {
              const gasEstimate = 120000;
              var res = await confirmTransaction(gasEstimate, value, tokenAddress);
              if(!res) {
                return;
              }
              showLoader();
              await getApproval(tokenAddress, value);
              hideLoader();
              var myval = "0";
              var difference = web3.utils.toBN(value).sub(web3.utils.toBN(balances[tokenAddress].amount));
              if(tokennames[tokenAddress] == tokens[0].token) {
                var mybase = web3.utils.toBN(balances['base'].amount);
                var glimit = web3.utils.toBN(gasOptions[gasSetting].gasLimit).mul(web3.utils.toBN(gasPrice));
                if(mybase.lt(difference.add(glimit))) {
                  await Swal.fire(translateThis("Not enough funds"));
                  return;
                }
                myval = difference.toString();
              }
              showLoader();
              await DDEcontract.methods.depositAndWithdrawal(tokenAddress, difference.toString(), tokenAddress, value, destination).send({"from":myaccounts,"value":myval,...gasOptions[gasSetting]});
              hideLoader();
            }
          }
          await Swal.fire(translateThis("Withdraw success!"));
          await loadUser();
        } catch (error) {
          console.error(error);
          hideLoader();
          await showError(error);
        } finally {
          setActionActive(myaccounts+"withdraw"+tokenAddress+value, false);
          hideLoader();
        }
      }
    }

    async function resizeImage(file) {
      // Check if the file is an image
      if (!file.type.startsWith('image/')) {
        return null;
      }

      // Load the image data into an image object
      const img = new Image();

      const base64 = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
      });

      img.src = base64;

      // Wait for the image to load
      await new Promise((resolve) => {
        img.onload = resolve;
      });

      // Check if the image is too large
      const maxSize = 100 * 1024; // 100 KB
      const size = img.width * img.height * 3; // 3 bytes per pixel
      if (size <= maxSize) {
        return img.src;
      }

      // Resize the image using the Canvas API
      const canvas = document.createElement('canvas');
      const scale = Math.sqrt(maxSize / size);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL(file.type, 0.8); // Reduce quality to reduce size
    }

    async function createContract(publicoffer = true, counterdata = {}) {
      if(myaccounts == "") {
        await Swal.fire({title: translateThis("Please Login/connect your wallet to create a contract."), icon: 'warning'});
        return;
      }
      var DDEcontract4 = new web3.eth.Contract(DDEabi, DDEaddy);
          // Fetch user data to check if encryption key and contact info are registered
      const datalen = DOMPurify.sanitize(await DDEcontract4.methods.getArrayLength(myaccounts, 3).call());
      const dontShowAgain = localStorage.getItem('dontShowRegistrationNotification') === 'true';
      if (datalen > 0 && !dontShowAgain) {
        const contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract4.methods.userdata(myaccounts, datalen - 1).call()));
        if (!contact2.mycontact || !contact2.publickey) {
          const response = await Swal.fire({
                title: translateThis("Registration Recommended"),
                text: translateThis("We recommend registering your contact information and encryption key before creating a contract. Would you like to register now?"),
                icon: 'info',
                confirmButtonText: translateThis('Yes'),
                showCancelButton: true,
                cancelButtonText: translateThis('No'),
                footer: '<label><input type="checkbox" id="dontShowAgain"> ' + translateThis("Don't show this again") + '</label>',
            });

            const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
            if (dontShowAgainCheckbox && dontShowAgainCheckbox.checked) {
                localStorage.setItem('dontShowRegistrationNotification', 'true');
            }

            if (response.isConfirmed) {
              await Swal.fire({
                title: translateThis('Register Contact Information and Public Key'),
                html: `
                    <input id="contactInfoInput" class="swal2-input" placeholder="${translateThis('Enter your email/contact information')}">
                    <p>${translateThis('Would you like to register this public key to your account now? This is how users will know how to encrypt their offers to you.')}</p>
                `,
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
                preConfirm: () => {
                    const contactInfo = document.getElementById('contactInfoInput').value;
                    if (!contactInfo) {
                        Swal.showValidationMessage(translateThis('Please enter your contact information.'));
                        return false;
                    }
                    return { contactInfo };
                }
            }).then(async (result) => {
                if (result.isConfirmed && result.value) {
                    await registerData(result.value.contactInfo);
                }
            });
            }
        }
      } else if (!dontShowAgain) {
        const response = await Swal.fire({
            title: translateThis("Registration Recommended"),
            text: translateThis("No user data found. We recommend registering your contact information and encryption key. Would you like to register now?"),
            icon: 'info',
            confirmButtonText: translateThis('Yes'),
            showCancelButton: true,
            cancelButtonText: translateThis('No'),
            footer: '<label><input type="checkbox" id="dontShowAgain"> ' + translateThis("Don't show this again") + '</label>',
        });

        const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
            if (dontShowAgainCheckbox && dontShowAgainCheckbox.checked) {
            localStorage.setItem('dontShowRegistrationNotification', 'true');
        }

        if (response.isConfirmed) {
          await Swal.fire({
              title: translateThis('Register Contact Information and Public Key'),
              html: `
                  <input id="contactInfoInput" class="swal2-input" placeholder="${translateThis('Enter your email/contact information')}">
                  <p>${translateThis('Would you like to register this public key to your account now? This is how users will know how to encrypt their offers to you.')}</p>
              `,
              icon: 'question',
              showCancelButton: true,
              confirmButtonText: translateThis('Yes'),
              cancelButtonText: translateThis('No'),
              preConfirm: () => {
                  const contactInfo = document.getElementById('contactInfoInput').value;
                  if (!contactInfo) {
                      Swal.showValidationMessage(translateThis('Please enter your contact information.'));
                      return false;
                  }
                  return { contactInfo };
              }
          }).then(async (result) => {
              if (result.isConfirmed && result.value) {
                  await registerData(result.value.contactInfo);
              }
          });
        }
      } 
      // showLoader();
      // Create the popup container
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');
      //popupContainer.onclick = function() { popupContainer.remove(); };

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      var myterms = [];
      var expiration = 0;

      // Create the form element
      var form = document.createElement('form');
      form.classList.add('popup-form');
      form.innerHTML = `<div id="createContractModal" class="modal modal-header">
          <h2>` + translateThis('Create Contract') + `</h2>
          <div class="modal-content form-contract-modal">
            <form id="createContractForm">
              <div class="input-wrapper">
                <label for="contractType">` + translateThis('Contract Type') + `:</label>
                <select id="contractType">
                  <option value="public">` + translateThis('Public Offer') + `</option>
                  <option value="private">` + translateThis('Private Offer') + `</option>
                </select>
              </div>
              <div class="input-wrapper">
                <div id="counterPartyAddressField" style="display:none;">
                <label for="counterPartyAddress">` + translateThis('Counter-Party Address:') + `</label>
                <input type="text" id="counterPartyInput">
                </div>
              </div>
              <div class="input-wrapper-area">
                <div class="input-wrapper">
                  <label for="senderReceiver">` + translateThis('Sender or Receiver:') + `</label>
                  <select id="senderReceiver">
                    <option value="receiver">` + translateThis("I'm the one receiving the funds") + `</option>
                    <option value="sender">` + translateThis("I'm the one sending the funds") + `</option>                
                  </select>
                </div>
                <div class="input-wrapper">
                  <div class="input-wrapper-area">
                    <div class="input-wrapper content-margin">
                      <label for="order-quantity">` + translateThis('Quantity:') + `</label>
                      <input type="number" id="order-quantity" min="1" value="1">
                    </div>  
                    <div class="input-wrapper content-margin">
                      <label for="order-maximum">` + translateThis('Maximum:') + `</label>
                      <input type="number" id="order-maximum" min="1" value="1">
                    </div>
                  </div>
                </div>
              </div>
              <div class="input-wrapper-area">
                <div class="input-wrapper">
                  <label for="token">` + translateThis('Token:') + `</label>
                  <select id="token-select">
                    <!-- options added dynamically through javascript -->
                  </select>
                </div>
                <div class="input-wrapper">
                  <div class="input-wrapper-area">
                    <div class="input-wrapper content-margin">
                      <label for="amount">` + translateThis('Amount:') + `</label>
                      <input type="number" id="amount-input" min="0" step="0.00000001">
                    </div>
                  </div>
                </div>
              </div>
              <div class="input-wrapper-content">
                <label for="depositSettings">` + translateThis('Deposit Settings:') + `</label>
                <select id="depositSettings">
                  <option value="recommended">` + translateThis('Use recommended deposit settings') + `</option>
                  <option value="custom">` + translateThis('Custom deposits') + `</option>
                </select>
              </div>
              <div class="input-wrapper-area">
                <div class="input-wrapper">
                  <div id="senderDepositField" style="display:none;">
                  <label for="senderDeposit">` + translateThis('Sender Deposit:') + `</label>
                  <input type="number" id="sender-deposit-input" min="0" step="0.00000001">
                  </div>
                </div>
                <div class="input-wrapper">
                  <div id="receiverDepositField" style="display:none;">
                    <label for="receiverDeposit">` + translateThis('Receiver Deposit:') + `</label>
                    <input type="number" id="recipient-deposit-input" min="0" step="0.00000001">
                  </div>
                </div>
              </div>
              <div class="input-wrapper">
                <label for="timeLimit">` + translateThis('Time Limit (in weeks):') + `</label>
                <input type="number" id="timeLimit" min="1" value="4">
                <p id="timeLimitWarning" style="display:none;">` + translateThis('Notice: Fast expiration times can cause users to lose funds if they lose access to their computers. The default time of one month or longer is recommended for this reason.') + `</p>
              </div>  
              <div class="input-wrapper-content">
                <label for="contractDetails">` + translateThis('Contract Details:') + `</label>
                <textarea id="contractDetails"></textarea>
              </div>
              <div class="input-wrapper-content">
                  <label for="contractImage">` + translateThis('Contract Images/files:') + `</label>
                  <input type="file" id="contractImage" multiple">
                  <div id="fileDisplayArea"></div>
                  <button type="button" id="changefile" style="display:none;">` + translateThis('Change Images') + `</button>
                  <p style="color: grey; font-size: 0.8em;">` + translateThis('Maximum file size: 10 MB per file.') + `</p>
              </div>
              <div class="input-wrapper-area">
                <div class="input-wrapper">
                  <label for="contactInfo">` + translateThis('Contact Information(email/chat):') + `</label>
                  <textarea id="contactInfo" ></textarea>
                  <div id="contactInfoWarning" style="color: red; display: none;">` + translateThis('Please enter a valid email address.') + `</div>
                </div>
                <div class="input-wrapper">
                  <label for="key-words" id="key-label">` + translateThis('Search key words(optional):') + `</label>
                  <button class="input-buttons" type="button" id="key-words">` + translateThis('Add search terms') + `</button>
                </div>
              </div>
              <div class="input-wrapper-area">
                <div class="input-wrapper input-checkboxes"> 
                  <label for="allowcounters" id="allowcounterslabel">` + translateThis('Allow counter offers') + ` 
                    <input type="checkbox" id="allowcounters" checked="checked">
                    <span class="checkmark"></span>
                  </label>
                </div>
                <div class="input-wrapper input-checkboxes">
                  <label for="autoaccept" id="autoacceptlabel">` + translateThis('Automatically accept matching offers') + `  
                    <input type="checkbox" id="autoaccept">
                    <span class="checkmark"></span>
                  </label>
                </div>
              </div>
              <button class="btn-filled" type="submit">` + translateThis('Submit') + `</button>
            </form>
          </div>
        </div>
        `;

      // Populate the token select dropdown
      var tokenSelect = form.querySelector('#token-select');
      for (var i = 0; i < tokens.length; i++) {
        var option = document.createElement('option');
        option.value = i;
        option.text = tokens[i].token;
        tokenSelect.appendChild(option);
      }

      form.querySelector("#contactInfo").value = document.getElementById("myContactInfo").value;

      // Get necessary DOM elements
      var contractType = form.querySelector('#contractType');
      var counterPartyAddressField = form.querySelector('#counterPartyAddressField');
      var depositSelect = form.querySelector('#depositSettings');
      var senderDepositInput = form.querySelector('#senderDepositField');
      var recipientDepositInput = form.querySelector('#receiverDepositField');
      var imageInput = form.querySelector('#contractImage');
      var contactInfo = form.querySelector('#contactInfo')
      var warningDiv = form.querySelector('#contactInfoWarning');
      var displayArea = form.querySelector('#fileDisplayArea');
      var fileNamesInput = form.querySelector('#fileNames');
      var auto = form.querySelector('#autoaccept');
      var allowcounters = form.querySelector('#allowcounters');
      var adjusttime = form.querySelector('#timeLimit');
      var addWord = form.querySelector("#key-words");
      var addWordLabel = form.querySelector("#key-label");

      // Hide counterparty input initially
      counterPartyAddressField.style.display = 'none';

      // Hide deposit inputs initially
      senderDepositInput.style.display = 'none';
      recipientDepositInput.style.display = 'none';

      auto.addEventListener('change', async() => {
        if (auto.checked) {
          await Swal.fire({
            icon: 'info',
            title: translateThis('Autoaccept'),
            text: translateThis('Please be aware when you automatically accept deals you must occassionally check the software to make sure you are aware of when deals enter escrow just in case the counter-party does not alert you. This way losses do not occur and deals will not expire.'),
          });
        }
      });

      // Event listener for type select
      contractType.addEventListener('change', () => {
        if (contractType.value === 'private') {
          publicoffer = false;
          counterPartyAddressField.style.display = 'block';
          auto.style.display = 'none';
          document.getElementById("autoacceptlabel").style.display = 'none';
          allowcounters.style.display = 'none';
          document.getElementById("allowcounterslabel").style.display = 'none';
          myterms = [];
          addWord.style.display = 'none';
          addWordLabel.style.display = 'none';
        } else {
          publicoffer = true;
          counterPartyAddressField.style.display = 'none';
          auto.style.display = 'block';
          document.getElementById("autoacceptlabel").style.display = 'block';
          allowcounters.style.display = 'block';
          document.getElementById("allowcounterslabel").style.display = 'block';
          addWord.style.display = 'block';
          addWordLabel.style.display = 'block';
        }
      });

      adjusttime.addEventListener('change', () => {
            if(adjusttime.value<4) {
          timeLimitWarning.style.display = 'block';
        } else {
          timeLimitWarning.style.display = 'none';
        }
      });

      // Event listener for deposit select
      depositSelect.addEventListener('change', () => {
        if (depositSelect.value === 'custom') {
          senderDepositInput.style.display = 'block';
          recipientDepositInput.style.display = 'block';
        } else {
          senderDepositInput.style.display = 'none';
          recipientDepositInput.style.display = 'none';
        }
      });
      var image = [];
      var selectedFiles = [];
      // Event listener for image input
      imageInput.addEventListener('change', async () => {
          if (imageInput.files.length + selectedFiles.length > 10) {
              await Swal.fire(translateThis("Please add less than the maximum of 10 files"));
              return false;
          }

          for (const file of imageInput.files) {
              const fileType = file.type;
              const validImageTypes = ['image/gif', 'image/jpeg', 'image/png', 'image/svg+xml'];
              const validTextType = ['text/plain'];
              const validDocTypes = ['application/msword', 'application/pdf', 'application/zip'];
              const isZipFile = fileType.includes('zip');
              const isValidDoc = fileType.includes('doc', 'docx');

              
              if (file.size > 10 * 1024 * 1024) { // 10 MB in bytes
                  await Swal.fire({
                      icon: 'error',
                      title: translateThis('File Size Exceeded'),
                      text: translateThis('The file size should not exceed 10 MB. Please select a smaller file.'),
                  });
                  continue;
              }

              // Check if the file type is valid
              if (validImageTypes.includes(fileType) || validTextType.includes(fileType) || isValidDoc || validDocTypes.includes(fileType) || isZipFile) {
                  if (validImageTypes.includes(fileType)) {
                      const myimage = await resizeImage(file);
                      if (myimage) {
                          image.push(myimage);
                          selectedFiles.push(file);
                      } else {
                          console.warn(`File ${file.name} is not a valid image`);
                      }
                  } else {
                      const base64File = await readFileAsDataURL(file);
                      image.push(base64File);
                      selectedFiles.push(file);
                      if (!validTextType.includes(fileType)) {
                          await Swal.fire({
                              icon: 'warning',
                              title: translateThis('Security Warning'),
                              text: translateThis('Text file attachments are preferred due to security reasons. You are uploading a DOC/PDF/ZIP file. Please make sure you trust any files being sent before proceeding.'),
                          });
                      }
                  }
              } else {
                  // Handle unsupported file types
                  await Swal.fire({
                      icon: 'error',
                      title: translateThis('Unsupported File Type'),
                      text: translateThis('Only image, text, and specific document files are allowed. Please select a different file.'),
                  });
              }
          }

          updateFilesDisplay();
      });

      function updateFilesDisplay() {
        displayArea.innerHTML = '';

        selectedFiles.forEach((file, index) => {
          const imgSrc = URL.createObjectURL(file);
          appendFileToDisplay(imgSrc, index);
        });

        // Update file names display
        const fileNames = selectedFiles.map(file => file.name).join(', ');
        document.getElementById('fileNames').textContent = fileNames;
      }

      function appendFileToDisplay(imgSrc, index) {
        const file = selectedFiles[index];
        const fileType = file.type;
        const validImageTypes = ['image/gif', 'image/jpeg', 'image/png', 'image/svg+xml'];
        const isImage = validImageTypes.includes(fileType);
        
        const fileElement = document.createElement('div');
        fileElement.className = 'file-display';
        const truncatedFileName = file.name.length > 9 ? file.name.substring(0, 9) + '...' : file.name;
        if (isImage) {
          fileElement.innerHTML = `
            <img src="${imgSrc}" alt="${file.name}">
            <span class="file-name">${truncatedFileName}</span>
            <span class="remove-file" data-index="${index}">&times;</span>
          `;
        } else {
          // Use a generic document icon for non-image files
          fileElement.innerHTML = `
            <img src="document-icon.png" alt="${file.name}">
            <span class="file-name">${truncatedFileName}</span>
            <span class="remove-file" data-index="${index}">&times;</span>
          `;
        }

        displayArea.appendChild(fileElement);
      }

      // Handle click on remove file icon
      displayArea.addEventListener('click', function (event) {
        if (event.target.className === 'remove-file') {
          const index = parseInt(event.target.getAttribute('data-index'));
          selectedFiles.splice(index, 1);
          image.splice(index, 1);
          updateFilesDisplay();
        }
      });

      contactInfo.addEventListener('blur', function () {
        const contactInput = contactInfo;
        const contactValue = contactInput.value.trim();
        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        

        if (!contactValue) {
          warningDiv.textContent = translateThis('Please provide contact information.');
          warningDiv.style.display = 'block';
        } else if (!emailPattern.test(contactValue)) {
          warningDiv.textContent = translateThis('Email is preferred for contact due to automatic email settings. Please enter a valid email address if possible.');
          warningDiv.style.display = 'block';
        } else {
          warningDiv.style.display = 'none';
        }
      });

      if (Object.keys(counterdata).length !== 0) {
        form.querySelector('#contractType').selectedIndex = 1;
        counterPartyAddressField.style.display = 'block';
        auto.style.display = 'none';
        allowcounters.style.display = 'none';
        if(myaccounts === counterdata.recipient) {
          form.querySelector("#senderReceiver").selectedIndex = 0;
          form.querySelector("#counterPartyInput").value = counterdata.sender;
        } else {
          form.querySelector("#senderReceiver").selectedIndex = 1;
          form.querySelector("#counterPartyInput").value = counterdata.recipient;
        }
        form.querySelector("#order-quantity").value = 1;
        form.querySelector("#amount-input").value = displayDecimals(counterdata.token, counterdata.amount);
          if(counterdata.amount == counterdata.depositSender && counterdata.amount == counterdata.depositRecipient) {
          form.querySelector("#depositSettings").selectedIndex = 0;
        } else {
          form.querySelector("#depositSettings").selectedIndex = 1;
          senderDepositInput.style.display = 'block';
          recipientDepositInput.style.display = 'block';
          form.querySelector("#sender-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositSender);
          form.querySelector("#recipient-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositRecipient);
        }
        form.querySelector("#timeLimit").value = parseInt(counterdata.timelimit[0]) / (60 * 60 * 24 * 7);
        form.querySelector("#contractDetails").value = counterdata.message;
        var selectedIndex = -1;

        for (var inx = 0; inx < tokens.length; inx++) {
          if (tokens[inx].address === counterdata.token) {
            selectedIndex = inx;
            break;
          }
        }

        if (selectedIndex !== -1) {
          tokenSelect.selectedIndex = selectedIndex;
        } else {
          await Swal.fire(translateThis('Token not found in default coin list!'));
          popupContainer.remove();
          return;
        }
        image = await(getFile(counterdata.image));
        form.querySelector("#contractImage").style.display = 'none';
        const changefile = form.querySelector("#changefile")
        changefile.style.display = 'block';
        changefile.onclick = () => {
          changefile.style.display = 'none';
          form.querySelector("#contractImage").style.display = 'block';
          image = [];
        }
      }

      addWord.onclick = async function() {
        myterms = await addWords(myterms);
      }

      // Add the form submit event listener
      form.addEventListener('submit', async function(event) {
          event.preventDefault();          
          var selectedIndex = parseInt(tokenSelect.value);
          var tokenAddress = tokens[selectedIndex].address;
          var decimals = parseInt(tokens[selectedIndex].decimals);
          var returnMe = 0;
          var depnotice = 0;
          if(tokennames[tokenAddress] == tokens[0].token) {
            if(parseInt(balances['base'].amount) != 0 && parseInt(balances[tokenAddress].amount) == 0) {
              depnotice = 1;
            }
          } else {
            if(parseInt(balances[tokenAddress].amount2) != 0 && parseInt(balances[tokenAddress].amount) == 0) {
              depnotice = 1;
            }
          }          
          if(depnotice == 1 && accountprivkey != "") {
            await Swal.fire({
              title: translateThis('Deposit'),
              text: translateThis("You have funds in your wallet but you should move some to your markets/trading account in order to interact with offers like this. Would you like to do that now?"),
              icon: 'question',
              showCancelButton: true,
              confirmButtonText: translateThis('Yes'),
              cancelButtonText: translateThis('No'),
            }).then(async (result) => {
              if (result.isConfirmed) {
                returnMe = 1;
                await deposit(1);
                return;
              }
            });
          }
          if(returnMe == 1) {
            return false;
          }
          // Get form values

          var counterPartyInput = document.getElementById("counterPartyInput").value;
          var sender = "0x0000000000000000000000000000000000000000";
          var recipient = "0x0000000000000000000000000000000000000000";
          const currentBlockNumber = await web3.eth.getBlockNumber();
          const currentBlock = await web3.eth.getBlock(currentBlockNumber);
          const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
          if (contractType.value === 'private') {
            sender = counterPartyInput;
            recipient = myaccounts;
            var offerExpirationSelect = document.getElementById("offerExpiration");
            var selectedValue = offerExpirationSelect.value;
            if (selectedValue === "never") {
              expiration = 0; // Set the time limit to 0 seconds for "Never" option
            } else if (selectedValue === "two-weeks") {
              expiration = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
            } else if (selectedValue === "one-month") {
              expiration = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
            }
          } else {
            expiration = 0;
            recipient = myaccounts;
          }
          var senderReceiver = document.getElementById("senderReceiver").value;
          var quantity = parseInt(document.getElementById('order-quantity').value);
          var maximum = parseInt(document.getElementById('order-maximum').value);
          var amount = document.getElementById("amount-input").value;
          var depositType = form.querySelector("#depositSettings").value;
          var depositSender = document.getElementById("sender-deposit-input").value;
          var depositRecipient = document.getElementById("recipient-deposit-input").value;
          var timeLimit = document.getElementById("timeLimit").value;
          var contactinfo = document.getElementById("contactInfo").value;
          var message = JSON.stringify({message: document.getElementById("contractDetails").value, contact: contactinfo, image: image});
          if (contactinfo != '') {
            document.getElementById("myContactInfo").value = contactinfo;
            await saveContactInfo(contactinfo);
          }
          if(message == "error") {
            await Swal.fire(translateThis("Error posting IPFS data, please try again later"));
            return false;
          }
          if (amount === "") {
            await Swal.fire(translateThis("Please enter the amount"));
            return false;
          }
          if (depositType === "custom") {
            if (depositSender === "" || depositRecipient === "") {
              await Swal.fire(translateThis("Please enter the custom deposits"));
              return false;
            }
          }
          if (timeLimit === "") {
            await Swal.fire(translateThis("Please enter the time limit"));
            return false;
          }
          timeLimit = parseInt(timeLimit);
          if (timeLimit === 0) {
            await Swal.fire(translateThis("Time limit must be greater than zero"));
          }
          if (document.getElementById("contractDetails").value === "") {
            await Swal.fire(translateThis("Please enter the description"));
            return false;
          }
          var sender2 = (senderReceiver === "receiver" ? sender : recipient);
          var recipient2 = (senderReceiver === "receiver" ? recipient : sender);

          amount = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0);
          depositSender = (depositType === "recommended" ? amount : (new BigNumber(depositSender.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          depositRecipient = (depositType === "recommended" ? amount : (new BigNumber(depositRecipient.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          var style = 0;
          if(publicoffer) {
            if(document.getElementById("autoaccept").checked == false) {
              style = 1;
            } else {
              style = 0;
            }
            if(document.getElementById("allowcounters").checked == false) {
              style += 2;
            }
          }
          var multiplier = 1;
          if(style == 0 || style == 2) {
            multiplier = maximum;
            if(maximum > quantity) {
              multiplier = quantity;
            }
          }
          var mytotal = web3.utils.toBN(amount).add(web3.utils.toBN(depositSender)).mul(web3.utils.toBN(multiplier));          
          var mybal = web3.utils.toBN(balances[tokenAddress].amount);
          if(accountprivkey != "") {
            if(tokennames[tokenAddress] == tokens[0].token) {
              mybal = mybal.add(web3.utils.toBN(balances['base'].amount));
            } else {
              mybal = mybal.add(web3.utils.toBN(balances[tokenAddress].amount2));
            }
          }
          if(myaccounts == sender2) {
            if (mybal.lt(mytotal)) {
              await Swal.fire(translateThis("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding."));
              return false;
            }
          }
          if(myaccounts == recipient2) {
            mytotal = web3.utils.toBN(depositRecipient).mul(web3.utils.toBN(multiplier));
            if (mybal.lt(mytotal)) {
              await Swal.fire(translateThis("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding."));
              return false;
            }
          }
          var datalen = 0;
          var contact2 = '';
          var otherparty = '';
          try {
            if(myaccounts == sender2) {
              otherparty = recipient2;
            } else {
              otherparty = sender2;
            }
            var returnThis = 0;
            if(otherparty != "0x0000000000000000000000000000000000000000") {
              datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(otherparty, 3).call());
              if(datalen > 0) {
                contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(otherparty, datalen-1).call()));
                if('publickey' in contact2 && userprivkey != '') {
                  var paddedMessage = message + "#*#*#" + (new Date().getTime()) + Crypto.SHA256(new Date().getTime());
                  if(myaccounts == sender2) {
                    message = JSON.stringify({'recipient':cryptico.encrypt(paddedMessage, contact2['publickey'], userprivkey),'sender':cryptico.encrypt(paddedMessage, userpubkey, userprivkey)});
                  }
                  if(myaccounts == recipient2) {
                    message = JSON.stringify({'sender':cryptico.encrypt(paddedMessage, contact2['publickey'], userprivkey),'recipient':cryptico.encrypt(paddedMessage, userpubkey, userprivkey)});
                  }
                  console.log(message)
                } else if ('publickey' in contact2 && userprivkey == '') {
                  await Swal.fire({
                    title: translateThis('Encrypt offer'),
                    text: translateThis('Your counterparty has listed a key for encryption. If you would like your order be encrypted you should set a password for your account. Would you like to do that before proceeding?'),
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: translateThis('Yes'),
                    cancelButtonText: translateThis('No'),
                  }).then((result) => {
                    if (result.isConfirmed) {
                      popupContainer.remove();
                      returnThis = 1;
                      return;
                    }
                  });
                }
              }
            }
            if(returnThis == 1) {
              return false;
            }
          } catch(e) {
            console.log(e);
          }
          const byteLength = new TextEncoder().encode(message).length;
          if (byteLength > parseInt(maxFileSize * .97)) {
            await Swal.fire(translateThis("Message exceeds maximum byte size:") + " " + maxFileSize);
            return false;
          }
          var result = await postOfferData(message);
          if(result == "error") {
            await Swal.fire(translateThis("Error posting message data to IPFS."));
            return false;
          }
          if(result.length > 100) {
            await Swal.fire(translateThis("Error message length was unusually long. Please check IPFS hash result."));
            return false;
          }
          message = result;
          // Construct data object
          const data = {
            sender: sender2,
            recipient: recipient2,
            token: tokenAddress,
            amount: amount,
            depositSender: depositSender,
            depositRecipient: depositRecipient,
            quantity: [quantity.toString(), maximum.toString()],
            timelimit: parseInt(timeLimit * 7 * 24 * 60 * 60),
            message: message
          };
          data2 = JSON.parse(JSON.stringify(data));
          data2.image = [];
          data2.message = "IPFS link: " + data2.message;
          data2.timelimit = [data2.timelimit];
          data2.rfee = baseFee;
          data2.referred = referral;
          if(Object.keys(counterdata).length !== 0) {
            data2.referred = counterdata.referred;
            if(myaccounts == sender2) {
              data2.referred = referral;
              const rfee2 = parseInt(DOMPurify.sanitize(await DDEcontract.methods.customFee(otherparty).call()));
              if(rfee2 > baseFee) {
                data2.rfee = rfee2;
              }
              style = 4;
            }
          }
          //if(Object.keys(counterdata).length !== 0) {
          //  data2.amount *= quantity;
          //  data2.depositSender *= quantity;
          //  data2.depositRecipient *= quantity;
          //}          
          console.log("data2",data2);
          //May eventually want to check for duplicate contract hash submission
          var result = await showListing(data2, 3)
          if(result == false) {
            popupContainer.remove();
            return;
          }
          try {
            var cHash = web3.utils.keccak256(web3.utils.encodePacked({value: data.sender, type: 'address'},{value: data.recipient, type: 'address'},{value: data.token, type: 'address'},{value: data.amount, type: 'uint256'},{value: data.depositSender, type: 'uint256'},{value: data.depositRecipient, type: 'uint256'},{value: data.timelimit.toString(), type: 'uint256'},{value: expiration.toString(), type: 'uint256'},{value: data.message, type: 'string'},{value: blockTimestamp, type: 'uint256'}));
            console.log(cHash);
            var returnThis2 = false;
            if(publicoffer) {
              if(myterms.length == 0) {
                await Swal.fire({
                  title: translateThis('Hashtags'),
                  text: translateThis('You did not include any keywords. Without these it could make your offer hard to find. It is recommended to add some keywords related to your open offer. Would you like to submit your offer without keywords?'),
                  icon: 'question',
                  showCancelButton: true,
                  confirmButtonText: translateThis('Yes'),
                  cancelButtonText: translateThis('No'),
                }).then((result) => {
                      if(!result.isConfirmed) {
                    popupContainer.remove();
                    returnThis2 = true;
                    return;
                  }
                });
              }
            }
            if(returnThis2) {
              return;
            }
            if(DOMPurify.sanitize(await DDEcontract.methods.initialized(cHash).call()) == "true") {
              await Swal.fire(translateThis("Duplicate contract detected! This contract has already been created in the past. Please modify the description slightly so it may be submitted again."));
              popupContainer.remove();
              return;
            }
            setActionActive(myaccounts+"createContract"+cHash, true);
            // Call solidity function to create contract
            if(accountprivkey == "") {
              showLoader();
              await DDEcontract.methods.createContract(
                [data.sender, data.recipient, data.token, "0x0000000000000000000000000000000000000000", data.amount.toString(), data.depositSender.toString(), data.depositRecipient.toString(), [data.quantity[0].toString(), data.quantity[1].toString()], "0", [data.timelimit.toString(), expiration.toString(), "0"], [style.toString(), "0"], data.message], data2.referred, myterms).send({"from":myaccounts,...gasOptions[gasSetting]});
              hideLoader();
            } else {
              mytotal = mytotal.toString();
              if(web3.utils.toBN(mytotal).lte(web3.utils.toBN(balances[data.token].amount))) {
                const gasEstimate = 700000;
                var res = await confirmTransaction(gasEstimate, mytotal, data.token);
                if(!res) {
                  return;
                }
                showLoader();
                await DDEcontract.methods.createContract(
                  [data.sender, data.recipient, data.token, "0x0000000000000000000000000000000000000000", data.amount.toString(), data.depositSender.toString(), data.depositRecipient.toString(), [data.quantity[0].toString(), data.quantity[1].toString()], "0", [data.timelimit.toString(), expiration.toString(), "0"], [style.toString(), "0"], data.message], data2.referred, myterms).send({"from":myaccounts,...gasOptions[gasSetting]});
                  hideLoader();
              } else {
                const gasEstimate = 750000;
                var res = await confirmTransaction(gasEstimate, mytotal, data.token);
                if(!res) {
                  return;
                }
                showLoader();
                await getApproval(data.token, mytotal);
                hideLoader();
                var myval = "0";
                var difference = web3.utils.toBN(mytotal).sub(web3.utils.toBN(balances[data.token].amount));
                if(tokennames[data.token] == tokens[0].token) {
                  var mybase = web3.utils.toBN(balances['base'].amount);
                  var glimit = web3.utils.toBN(gasOptions[gasSetting].gasLimit).mul(web3.utils.toBN(gasPrice));
                  if(mybase.lt(difference.add(glimit))) {
                    await Swal.fire(translateThis("Not enough funds"));
                    return;
                  }
                  myval = difference.toString();
                }
                showLoader();
                await DDEcontract.methods.depositAndCreateContract(data.token, difference.toString(), [data.sender, data.recipient, data.token, "0x0000000000000000000000000000000000000000", data.amount.toString(), data.depositSender.toString(), data.depositRecipient.toString(), [data.quantity[0].toString(), data.quantity[1].toString()], "0", [data.timelimit.toString(), expiration.toString(), "0"], [style.toString(), "0"], data.message], data2.referred, myterms).send({"from":myaccounts,"value":myval,...gasOptions[gasSetting]});
                hideLoader();
              }
            }
            setActionActive(myaccounts+"createContract"+cHash, false);
            hideLoader();
            await Swal.fire(translateThis("Contract creation success!"));
            await loadUser();
            if(emailClient.checked && sender2 != "0x0000000000000000000000000000000000000000" && recipient2 != "0x0000000000000000000000000000000000000000" && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
              Swal.fire({
                title: translateThis('Notify Counterparty'),
                text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then((result) => {
                if (result.isConfirmed) {
                  var emailSubject = encodeURIComponent('You have received an offer on the BitBay marketplace');
                  var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have sent you an offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about my offer please let me know. Thank you and have a nice day.'));
                  const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                  window.location.href = mailtoLink;
                }
              });
            }
            popupContainer.remove();
          } catch (error) {
            console.error(error);
            hideLoader();
            await showError(error);
          } finally {
            setActionActive(myaccounts+"createContract"+cHash, false);
            hideLoader();
          }
      });

      // Append the form to the popup container
      popupContainer.appendChild(popup);
      popup.appendChild(form);
      popup.appendChild(closeButton);

      // Append the popup container to the page body
      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        
        `;
      document.head.appendChild(style);
    }

    async function addWords(theterms = "") {
      return new Promise((resolve) => {
        const dialog = document.createElement("div");
        var addedTerms = [];

        // Predefined list of popular key words
        const popularKeywords = ["goods", "services", "barter", "crypto", "real-estate", "electronics", "metals"];

        dialog.innerHTML = `
          <div>` + translateThis('Please enter some key words so users can find your order easier:') + `<br></div>
            <input id="hashtag" type="text"></input><button id="add-btn">` + translateThis('Add') + `</button><br><br>
          <div id="term-list"></div>
          <br>
          <div>          
            <div>` + translateThis('Popular key words:') + `</div>            
            <div id="popular-keywords"></div>
            <br>
            <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
            <button id="cancel-btn">` + translateThis('Cancel') + `</button>
          </div>
        `;
        dialog.style.display = "block";
        dialog.style.position = "fixed";
        dialog.style.zIndex = 999;
        dialog.style.backgroundColor = "white";
        dialog.style.padding = "20px";
        dialog.style.borderRadius = "10px";
        dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
        dialog.style.top = "50%";
        dialog.style.left = "50%";
        dialog.style.transform = "translate(-50%, -50%)";

        document.body.appendChild(dialog);

        const termList = dialog.querySelector("#term-list");
        const confirmBtn = dialog.querySelector("#confirm-btn");
        const cancelBtn = dialog.querySelector("#cancel-btn");
        const addBtn = dialog.querySelector("#add-btn");
        const popularKeywordsContainer = dialog.querySelector("#popular-keywords");

        // Display the added terms list
        function displayAddedTerms() {
          termList.innerHTML = "";
          addedTerms.forEach(term => {
            const termElement = document.createElement("div");
            termElement.textContent = term;
            termList.appendChild(termElement);
          });
        }

        if(theterms != "") {
          addedTerms = theterms;
          displayAddedTerms();
        }

        termList.addEventListener('click', function (event) {
          if (event.target.tagName === 'DIV') {
            const termToRemove = event.target.textContent.trim();
            const termIndex = addedTerms.indexOf(termToRemove);
            if (termIndex !== -1) {
              addedTerms.splice(termIndex, 1);
              displayAddedTerms();
            }
          }
        });

        // Add a term to the list when Add button is clicked
        addBtn.addEventListener("click", async () => {
          const hashtagInput = dialog.querySelector("#hashtag");
          const term = hashtagInput.value.toLowerCase().trim();
          if (term.includes(" ") || term.includes(",")) {
            await Swal.fire(translateThis("Key words should not contain spaces or commas"));
            return;
          }
          const encoder = new TextEncoder();
          const utf8Bytes = encoder.encode(term);
          const byteLength = utf8Bytes.length;
          if (byteLength > 32) {
            await Swal.fire(translateThis("String exceeds limit of 32 bytes"));
            return;
          }
          if (term !== "") {
            if (!addedTerms.includes(term)) {
              addedTerms.push(term);
              displayAddedTerms();
            }
            hashtagInput.value = "";
          }
        });

        // Add a popular keyword to the list when a bubble button is clicked
        popularKeywords.forEach(keyword => {
          const keywordButton = document.createElement("button");
          keywordButton.textContent = keyword;
          keywordButton.addEventListener("click", async () => {
            if (addedTerms.length < 11) {
              if (!addedTerms.includes(keyword.toLowerCase())) {
                addedTerms.push(keyword.toLowerCase());
                displayAddedTerms();
              }
            } else {
              await Swal.fire(translateThis('The maximum number of keywords is 10'));
            }
          });
          popularKeywordsContainer.appendChild(keywordButton);
        });

        // Remove the dialog when Cancel button is clicked
        cancelBtn.addEventListener("click", async () => {
          dialog.remove();
        });

        // Resolve the promise with the added terms when Confirm button is clicked
        confirmBtn.addEventListener("click", async () => {
          dialog.remove();
          resolve(addedTerms);
        });
      });
    }
    
    async function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
          let reader = new FileReader();
          reader.onload = () => {
              const resultParts = reader.result.split(',');
              if (resultParts.length < 2) {
                  reject(new Error("Invalid file data"));
                  return;
              }
              const base64Data = resultParts[1];
              const fileTypePrefix = `data:${file.type};base64,`;
              resolve(fileTypePrefix + base64Data);
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
      });
    }

    async function acceptOffer(listing) {
      try {
        var mylisting = JSON.parse(JSON.stringify(listing));
        var quantity = 1;
        var accepttimelimit = 0;
        var offerExpirationSelect = document.getElementById("offerExpiration");
        var selectedValue = offerExpirationSelect.value;
        const currentBlockNumber = await web3.eth.getBlockNumber();
        const currentBlock = await web3.eth.getBlock(currentBlockNumber);
        const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
        if (selectedValue === "never") {
          accepttimelimit = 0; // Set the time limit to 0 seconds for "Never" option
        } else if (selectedValue === "two-weeks") {
          accepttimelimit = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
        } else if (selectedValue === "one-month") {
          accepttimelimit = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
        }
        var returnMe = 0;
        var depnotice = 0;
        if(tokennames[mylisting.token] == tokens[0].token) {
          if(parseInt(balances['base'].amount) != 0 && parseInt(balances[mylisting.token].amount) == 0) {
            depnotice = 1;
          }
        } else {
          if(parseInt(balances[mylisting.token].amount2) != 0 && parseInt(balances[mylisting.token].amount) == 0) {
            depnotice = 1;
          }
        }          
        if(depnotice == 1 && accountprivkey != "") {
          await Swal.fire({
            title: translateThis('Deposit'),
            text: translateThis("You have funds in your wallet but you should move some to your markets/trading account in order to interact with offers like this. Would you like to do that now?"),
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: translateThis('Yes'),
            cancelButtonText: translateThis('No'),
          }).then(async (result) => {
            if (result.isConfirmed) {
              returnMe = 1;
              await deposit(1);
              return;
            }
          });
        }
        if(returnMe == 1) {
          return false;
        }
        if(mylisting.sender == "0x0000000000000000000000000000000000000000" || mylisting.recipient == "0x0000000000000000000000000000000000000000" ) {
          const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(mylisting.hash).call());
          if(offerID == 0) {
            await Swal.fire(translateThis("Offer no longer available!"));
            return;
          }
          if(listing.status[0]==0 || listing.status[1]==0) {
            const dialog = document.createElement("div");
            dialog.classList.add("modal-shade-bg")
            dialog.innerHTML = `
                  <div class="category-purchase-popup">
                    <div class="detail-content">` + translateThis('Please enter the quantity you wish to purchase:') + `<br></div>
                      <input id="new-quantity" type="number" min="1"></input><br><br>
                    <div>
                      <button id="confirm-btn" class="btn-filled">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
                      <button id="cancel-btn" class="btn-gray">` + translateThis('Cancel') + `</button>
                    </div>
                  </div>
                `;

            document.body.appendChild(dialog);

            const confirmBtn = dialog.querySelector("#confirm-btn");
            const cancelBtn = dialog.querySelector("#cancel-btn");
            cancelBtn.addEventListener("click", async () => {
              dialog.remove();
            });

            confirmBtn.addEventListener("click", async () => {
              quantity = parseInt(document.getElementById('new-quantity').value);
              if(quantity > parseInt(mylisting.quantity[0]) || quantity > parseInt(mylisting.quantity[1])) {
                await Swal.fire(translateThis("Quantity exceeds what is available!"));
                return;
              }
              dialog.remove();
              mylisting.quantity[0] = quantity.toString();
              var counterparty = mylisting.sender;
              if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                counterparty = mylisting.recipient;
              }
              var counterbalance = "";
              await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
                counterbalance = DOMPurify.sanitize(bal);
              });
              var mytotal = "0";
              var mybal = web3.utils.toBN(balances[mylisting.token].amount);
              if(accountprivkey != "") {
                if(tokennames[mylisting.token] == tokens[0].token) {
                  mybal = mybal.add(web3.utils.toBN(balances['base'].amount));
                } else {
                  mybal = mybal.add(web3.utils.toBN(balances[mylisting.token].amount2));
                }
              }
              if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                mytotal = web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity));
                if (web3.utils.toBN(mybal).lt(mytotal)) {
                  await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                  return false;
                }
                if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                  await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                  return false;
                }
              }
              if(mylisting.recipient == "0x0000000000000000000000000000000000000000") {
                mytotal = web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity));
                if (web3.utils.toBN(mybal).lt(mytotal)) {
                  await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                  return false;
                }
                if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                  await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                  return false;
                }
              }
              var datalen = 0;
              var contact2 = '';
              try {
                datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(counterparty, 3).call());
                if(datalen > 0) {
                  contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(counterparty, datalen-1).call()));
                }
              } catch(e) {
                console.log(e);
              }
              //If one wants to show a grand total
              //mylisting.amount *= quantity;
              //mylisting.depositSender *= quantity;
              //mylisting.depositRecipient *= quantity;
              var result = await showListing(mylisting, 3)
              if(result == false) {
                return;
              }
              if (!web3.utils.isAddress(referral)) {
                referral = "0x0000000000000000000000000000000000000000";
              }
              try {
                setActionActive(myaccounts+"acceptOffer"+mylisting.hash, true);                
                if (accountprivkey == "") {
                  showLoader();
                  await DDEcontract.methods.acceptOffer(
                    mylisting.hash,
                    quantity.toString(),
                    accepttimelimit.toString(),
                    referral
                  ).send({ "from": myaccounts, ...gasOptions[gasSetting] });
                  hideLoader();
                } else {
                  mytotal = mytotal.toString();
                  if(web3.utils.toBN(mytotal).lte(web3.utils.toBN(balances[mylisting.token].amount))) {
                    const gasEstimate = 500000;
                    var res = await confirmTransaction(gasEstimate, mytotal, mylisting.token);
                    if(!res) {
                      return;
                    }
                    showLoader();
                    await DDEcontract.methods.acceptOffer(mylisting.hash, quantity.toString(), accepttimelimit.toString(), referral).send({"from":myaccounts,...gasOptions[gasSetting]});
                    hideLoader();
                  } else {
                    const gasEstimate = 550000;
                    var res =  await confirmTransaction(gasEstimate, mytotal, mylisting.token);;
                    if(!res) {
                      return;
                    }
                    await getApproval(mylisting.token, mytotal);
                    var myval = "0";
                    var difference = web3.utils.toBN(mytotal).sub(web3.utils.toBN(balances[mylisting.token].amount));
                    if(tokennames[mylisting.token] == tokens[0].token) {
                      var mybase = web3.utils.toBN(balances['base'].amount);
                      var glimit = web3.utils.toBN(gasOptions[gasSetting].gasLimit).mul(web3.utils.toBN(gasPrice));
                      if(mybase.lt(difference.add(glimit))) {
                        await Swal.fire(translateThis("Not enough funds"));
                        return;
                      }
                      myval = difference.toString();
                    }
                    showLoader();
                    await DDEcontract.methods.depositAndAcceptOffer(mylisting.token, difference.toString(), mylisting.hash, quantity.toString(), accepttimelimit.toString(), referral).send({"from":myaccounts,"value":myval,...gasOptions[gasSetting]});
                    hideLoader();
                  }
                }
                await Swal.fire(translateThis("Contract accepted!"));
                await loadUser();
                if(emailClient.checked && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
                  Swal.fire({
                    title: translateThis('Notify Counterparty'),
                    text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: translateThis('Yes'),
                    cancelButtonText: translateThis('No'),
                  }).then((result) => {
                    if (result.isConfirmed) {
                      var emailSubject = encodeURIComponent(translateThis('Your offer on BitBay markets was accepted'));
                      var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have accepted your offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about our contract please let me know. Thank you and have a nice day.'));
                      const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                      window.location.href = mailtoLink;
                    }
                  });
                }
              } catch (error) {
                console.error(error);
                hideLoader();
                await showError(error);
              } finally {
                setActionActive(myaccounts+"acceptOffer"+mylisting.hash, false);
              }
            });
          }
        } else {
          quantity = mylisting.quantity[0];
          var counterparty = mylisting.sender;
          if(mylisting.sender == myaccounts) {
            counterparty = mylisting.recipient;
          }
          var counterbalance = "";
          await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
            counterbalance = DOMPurify.sanitize(bal);
          });
          var mytotal = "0";
          var mybal = web3.utils.toBN(balances[mylisting.token].amount);
          if(accountprivkey != "") {
            if(tokennames[mylisting.token] == tokens[0].token) {
              mybal = mybal.add(web3.utils.toBN(balances['base'].amount));
            } else {
              mybal = mybal.add(web3.utils.toBN(balances[mylisting.token].amount2));
            }
          }
          if(mylisting.sender == myaccounts) {
            mytotal = web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity));
            if (web3.utils.toBN(mybal).lt(mytotal)) {
              await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
              return false;
            }
            if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
              await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
              return false;
            }
          }
          if(mylisting.recipient == myaccounts) {
            mytotal = web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity));
            if (web3.utils.toBN(mybal).lt(mytotal)) {
              await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
              return false;
            }
            if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
              await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
              return false;
            }
          }
          var datalen = 0;
          var contact2 = '';
          try {
            datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(counterparty, 3).call());
            if(datalen > 0) {
              contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(counterparty, datalen-1).call()));
            }
          } catch(e) {
            console.log(e);
            hideLoader();
          }
          //If one wants to show a grand total
          //mylisting.amount *= quantity;
          //mylisting.depositSender *= quantity;
          //mylisting.depositRecipient *= quantity;
          var result = await showListing(mylisting, 3)
          if(result == false) {
            return;
          }
          if (!web3.utils.isAddress(referral)) {
            referral = "0x0000000000000000000000000000000000000000";
          }
          try {
            setActionActive(myaccounts+"acceptOffer"+mylisting.hash, true);            
            if(accountprivkey == "") {
              showLoader();
              await DDEcontract.methods.acceptOffer(
                mylisting.hash,
                quantity.toString(),
                accepttimelimit.toString(),
                referral
              ).send({"from":myaccounts,...gasOptions[gasSetting]});
              hideLoader();
            } else {
              mytotal = mytotal.toString();
              if(web3.utils.toBN(mytotal).lte(web3.utils.toBN(balances[mylisting.token].amount))) {
                const gasEstimate = 500000;
                var res = await confirmTransaction(gasEstimate, mytotal, mylisting.token);
                if(!res) {
                  return;
                }
                showLoader();
                await DDEcontract.methods.acceptOffer(mylisting.hash, quantity.toString(), accepttimelimit.toString(), referral).send({"from":myaccounts,...gasOptions[gasSetting]});
                hideLoader();
              } else {
                const gasEstimate = 550000;
                var res =  await confirmTransaction(gasEstimate, mytotal, mylisting.token);;
                if(!res) {
                  return;
                }
                showLoader();
                await getApproval(mylisting.token, mytotal);
                hideLoader();
                var myval = "0";
                var difference = web3.utils.toBN(mytotal).sub(web3.utils.toBN(balances[mylisting.token].amount));
                if(tokennames[mylisting.token] == tokens[0].token) {
                  var mybase = web3.utils.toBN(balances['base'].amount);
                  var glimit = web3.utils.toBN(gasOptions[gasSetting].gasLimit).mul(web3.utils.toBN(gasPrice));
                  if(mybase.lt(difference.add(glimit))) {
                    await Swal.fire(translateThis("Not enough funds"));
                    return;
                  }
                  myval = difference.toString();
                }
                showLoader();
                await DDEcontract.methods.depositAndAcceptOffer(mylisting.token, difference.toString(), mylisting.hash, quantity.toString(), accepttimelimit.toString(), referral).send({"from":myaccounts,"value":myval,...gasOptions[gasSetting]});
                hideLoader();
              }
            }
            await Swal.fire(translateThis("Contract accepted!"));
            await loadUser();
            if(emailClient.checked && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
              Swal.fire({
                title: translateThis('Notify Counterparty'),
                text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then((result) => {
                if (result.isConfirmed) {
                  var emailSubject = encodeURIComponent(translateThis('Your offer on BitBay markets was accepted'));
                  var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have accepted your offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about our contract please let me know. Thank you and have a nice day.'));
                  const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                  window.location.href = mailtoLink;
                }
              });
            }
          } catch (error) {
            console.error(error);
            hideLoader();
            await showError(error);
          } finally {
            setActionActive(myaccounts+"acceptOffer"+mylisting.hash, false);
            hideLoader();
          }
        }
      } catch (error) {
        console.error(error);
        hideLoader();
        await showError(error);
      } finally {
        hideLoader();
      }
    }
    async function counterOffer(listing) {
      await createContract(false, listing);
    }

    async function cancelOffer(listing, hide = 0) {
      if (hide == 1) {
        const dialog = document.createElement("div");
        dialog.innerHTML = `
            <div>` + translateThis('Would you like to hide this offer or cancel it?') + '<br>' + translateThis('Hiding just removes it from the list.') + '<br>' + translateThis('Cancelling will also notify the other party.') + `<br><br></div>
            <div>
              <button id="hide-btn">` + translateThis('Hide') + `</button>&nbsp;&nbsp;
              <button id="cancel-btn">` + translateThis('Cancel') + `</button>
            </div>
          `;
        dialog.style.display = "block";
        dialog.style.position = "fixed";
        dialog.style.zIndex = 999;
        dialog.style.backgroundColor = "white";
        dialog.style.padding = "20px";
        dialog.style.borderRadius = "10px";
        dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
        dialog.style.top = "50%";
        dialog.style.left = "50%";
        dialog.style.transform = "translate(-50%, -50%)";

        document.body.appendChild(dialog);

        const hideBtn = dialog.querySelector("#hide-btn");
        const cancelBtn = dialog.querySelector("#cancel-btn");

        hideBtn.addEventListener("click", async () => {
          var readMessages = JSON.parse(localStorage.getItem(myaccounts + DDEaddy + ":readmessages2")) || {};
          readMessages[listing.index] = true;
          localStorage.setItem(myaccounts + DDEaddy + ":readmessages2", JSON.stringify(readMessages));
          await loadUser();
          dialog.remove();
        });

        cancelBtn.addEventListener("click", async () => {
          try {
            setActionActive(myaccounts+"cancelOffer"+listing.hash, true);
            dialog.remove();
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.cancelPrivateOffer(
              listing.hash,
              myaccounts
            ).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            await Swal.fire(translateThis("Contract removed!"));
            await loadUser();
          } catch (error) {
            console.error(error);
            hideLoader();
            await showError(error);
          } finally {
            setActionActive(myaccounts+"cancelOffer"+listing.hash, false);
            hideLoader();
          }
        });
      } else {
        try {
          setActionActive(myaccounts+"cancelOffer"+listing.hash, true);
          if (listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000") {
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.removeMarketOffer(
              listing.hash,
              myaccounts
            ).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            await Swal.fire(translateThis("Contract removed!"));
            await loadUser();
          } else {
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.cancelPrivateOffer(
              listing.hash,
              myaccounts
            ).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            await Swal.fire(translateThis("Contract removed!"));
            await loadUser();
          }
        } catch (error) {
          console.error(error);
          hideLoader();
          await showError(error);
        } finally {
          setActionActive(myaccounts+"cancelOffer"+listing.hash, false);
        }
      }
    }

    
    async function userSupportsEncryption(userAddress) {
      try {
        var DDEcontract4 = new web3.eth.Contract(DDEabi, DDEaddy);
        const dataLength = DOMPurify.sanitize(await DDEcontract4.methods.getArrayLength(userAddress, 3).call());
        if (dataLength > 0) {
          const userData = JSON.parse(DOMPurify.sanitize(await DDEcontract4.methods.userdata(userAddress, dataLength - 1).call()));
          return {
            supportsEncryption: !!userData.publickey,
            publicKey: userData.publickey
          };
        }
        return { supportsEncryption: false };
      } catch (error) {
        console.error('Error checking encryption support:', error);
        return { supportsEncryption: false };
      }
    }

    async function updateQuantity(listing) {
      const dialog = document.createElement("div");
      dialog.innerHTML = `
        <div>` + translateThis('Please enter the updated quantity:') + `<br></div>
          <label for="new-quantity">` + translateThis('Total Supply:') + ` </label>
          <input id="new-quantity" type="number" min="1"></input><br><br>
          <label for="new-maximum">` + translateThis('Maximum:') + ` </label>
          <input id="new-maximum" type="number" min="1"></input><br><br>
        <div>
          <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
          <button id="cancel-btn">` + translateThis('Cancel') + `</button>
        </div>
      `;
      dialog.style.display = "block";
      dialog.style.position = "fixed";
      dialog.style.zIndex = 999;
      dialog.style.backgroundColor = "white";
      dialog.style.padding = "20px";
      dialog.style.borderRadius = "10px";
      dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
      dialog.style.top = "50%";
      dialog.style.left = "50%";
      dialog.style.transform = "translate(-50%, -50%)";

      document.body.appendChild(dialog);

      const confirmBtn = dialog.querySelector("#confirm-btn");
      const cancelBtn = dialog.querySelector("#cancel-btn");

      cancelBtn.addEventListener("click", async () => {
        dialog.remove();
        return;
      });

      confirmBtn.addEventListener("click", async () => {
        try {
          var quantity = parseInt(document.getElementById('new-quantity').value);
              if(quantity == 0) {
            dialog.remove();
            await Swal.fire(translateThis("Quantity can not be changed to zero!"));
            return;
          }
          var quantity1 = parseInt(document.getElementById('new-maximum').value);
              if(quantity1 == 0) {
            dialog.remove();
            await Swal.fire(translateThis("Quantity can not be changed to zero!"));
            return;
          }
          setActionActive(myaccounts+"changeQuantity"+listing.hash, true);
          if(accountprivkey != "") {
            const gasEstimate = 50000;
            var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
            if(!res) {
              return;
            }
          }
          showLoader();
          await DDEcontract.methods.updateQuantity(
            listing.hash,
            [quantity.toString(), quantity1.toString()]
              ).send({"from":myaccounts,...gasOptions[gasSetting]});
            hideLoader();
          dialog.remove();
          await Swal.fire(translateThis("Quantity updated!"));
          await loadUser();
          return;
        } catch (error) {
          console.error(error);
          hideLoader();
          await showError(error);
        } finally {
          setActionActive(myaccounts+"changeQuantity"+listing.hash, false);
          hideLoader();
        }
        dialog.remove();
      });
    }

    async function updateFee(listing) {
      await Swal.fire({
        title: translateThis('Set order fee'),
        text: translateThis('Please enter the percentage fee that you wish to offer to affiliates for this order.'),
        input: 'range',
        inputAttributes: {
          min: (baseFee / 100).toFixed(1),
          max: 50,
          step: 0.1,
          value: 0 // Set the initial value as needed
        },
        inputValue: (baseFee / 100).toFixed(1), // Set the initial value as needed
        showCancelButton: true,
        inputLabel: 'Percentage',
        preConfirm: (value) => {
        }
      }).then(async (result) => {
        if (result.isConfirmed) {
          var value = parseInt(result.value) * parseInt(100);
          try {
            setActionActive(myaccounts+"changeOrderFee"+listing.hash, true);
            if(accountprivkey != "") {
              const gasEstimate = 50000;
              var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
              if(!res) {
                return;
              }
            }
            showLoader();
            await DDEcontract.methods.changeReferralFee(listing.hash, value).send({ "from": myaccounts, ...gasOptions[gasSetting] });
            hideLoader();
            Swal.fire(translateThis("Success!"));
            await loadUser();
          } catch (error) {
            console.log(error);
            hideLoader();
            await showError(error);
          } finally {
            setActionActive(myaccounts+"changeOrderFee"+listing.hash, false);
          }
        }
      });
    }

    async function postData(myuserdata) {
      await DDEcontract.methods.adduserdata(JSON.stringify(myuserdata)).send({"from":myaccounts,...gasOptions[gasSetting]});
      await Swal.fire(translateThis("Data added!"));
    }

    async function addAPI(text) {
      var data = CryptoJS.AES.encrypt(JSON.stringify(text), AESkey).toString();
      console.log(data)
      try {
        setActionActive(myaccounts+"addAPI"+text, true);
        if(accountprivkey != "") {
          const gasEstimate = 150000;
          var res = await confirmTransaction(gasEstimate, gasEstimate, tokens[0].address);
          if(!res) {
            return;
          }
        }
        showLoader();
        await DDEcontract.methods.adddata(data).send({ "from": myaccounts, ...gasOptions[gasSetting] });
        hideLoader();
        await Swal.fire(translateThis("Data added!"));
      } catch (error) {
        console.error(error);
        hideLoader();
        await showError(error);
      } finally {
        setActionActive(myaccounts+"addAPI"+text, false);
      }
    }
    async function getAPI(index) {
      await DDEcontract.methods.publicdata(index).call().then(function (data) {
        data=JSON.parse(CryptoJS.AES.decrypt(DOMPurify.sanitize(data), AESkey).toString(CryptoJS.enc.Utf8));
        if (data.length === 2) { //using public gateway
          pinataApiKey = data[0];
          pinataSecretApiKey = data[1];
          pinataGateway = 'https://gateway.pinata.cloud/ipfs/';
        } else {
          if (!Array.isArray(data)) {
            data = JSON.parse(data);
          }
          if(data.length === 3) {
            pinataApiKey = data[0];
            pinataSecretApiKey = data[1];
            pinataGateway = data[2];
          } else {
            pinataApiKey = data[0];
            pinataSecretApiKey = data[1];
            pinataGateway = data[2];
            pinataToken = data[3];
          }
        }
      });
    }

    window.addEventListener("load", async function() {
      async function handleEthereum() {
        if (window.ethereum) {
          window.ethereum.on('accountsChanged', async function (newaccounts) {
            console.log('accountsChanges', newaccounts);
            defaultvars();
            await login2();
          });
          window.ethereum.on('chainChanged', async function (thenetworkId) {
            console.log('chainChanged', thenetworkId);
            marketOffers = {'indices': [], 'results': []};
            defaultvars();
            await login2();
          });
        } else {
          console.log("Ethereum object not found, you should consider installing MetaMask!");
        }
      }

      if (document.readyState === 'complete') {
        handleEthereum();
      } else {
        window.addEventListener('DOMContentLoaded', handleEthereum);
      }
    });
    // End Auto Connect Wallet

    // Dark/Light Mode  
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggleButton = document.getElementById('theme-toggle');
      const currentTheme = localStorage.getItem('theme') || 'light';
      document.body.setAttribute('data-theme', currentTheme);
      themeToggleButton.innerHTML = currentTheme === 'dark' ? '<a href="#" class="day-night-icon"><img src="day-icon.png" alt="day icon"/></a>' : '<a href="#" class="day-night-icon"><img src="night-icon.svg" alt="night icon"/></a>';
      currentTheme === 'dark' ? body.classList.add("dark-theme") : body.removeAttribute("class");
      if(currentTheme == 'dark') {
        document.head.insertAdjacentHTML("beforeend", "<style>.main.markets::after { content: ''; background: url('') center no-repeat; position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.25; z-index: -1; }</style>");
      }
      themeToggleButton.addEventListener('click', function() {
        const currentTheme = document.body.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.body.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        themeToggleButton.innerHTML = newTheme === 'dark' ? '<a href="#" class="day-night-icon"><img src="day-icon.png" alt="day icon"/></a>' : '<a href="#" class="day-night-icon"><img src="night-icon.svg" alt="night icon"/></a>';
        currentTheme === 'light' ? body.classList.add("dark-theme") : body.removeAttribute("class");
        if(newTheme == 'light') {
          document.head.insertAdjacentHTML("beforeend", "<style>.main.markets::after { content: ''; background: url('./bitbay-dynamic-peg-hero.png') center/cover; position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.25; z-index: -1; }</style>");
        } else {
          document.head.insertAdjacentHTML("beforeend", "<style>.main.markets::after { content: ''; background: url('') center no-repeat; position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.25; z-index: -1; }</style>");
        }
      });
      document.getElementById("myoffers").innerHTML = '<p>Please login to view offers and contracts.</p>';
      document.getElementById("mycontracts"). innerHTML = '<p>Please login to view offers and contracts.</p>';
    });
    //End Dark/Light Mode
    setInterval(loadUser, 90000);
    document.getElementById("loadingStatus").innerHTML = loader;
    locked = true;
    loadMarkets(0, maxContextLoad[0]).then(() => {
      locked = false;
      currentViewContext = '';
      document.getElementById("loadingStatus").innerHTML = '';
    });
    var accItem = document.getElementsByClassName('accordionItem');
    var accHD = document.getElementsByClassName('accordionItemHeading');

    for (i = 0; i < accHD.length; i++) {
      accHD[i].addEventListener('click', toggleItem, false);
    }
     // my js
    function toggleSidebar() {
      let sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('active');
    }
    // end js
    function toggleItem() {
      var itemClass = this.parentNode.className;
      for (i = 0; i < accItem.length; i++) {
        accItem[i].className = 'accordionItem accordion-close';
      }
      if (itemClass == 'accordionItem accordion-close') {
        this.parentNode.className = 'accordionItem accordion-open';
      }
    }

    // about tabs
    function openCity(evt, cityName) {
      var i, tabcontent, tablinks;
      tabcontent = document.getElementsByClassName("abouttabcontent");
      for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
      }
      tablinks = document.getElementsByClassName("abouttablinks");
      for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
      document.getElementById(cityName).style.display = "block";
      evt.currentTarget.className += " active";
    }

    //Notes:
    //It's an interesting idea to let users post an API key for GPT so that new offers can be curated
    //Having users who iterate all contracts and collect all the tags to share with other users on front end
    //A page that looks like "craigs list/classified ads" to browse all the key words and tags
    //Instructions on how to set up an IPFS node and letting the system synchronize with multiple nodes
    //Having it so users can set up blockchain nodes and let other users access/poll multiple nodes at once through API(like electrum)
    //Making it so users can exchange market data using something like gundb or webrtc/torrent protocols
  </script>
</body>
</html>